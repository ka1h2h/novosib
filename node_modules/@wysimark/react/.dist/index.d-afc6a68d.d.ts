/// <reference types="react" />
import { BaseEditor, Range, Descendant, Editor } from 'slate';
import { HistoryEditor } from 'slate-history';
import { ReactEditor } from 'slate-react';
import React$1 from 'react';
import { JsonObject } from 'type-fest';

/**
 * The return type of `useModal`
 */
declare type UseModalReturnType = {
    open: <T>(Component: React$1.FunctionComponent<T>, props: T) => void;
    close: () => void;
    zIndex: number;
};

declare type Resize = (width: number, height: number) => string;
/**
 * An ActiveImage object represents an instance of an Image which is wholly
 * created based on the URL of the image.
 *
 * Images in Wysimark have the width/height encoded in their URL which looks
 * like either an original image url or a resized image url:
 *
 * - original image:
 *   - https://files.wysimark.com/mezine/i/a/b/c/ruewiou82434--640x480.png
 *   - https://mezine.files.wysimark.com/i/a/b/c/ruewiou82434--640x480.png
 * - resized image:
 *   - https://files.wysimark.com/mezine/r/a/b/c/ruewiou82434--640x480--100x75.png
 *   - https://mezine.wysimark.com/r/a/b/c/ruewiou82434--640x480--100x75.png
 */
declare type ActiveImage = {
    type: "dynamic";
    resize: Resize;
    url: string;
    originalWidth: number;
    originalHeight: number;
    width: number;
    height: number;
} | {
    type: "static";
    url: string;
};
/**
 * The method that created active images that is added to the `Editor` instance
 */
declare type CreateActiveImage = (url: string) => ActiveImage;
declare type ActiveImageEditor = {
    createActiveImage: CreateActiveImage;
};

/**
 * Upload File Info
 *
 * The shape of information passed from the browser to the upload API.
 */
declare type UploadGenericFileInfo = {
    type: "generic";
    filename: string;
    bytes: number;
};
declare type UploadImageFileInfo = {
    type: "image";
    filename: string;
    bytes: number;
    width: number;
    height: number;
};
declare type UploadFileInfo = UploadGenericFileInfo | UploadImageFileInfo;
/**
 * Upload Base types used to create UploadProps and UploadOptions
 */
declare type DemoUploadBase = {
    type: "demo";
};
declare type BrowserUploadBase = {
    type: "browser";
    appName: string;
    path: string;
    apiKeyId: string;
    apiPublicKey: string;
};
declare type CustomUploadBase = {
    type: "custom";
    data: JsonObject;
};
declare type DisableUploadBase = {
    type: "disabled";
};
/**
 * Upload Props from Upload Base
 *
 * DemoUploadProps, BrowserUploadProps and ServerUploadProps should be exported
 * so that they can be used by the upload servers to confirm that the API
 * matches on the server.
 */
declare type FixedUploadProps = {
    file: UploadFileInfo;
};
declare type DemoUploadProps = FixedUploadProps & DemoUploadBase;
declare type BrowserUploadProps = FixedUploadProps & BrowserUploadBase;
declare type CustomUploadProps = FixedUploadProps & CustomUploadBase;
/**
 * Upload Options from Upload Base
 */
declare type FixedUploadOptions = {
    url: string;
};
declare type DemoUploadOptions = FixedUploadOptions & DemoUploadBase;
declare type BrowserUploadOptions = FixedUploadOptions & BrowserUploadBase;
declare type CustomUploadOptions = FixedUploadOptions & CustomUploadBase;
declare type DisableUploadOptions = DisableUploadBase;
declare type UploadOptions = DemoUploadOptions | CustomUploadOptions | BrowserUploadOptions | DisableUploadOptions;

/**
 * Props that are added to the `editor` object passed in through the
 * `useEditor` method.
 */
declare type UseEditorProps = {
    initialMarkdown: string;
    upload?: UploadOptions;
};
/**
 * Custom Editor Props
 */
declare type CustomEditorProps = ActiveImageEditor & {
    initialMarkdown: string;
    /**
     * Save the last active selection so that when we open a modal, which causes
     * selection loss, we can reselect the previous selection
     */
    lastSelection?: Range;
    lastValue?: Descendant[];
    modalDialog: UseModalReturnType;
    uploadOptions: UploadOptions;
    upload: (files: FileList) => void;
    /**
     * Optionas passed into `UseEditor`
     */
    /**
     * Returns the current markdown value of the Editor.
     *
     * It must iterate the entire document to generate the markdown so it should
     * not be called too often.
     */
    getMarkdown: () => string;
    /**
     * We use a `ref` to the Editor's container instead of the Body itself which
     * is what we used to do because we use the `Editable` directly to render
     * the Editor's body. Unfortunately, it is not easy to get a ref set on
     * the Editor's body directly, we we instead create a ref to the container.
     *
     * From the container, we can look into its children and find the body.
     */
    containerRef: React.RefObject<HTMLDivElement>;
    reorderedLists: {
        [key: string]: true;
    };
    /**
     * Narrow children to only allow RootBlockElement
     */
    children: RootBlockElement[];
};
/**
 * Merged CustomEditor Type
 */
declare type CustomEditor = BaseEditor & ReactEditor & HistoryEditor & CustomEditorProps;

/**
 * Custom Text Mark Properties
 */
declare type MarkProps = {
    bold?: true;
    italic?: true;
    ins?: true;
    del?: true;
    sup?: true;
    sub?: true;
    code?: true;
};
/**
 * Custom Text Type
 */
declare type CustomText = {
    text: string;
} & MarkProps;
/**
 * Unstyled text is found only in code blocks at the moment
 */
declare type UnstyledText = {
    text: string;
};

/**
 * Link Element
 */
declare type LinkElement = {
    type: "link";
    url: string;
    children: CustomText[];
};
declare type InlineElement = LinkElement;

/**
 * Block Quote Element
 */
declare type BlockquoteElement = {
    type: "blockquote";
    children: RootBlockElement[];
};

/**
 * Code Block Language types
 */
declare type CodeLanguage = "text" | "html" | "css" | "js" | "clike";
/**
 * Code Block Element
 */
declare type CodeBlockElement = {
    type: "code-block";
    language: CodeLanguage;
    children: CodeLineElement[];
};
/**
 * Code Line in a Code Block Element
 */
declare type CodeLineElement = {
    type: "code-line";
    children: UnstyledText[];
};

/**
 * Segments within a Line include text and links
 */
declare type Segment = CustomText | InlineElement;

/**
 * Flush Types are the subset of Convertible Types that are flush to the left
 * margin. Currently, that means all the convertible types that are not
 * list item types.
 */
/**
 * Paragraph Element
 */
declare type ParagraphElement = {
    type: "p";
    children: Segment[];
};
/**
 * Heading Element with levels 1 through 6
 */
declare type HeadingElement = {
    type: "heading";
    level: 1 | 2 | 3 | 4 | 5 | 6;
    children: Segment[];
};
/**
 * Simpe Root Block Elements that sit flush (ie. don't have any indent).
 * Headings and Paragraphs.
 */
declare type FlushBlockElement = ParagraphElement | HeadingElement;

/**
 * Table Column Alignment values
 */
declare type TableColumnAlign = "left" | "center" | "right";
/**
 * Table Column values
 */
declare type TableColumn = {
    align: TableColumnAlign;
};
/**
 * Table Element
 */
declare type TableElement = {
    type: "table";
    columns: TableColumn[];
    children: TrElement[];
};
/**
 * Table Row Element
 */
declare type TrElement = {
    type: "tr";
    children: TdElement[];
};
/**
 * Table Cell Element
 *
 * The children of a `TdElement` is exactly one `ParagraphElement`.
 *
 * This is a good choice for Slate because copying and pasting a range of
 * elements will split the lowest child element by default. If the child of
 * a `TdElement` is a leaf, then we split the `TdElement` which is never what
 * we want.
 *
 * Instead, by having a lower level element, the `ParagraphElement`, we allow
 * that to be split.
 *
 * But of course, insertion means we have many child elements in the `TdElement`
 * but these are easier to fix using normalization. We can keep iterating
 * through normalizations until we end up with a single Paragraph.
 */
declare type TdElement = {
    type: "td";
    index: number;
    children: [ParagraphElement];
};

/**
 * The children in a void node always has one text Node that is empty
 */
declare type VoidChildren = [{
    text: "";
}];
/**
 * Media Element
 */
declare type MediaElement = {
    type: "media";
    url: string;
    alt: string;
    children: VoidChildren;
};
/**
 * Horizontal Rule Element
 */
declare type HrElement = {
    type: "hr";
    children: VoidChildren;
};
declare type VoidElement = MediaElement | HrElement;

/**
 * Convertible Types
 *
 * Convertible types are the element types that can easily be converted from
 * one type to another. Specifically, we typically don't insert convertible
 * types into the document. Instead, we toggle from a type like a `p` type
 * to a `heading` type or some form of `ListItemElement` type.
 */
declare type ConvertibleBlockElement = FlushBlockElement | ListItemElement;
/**
 * Nested Block Elements like `table` and `code-block`
 */
declare type NestedBlockElement = TableElement | CodeBlockElement;
/**
 * Primary Block Elements
 *
 * All the block elements that can be the immediate children of a `blockquote`
 * with the exception of another `blockquote`. This type is primarily used to
 * identify the boundaries of `clearRange` which allows for deletes without
 * inappropriately joining nested elements with other elements.
 */
declare type PrimaryBlockElement = ConvertibleBlockElement | VoidElement | NestedBlockElement;
/**
 * Root Block Elements
 *
 * All the elements that can be found at the root of a document
 *
 * Any Block Element that can be at the root level of the editor (ie. the
 * direct children of the Editor object)
 */
declare type RootBlockElement = PrimaryBlockElement | BlockquoteElement;
/**
 * Any Block Element that is not at the root level of the editor like table
 * rows or code lines that are within a code block.
 */
declare type NonRootBlockElement = TrElement | TdElement | CodeLineElement;
/**
 * Block Elements
 *
 * All of the block element types
 */
declare type BlockElement = RootBlockElement | NonRootBlockElement;
/**
 * All Element types including Block and Segment
 */
declare type CustomElement = BlockElement | InlineElement;

/**
 * Ordered List Item Element
 */
declare type OrderedListItemElement = {
    type: "ordered-list-item";
    depth: number;
    number: number;
    children: Segment[];
};
/**
 * Unordered List Item Element
 */
declare type UnorderedListItemElement = {
    type: "unordered-list-item";
    depth: number;
    children: Segment[];
};
/**
 * Checkable Task List Item Element
 */
declare type TaskListItemElement = {
    type: "task-list-item";
    depth: number;
    checked: boolean;
    children: Segment[];
};
/**
 * Any List Item Element
 */
declare type ListItemElement = OrderedListItemElement | UnorderedListItemElement | TaskListItemElement;

/**
 * T
 */
declare type EditorEvent = {
    /**
     * Do not change to `editor`.
     *
     * We use `getEditor` because in some scenarios, we only have a ref to the
     * editor. We need to use the `getEditor` method so that we can dereference
     * the `editor` from the `ref`.
     *
     * A notable place where this happens is the return value of
     * `editor/standalone`.
     */
    getEditor: () => Editor | null;
    getMarkdown: () => string;
    getData: () => {
        markdown: string;
    };
};

/**
 * All these types are associated with the `Wysimark` component that make up the
 * editor. This includes `<ModalProvider />`, `<Slate />`, the `<EditorToolbar />`,
 * `<Editable />` and various styled components.
 */
/**
 * OnChange callback
 */
declare type OnChange = (event: EditorEvent) => void;
/**
 * These props are the subset of all the `WysimarkProps` that will be passed
 * to the <Slate /> component either directly as a prop, or indirectly through
 * a callback that is attached to `Slate`.
 */
declare type WysimarkSlateProps = {
    editor: Editor;
    onChange?: OnChange;
    onUpdate?: OnChange;
    throttle?: number;
};
/**
 * Props that are passed into the Wysimark component except for those that
 * are part of `WysimarkSlateProps` above.
 */
declare type WysimarkContainerProps = {
    "data-cy"?: string;
    showInitial?: boolean;
    minHeight?: number;
    maxHeight?: number;
    onBlur?: OnChange;
};

/**
 * Extend Slate's Element and Text type with our CustomTypes
 */
declare module "slate" {
    interface CustomTypes {
        Editor: CustomEditor;
        Element: CustomElement;
        Text: CustomText;
    }
}

/**
 * Main Entry Point for Wysimark
 */
declare const Wysimark: ({ editor, onChange: onChangeProp, onUpdate: onUpdateProp, onBlur: onBlurProp, throttle, ...renderWysimarkProps }: WysimarkSlateProps & WysimarkContainerProps) => JSX.Element;

export { BrowserUploadProps as B, CustomEditor as C, DemoUploadProps as D, EditorEvent as E, OnChange as O, UseEditorProps as U, Wysimark as W, UploadFileInfo as a, CustomUploadProps as b };
