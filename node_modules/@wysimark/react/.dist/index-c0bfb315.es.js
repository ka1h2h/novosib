import 'prop-types';
import React, { useState, useContext, useEffect, useCallback, useMemo, useRef, createContext, createRef } from 'react';
import ReactDOM from 'react-dom';
import { ReactEditor, useSlateStatic, useSelected, useFocused, useReadOnly, Editable, useSlate, Slate, withReact } from 'slate-react';
import { Element, Transforms, Editor, Node, Path, Text, Range, Point, createEditor } from 'slate';
import moveImagesToRoot from 'mdast-move-images-to-root';
import remarkDisableTokenizers from 'remark-disable-tokenizers';
import remarkInlineLinks from 'remark-inline-links';
import remarkParse from 'remark-parse';
import remarkSubSuper from 'remark-sub-super';
import unified from 'unified';
import cx from 'classnames';
import isUrl from 'is-url';
import styled from '@emotion/styled';
import isHotkey from 'is-hotkey';
import { css, Global, CacheProvider } from '@emotion/core';
import copyToClipboard from 'copy-to-clipboard';
import Prism from 'prismjs';
import { withHistory } from 'slate-history';
import { AssertType } from '@thesunny/assert-type';
import shallowEqual from 'shallowequal';
import axios from 'axios';
import prettyBytes from 'pretty-bytes';
import extraScopePlugin from 'stylis-plugin-extra-scope';
import createCache from '@emotion/cache';
import { getUrlInfo } from '@wysimark/resource';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

var isObject_1 = isObject;

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, basedir, module) {
	return module = {
		path: basedir,
		exports: {},
		require: function (path, base) {
			return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
		}
	}, fn(module, module.exports), module.exports;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

var _freeGlobal = freeGlobal;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = _freeGlobal || freeSelf || Function('return this')();

var _root = root;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return _root.Date.now();
};

var now_1 = now;

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

var _trimmedEndIndex = trimmedEndIndex;

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, _trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

var _baseTrim = baseTrim;

/** Built-in value references. */
var Symbol = _root.Symbol;

var _Symbol = Symbol;

/** Used for built-in method references. */
var objectProto$f = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$d = objectProto$f.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$f.toString;

/** Built-in value references. */
var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty$d.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}

var _getRawTag = getRawTag;

/** Used for built-in method references. */
var objectProto$e = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto$e.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

var _objectToString = objectToString;

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? _getRawTag(value)
    : _objectToString(value);
}

var _baseGetTag = baseGetTag;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

var isObjectLike_1 = isObjectLike;

/** `Object#toString` result references. */
var symbolTag$3 = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike_1(value) && _baseGetTag(value) == symbolTag$3);
}

var isSymbol_1 = isSymbol;

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol_1(value)) {
    return NAN;
  }
  if (isObject_1(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject_1(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = _baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

var toNumber_1 = toNumber;

/** Error message constants. */
var FUNC_ERROR_TEXT$2 = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$2 = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT$2);
  }
  wait = toNumber_1(wait) || 0;
  if (isObject_1(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax$2(toNumber_1(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing
      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now_1();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now_1());
  }

  function debounced() {
    var time = now_1(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

var debounce_1 = debounce;

/** Error message constants. */
var FUNC_ERROR_TEXT$1 = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  if (isObject_1(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce_1(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

var throttle_1 = throttle;

function defineElementType() {
    /**
     * After the first call, we have specified `T` which extends `Element`.
     * This is the type that we want to check against. We specify it in the
     * method above because in this method below, we want to infer the type.
     *
     * TypeScript does not allow inferring some generics and specifying others.
     * See this issue: https://github.com/microsoft/TypeScript/issues/26242
     *
     * We infer the type as `UType` below and then we check it against the
     * specified type above. We also take another argument which should always
     * be passed in as `true`.
     *
     * We run an `IsEqual` generic as the type for `test` which will return
     * `true` if the specified Generic type above and the inferred one passed
     * in as the first argument match exactly (ie. not under or over specified).
     */
    return function createCheckWithTypeList(list, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _test // IMPORTANT: required for type checking
    ) {
        /**
         * This is the method that does the actual check. It also creates a type
         * guard that matches the type `T` passed in as the original generic.
         */
        return [
            list,
            function check(node) {
                return Element.isElement(node) && list.includes(node.type);
            },
        ];
    };
}

/**
 * `isInlineElement`
 *
 * IMPORTANT: `isInlineElement` overrides `editor.isInline`
 */
const [INLINE_TYPES, isInlineElement] = defineElementType()(["link"], true);
/**
 * `isVoidElement`
 *
 * IMPORTANT: `isVoidElement` overrides `editor.isVoid`
 *
 * We define it as any `Element` that has as its children `VoidChildren`.
 * This ensures that the Void Element is defined properly with `VoidChildren`
 */
const [VOID_TYPES$1, isVoidElement] = defineElementType()(["hr", "media"], true);
const [SEAMLESS_TYPES, isSeamlessElement] = defineElementType()(["table", "hr", "media", "code-block", "blockquote"], true);
AssertType.Equal(true);
/**
 * Flush Block Types
 */
const [FLUSH_TYPES, isFlushElement] = defineElementType()(["p", "heading"], true);
/**
 * List Item Types
 */
const [LIST_ITEM_TYPES, isListItemElement] = defineElementType()(["ordered-list-item", "unordered-list-item", "task-list-item"], true);
const [CONVERTIBLE_TYPES, isConvertibleBlockElement] = defineElementType()([...FLUSH_TYPES, ...LIST_ITEM_TYPES], true);
const [NESTED_BLOCK_TYPES, isNestedBlockElement] = defineElementType()(["table", "code-block"], true);
const [PRIMARY_BLOCK_TYPES, isPrimaryBlockElement] = defineElementType()([...CONVERTIBLE_TYPES, ...VOID_TYPES$1, ...NESTED_BLOCK_TYPES], true);
const [ROOT_BLOCK_TYPES, isRootBlockElement] = defineElementType()([...PRIMARY_BLOCK_TYPES, "blockquote"], true);
const [BLOCK_TYPES, isBlockElement] = defineElementType()([...ROOT_BLOCK_TYPES, "tr", "td", "code-line"], true);
/**
 * Takes a `Node` and returns whether the node is of the given type.
 *
 * Provides type narrowing.
 */
function isElementByType(node, type) {
    if (node == undefined)
        return false;
    return Element.isElement(node) && node.type === type;
}
/**
 * Similar to `isElementByType` but returns a function that takes a node as
 * the first argument which you are checking against the type. Can be useful
 * in `match` arguments in Slate which expect a function.
 */
function IsElementByType(type) {
    return function isElementType(node) {
        if (node == undefined)
            return false;
        return Element.isElement(node) && node.type === type;
    };
}

/**
 * Custom Text Mark Properties
 */
/**
 * All the keys in MarkProps
 */
const MARK_KEYS = [
    "bold",
    "italic",
    "ins",
    "del",
    "sup",
    "sub",
    "code",
];

/**
 * exhaustiveness type check for switch or if/else statements
 *
 * <https://stackoverflow.com/questions/39419170/how-do-i-check-that-a-switch-block-is-exhaustive-in-typescript>
 */
function assertUnreachable(x) {
    console.error("This should be unreachable");
    console.log(x);
    throw new Error("This should be unreachable code");
}

const parser = unified()
    .use(remarkParse)
    .use(remarkSubSuper)
    .use(remarkDisableTokenizers, { inline: ["url"] });
/**
 * Takes some markdown and returns an ast making sure to add the propery
 * plugins along the way.
 */
function parseAst(markdown) {
    const ast = parser.parse(markdown);
    /**
     * Turns links with references are turned into inline links.
     */
    remarkInlineLinks()(ast);
    /**
     * Must be after `remarkInlineLinks` because inline links creates images
     */
    moveImagesToRoot()(ast);
    return ast.children;
}

/**
 * Parse a block quote
 */
function parseBlockquote(node) {
    return {
        type: "blockquote",
        children: parseRootNodes(node.children),
    };
}

/**
 * Map to the proper language for syntax highlighting
 */
const LANGUAGE_MAP = {
    text: "text",
    html: "html",
    xml: "html",
    css: "css",
    javascript: "js",
    js: "js",
    c: "clike",
    java: "clike",
    clike: "clike",
};
/**
 * Parse a code block
 */
function parseCodeBlockNode(node) {
    const markdown = node.value;
    const codelines = markdown
        .split("\n")
        .map((text) => ({ type: "code-line", children: [{ text: text }] }));
    const nodeLang = node.lang;
    const language = LANGUAGE_MAP[nodeLang ? nodeLang : "text"] || "text";
    return {
        type: "code-block",
        language,
        children: codelines,
    };
}
/**
 * Parse a block of HTML such that it turns into code blocks.
 *
 * Technically, this means we don't support HTML. Pragmatically, we would never
 * want to support HTML as it means security holes everywhere.
 */
function parseHtmlBlockNode(node) {
    const codelines = node.value
        .split("\n")
        .map((text) => ({ type: "code-line", children: [{ text: text }] }));
    return { type: "code-block", language: "html", children: codelines };
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

var _listCacheClear = listCacheClear;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

var eq_1 = eq;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq_1(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

var _assocIndexOf = assocIndexOf;

/** Used for built-in method references. */
var arrayProto$1 = Array.prototype;

/** Built-in value references. */
var splice$1 = arrayProto$1.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice$1.call(data, index, 1);
  }
  --this.size;
  return true;
}

var _listCacheDelete = listCacheDelete;

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

var _listCacheGet = listCacheGet;

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return _assocIndexOf(this.__data__, key) > -1;
}

var _listCacheHas = listCacheHas;

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

var _listCacheSet = listCacheSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = _listCacheClear;
ListCache.prototype['delete'] = _listCacheDelete;
ListCache.prototype.get = _listCacheGet;
ListCache.prototype.has = _listCacheHas;
ListCache.prototype.set = _listCacheSet;

var _ListCache = ListCache;

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new _ListCache;
  this.size = 0;
}

var _stackClear = stackClear;

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

var _stackDelete = stackDelete;

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

var _stackGet = stackGet;

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

var _stackHas = stackHas;

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag$2 = '[object Function]',
    genTag$1 = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject_1(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = _baseGetTag(value);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}

var isFunction_1 = isFunction;

/** Used to detect overreaching core-js shims. */
var coreJsData = _root['__core-js_shared__'];

var _coreJsData = coreJsData;

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

var _isMasked = isMasked;

/** Used for built-in method references. */
var funcProto$2 = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$2 = funcProto$2.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

var _toSource = toSource;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto$1 = Function.prototype,
    objectProto$d = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$1 = funcProto$1.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$c = objectProto$d.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString$1.call(hasOwnProperty$c).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject_1(value) || _isMasked(value)) {
    return false;
  }
  var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
  return pattern.test(_toSource(value));
}

var _baseIsNative = baseIsNative;

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

var _getValue = getValue;

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = _getValue(object, key);
  return _baseIsNative(value) ? value : undefined;
}

var _getNative = getNative;

/* Built-in method references that are verified to be native. */
var Map$1 = _getNative(_root, 'Map');

var _Map = Map$1;

/* Built-in method references that are verified to be native. */
var nativeCreate = _getNative(Object, 'create');

var _nativeCreate = nativeCreate;

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
  this.size = 0;
}

var _hashClear = hashClear;

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

var _hashDelete = hashDelete;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto$c = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$b = objectProto$c.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (_nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? undefined : result;
  }
  return hasOwnProperty$b.call(data, key) ? data[key] : undefined;
}

var _hashGet = hashGet;

/** Used for built-in method references. */
var objectProto$b = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$a = objectProto$b.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$a.call(data, key);
}

var _hashHas = hashHas;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
  return this;
}

var _hashSet = hashSet;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = _hashClear;
Hash.prototype['delete'] = _hashDelete;
Hash.prototype.get = _hashGet;
Hash.prototype.has = _hashHas;
Hash.prototype.set = _hashSet;

var _Hash = Hash;

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new _Hash,
    'map': new (_Map || _ListCache),
    'string': new _Hash
  };
}

var _mapCacheClear = mapCacheClear;

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

var _isKeyable = isKeyable;

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return _isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

var _getMapData = getMapData;

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = _getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

var _mapCacheDelete = mapCacheDelete;

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return _getMapData(this, key).get(key);
}

var _mapCacheGet = mapCacheGet;

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return _getMapData(this, key).has(key);
}

var _mapCacheHas = mapCacheHas;

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = _getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

var _mapCacheSet = mapCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = _mapCacheClear;
MapCache.prototype['delete'] = _mapCacheDelete;
MapCache.prototype.get = _mapCacheGet;
MapCache.prototype.has = _mapCacheHas;
MapCache.prototype.set = _mapCacheSet;

var _MapCache = MapCache;

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof _ListCache) {
    var pairs = data.__data__;
    if (!_Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new _MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

var _stackSet = stackSet;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new _ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = _stackClear;
Stack.prototype['delete'] = _stackDelete;
Stack.prototype.get = _stackGet;
Stack.prototype.has = _stackHas;
Stack.prototype.set = _stackSet;

var _Stack = Stack;

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

var _arrayEach = arrayEach;

var defineProperty = (function() {
  try {
    var func = _getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

var _defineProperty = defineProperty;

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && _defineProperty) {
    _defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

var _baseAssignValue = baseAssignValue;

/** Used for built-in method references. */
var objectProto$a = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$9 = objectProto$a.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$9.call(object, key) && eq_1(objValue, value)) ||
      (value === undefined && !(key in object))) {
    _baseAssignValue(object, key, value);
  }
}

var _assignValue = assignValue;

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      _baseAssignValue(object, key, newValue);
    } else {
      _assignValue(object, key, newValue);
    }
  }
  return object;
}

var _copyObject = copyObject;

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

var _baseTimes = baseTimes;

/** `Object#toString` result references. */
var argsTag$3 = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike_1(value) && _baseGetTag(value) == argsTag$3;
}

var _baseIsArguments = baseIsArguments;

/** Used for built-in method references. */
var objectProto$9 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$8 = objectProto$9.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = _baseIsArguments(function() { return arguments; }()) ? _baseIsArguments : function(value) {
  return isObjectLike_1(value) && hasOwnProperty$8.call(value, 'callee') &&
    !propertyIsEnumerable$1.call(value, 'callee');
};

var isArguments_1 = isArguments;

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

var isArray_1 = isArray;

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

var stubFalse_1 = stubFalse;

var isBuffer_1 = createCommonjsModule(function (module, exports) {
/** Detect free variable `exports`. */
var freeExports = exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? _root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse_1;

module.exports = isBuffer;
});

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$2 = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$2 : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

var _isIndex = isIndex;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
}

var isLength_1 = isLength;

/** `Object#toString` result references. */
var argsTag$2 = '[object Arguments]',
    arrayTag$2 = '[object Array]',
    boolTag$3 = '[object Boolean]',
    dateTag$3 = '[object Date]',
    errorTag$2 = '[object Error]',
    funcTag$1 = '[object Function]',
    mapTag$5 = '[object Map]',
    numberTag$3 = '[object Number]',
    objectTag$4 = '[object Object]',
    regexpTag$3 = '[object RegExp]',
    setTag$5 = '[object Set]',
    stringTag$3 = '[object String]',
    weakMapTag$2 = '[object WeakMap]';

var arrayBufferTag$3 = '[object ArrayBuffer]',
    dataViewTag$4 = '[object DataView]',
    float32Tag$2 = '[object Float32Array]',
    float64Tag$2 = '[object Float64Array]',
    int8Tag$2 = '[object Int8Array]',
    int16Tag$2 = '[object Int16Array]',
    int32Tag$2 = '[object Int32Array]',
    uint8Tag$2 = '[object Uint8Array]',
    uint8ClampedTag$2 = '[object Uint8ClampedArray]',
    uint16Tag$2 = '[object Uint16Array]',
    uint32Tag$2 = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] =
typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] =
typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] =
typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] =
typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] =
typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] =
typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] =
typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] =
typedArrayTags[mapTag$5] = typedArrayTags[numberTag$3] =
typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$3] =
typedArrayTags[setTag$5] = typedArrayTags[stringTag$3] =
typedArrayTags[weakMapTag$2] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike_1(value) &&
    isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];
}

var _baseIsTypedArray = baseIsTypedArray;

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

var _baseUnary = baseUnary;

var _nodeUtil = createCommonjsModule(function (module, exports) {
/** Detect free variable `exports`. */
var freeExports = exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && _freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;
});

/* Node.js helper references. */
var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;

var isTypedArray_1 = isTypedArray;

/** Used for built-in method references. */
var objectProto$8 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray_1(value),
      isArg = !isArr && isArguments_1(value),
      isBuff = !isArr && !isArg && isBuffer_1(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? _baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$7.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           _isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

var _arrayLikeKeys = arrayLikeKeys;

/** Used for built-in method references. */
var objectProto$7 = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$7;

  return value === proto;
}

var _isPrototype = isPrototype;

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

var _overArg = overArg;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = _overArg(Object.keys, Object);

var _nativeKeys = nativeKeys;

/** Used for built-in method references. */
var objectProto$6 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$6 = objectProto$6.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!_isPrototype(object)) {
    return _nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$6.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

var _baseKeys = baseKeys;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength_1(value.length) && !isFunction_1(value);
}

var isArrayLike_1 = isArrayLike;

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike_1(object) ? _arrayLikeKeys(object) : _baseKeys(object);
}

var keys_1 = keys;

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && _copyObject(source, keys_1(source), object);
}

var _baseAssign = baseAssign;

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

var _nativeKeysIn = nativeKeysIn;

/** Used for built-in method references. */
var objectProto$5 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$5 = objectProto$5.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject_1(object)) {
    return _nativeKeysIn(object);
  }
  var isProto = _isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty$5.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

var _baseKeysIn = baseKeysIn;

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike_1(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);
}

var keysIn_1 = keysIn;

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && _copyObject(source, keysIn_1(source), object);
}

var _baseAssignIn = baseAssignIn;

var _cloneBuffer = createCommonjsModule(function (module, exports) {
/** Detect free variable `exports`. */
var freeExports = exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? _root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;
});

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

var _copyArray = copyArray;

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

var _arrayFilter = arrayFilter;

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

var stubArray_1 = stubArray;

/** Used for built-in method references. */
var objectProto$4 = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto$4.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols$1 ? stubArray_1 : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return _arrayFilter(nativeGetSymbols$1(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

var _getSymbols = getSymbols;

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return _copyObject(source, _getSymbols(source), object);
}

var _copySymbols = copySymbols;

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

var _arrayPush = arrayPush;

/** Built-in value references. */
var getPrototype = _overArg(Object.getPrototypeOf, Object);

var _getPrototype = getPrototype;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray_1 : function(object) {
  var result = [];
  while (object) {
    _arrayPush(result, _getSymbols(object));
    object = _getPrototype(object);
  }
  return result;
};

var _getSymbolsIn = getSymbolsIn;

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return _copyObject(source, _getSymbolsIn(source), object);
}

var _copySymbolsIn = copySymbolsIn;

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray_1(object) ? result : _arrayPush(result, symbolsFunc(object));
}

var _baseGetAllKeys = baseGetAllKeys;

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return _baseGetAllKeys(object, keys_1, _getSymbols);
}

var _getAllKeys = getAllKeys;

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return _baseGetAllKeys(object, keysIn_1, _getSymbolsIn);
}

var _getAllKeysIn = getAllKeysIn;

/* Built-in method references that are verified to be native. */
var DataView = _getNative(_root, 'DataView');

var _DataView = DataView;

/* Built-in method references that are verified to be native. */
var Promise$1 = _getNative(_root, 'Promise');

var _Promise = Promise$1;

/* Built-in method references that are verified to be native. */
var Set = _getNative(_root, 'Set');

var _Set = Set;

/* Built-in method references that are verified to be native. */
var WeakMap = _getNative(_root, 'WeakMap');

var _WeakMap = WeakMap;

/** `Object#toString` result references. */
var mapTag$4 = '[object Map]',
    objectTag$3 = '[object Object]',
    promiseTag = '[object Promise]',
    setTag$4 = '[object Set]',
    weakMapTag$1 = '[object WeakMap]';

var dataViewTag$3 = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = _toSource(_DataView),
    mapCtorString = _toSource(_Map),
    promiseCtorString = _toSource(_Promise),
    setCtorString = _toSource(_Set),
    weakMapCtorString = _toSource(_WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = _baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag$3) ||
    (_Map && getTag(new _Map) != mapTag$4) ||
    (_Promise && getTag(_Promise.resolve()) != promiseTag) ||
    (_Set && getTag(new _Set) != setTag$4) ||
    (_WeakMap && getTag(new _WeakMap) != weakMapTag$1)) {
  getTag = function(value) {
    var result = _baseGetTag(value),
        Ctor = result == objectTag$3 ? value.constructor : undefined,
        ctorString = Ctor ? _toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag$3;
        case mapCtorString: return mapTag$4;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag$4;
        case weakMapCtorString: return weakMapTag$1;
      }
    }
    return result;
  };
}

var _getTag = getTag;

/** Used for built-in method references. */
var objectProto$3 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$4 = objectProto$3.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty$4.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

var _initCloneArray = initCloneArray;

/** Built-in value references. */
var Uint8Array = _root.Uint8Array;

var _Uint8Array = Uint8Array;

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new _Uint8Array(result).set(new _Uint8Array(arrayBuffer));
  return result;
}

var _cloneArrayBuffer = cloneArrayBuffer;

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? _cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

var _cloneDataView = cloneDataView;

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

var _cloneRegExp = cloneRegExp;

/** Used to convert symbols to primitives and strings. */
var symbolProto$2 = _Symbol ? _Symbol.prototype : undefined,
    symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
}

var _cloneSymbol = cloneSymbol;

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? _cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

var _cloneTypedArray = cloneTypedArray;

/** `Object#toString` result references. */
var boolTag$2 = '[object Boolean]',
    dateTag$2 = '[object Date]',
    mapTag$3 = '[object Map]',
    numberTag$2 = '[object Number]',
    regexpTag$2 = '[object RegExp]',
    setTag$3 = '[object Set]',
    stringTag$2 = '[object String]',
    symbolTag$2 = '[object Symbol]';

var arrayBufferTag$2 = '[object ArrayBuffer]',
    dataViewTag$2 = '[object DataView]',
    float32Tag$1 = '[object Float32Array]',
    float64Tag$1 = '[object Float64Array]',
    int8Tag$1 = '[object Int8Array]',
    int16Tag$1 = '[object Int16Array]',
    int32Tag$1 = '[object Int32Array]',
    uint8Tag$1 = '[object Uint8Array]',
    uint8ClampedTag$1 = '[object Uint8ClampedArray]',
    uint16Tag$1 = '[object Uint16Array]',
    uint32Tag$1 = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$2:
      return _cloneArrayBuffer(object);

    case boolTag$2:
    case dateTag$2:
      return new Ctor(+object);

    case dataViewTag$2:
      return _cloneDataView(object, isDeep);

    case float32Tag$1: case float64Tag$1:
    case int8Tag$1: case int16Tag$1: case int32Tag$1:
    case uint8Tag$1: case uint8ClampedTag$1: case uint16Tag$1: case uint32Tag$1:
      return _cloneTypedArray(object, isDeep);

    case mapTag$3:
      return new Ctor;

    case numberTag$2:
    case stringTag$2:
      return new Ctor(object);

    case regexpTag$2:
      return _cloneRegExp(object);

    case setTag$3:
      return new Ctor;

    case symbolTag$2:
      return _cloneSymbol(object);
  }
}

var _initCloneByTag = initCloneByTag;

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject_1(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

var _baseCreate = baseCreate;

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !_isPrototype(object))
    ? _baseCreate(_getPrototype(object))
    : {};
}

var _initCloneObject = initCloneObject;

/** `Object#toString` result references. */
var mapTag$2 = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike_1(value) && _getTag(value) == mapTag$2;
}

var _baseIsMap = baseIsMap;

/* Node.js helper references. */
var nodeIsMap = _nodeUtil && _nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? _baseUnary(nodeIsMap) : _baseIsMap;

var isMap_1 = isMap;

/** `Object#toString` result references. */
var setTag$2 = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike_1(value) && _getTag(value) == setTag$2;
}

var _baseIsSet = baseIsSet;

/* Node.js helper references. */
var nodeIsSet = _nodeUtil && _nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? _baseUnary(nodeIsSet) : _baseIsSet;

var isSet_1 = isSet;

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG$2 = 1,
    CLONE_FLAT_FLAG$1 = 2,
    CLONE_SYMBOLS_FLAG$2 = 4;

/** `Object#toString` result references. */
var argsTag$1 = '[object Arguments]',
    arrayTag$1 = '[object Array]',
    boolTag$1 = '[object Boolean]',
    dateTag$1 = '[object Date]',
    errorTag$1 = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag$1 = '[object Map]',
    numberTag$1 = '[object Number]',
    objectTag$2 = '[object Object]',
    regexpTag$1 = '[object RegExp]',
    setTag$1 = '[object Set]',
    stringTag$1 = '[object String]',
    symbolTag$1 = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag$1 = '[object ArrayBuffer]',
    dataViewTag$1 = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] =
cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] =
cloneableTags[boolTag$1] = cloneableTags[dateTag$1] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag$1] =
cloneableTags[numberTag$1] = cloneableTags[objectTag$2] =
cloneableTags[regexpTag$1] = cloneableTags[setTag$1] =
cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag$1] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG$2,
      isFlat = bitmask & CLONE_FLAT_FLAG$1,
      isFull = bitmask & CLONE_SYMBOLS_FLAG$2;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject_1(value)) {
    return value;
  }
  var isArr = isArray_1(value);
  if (isArr) {
    result = _initCloneArray(value);
    if (!isDeep) {
      return _copyArray(value, result);
    }
  } else {
    var tag = _getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer_1(value)) {
      return _cloneBuffer(value, isDeep);
    }
    if (tag == objectTag$2 || tag == argsTag$1 || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : _initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? _copySymbolsIn(value, _baseAssignIn(result, value))
          : _copySymbols(value, _baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = _initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new _Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet_1(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap_1(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? _getAllKeysIn : _getAllKeys)
    : (isFlat ? keysIn_1 : keys_1);

  var props = isArr ? undefined : keysFunc(value);
  _arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    _assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

var _baseClone = baseClone;

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG$1 = 1,
    CLONE_SYMBOLS_FLAG$1 = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return _baseClone(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$1);
}

var cloneDeep_1 = cloneDeep;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

var _setCacheAdd = setCacheAdd;

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

var _setCacheHas = setCacheHas;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new _MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
SetCache.prototype.has = _setCacheHas;

var _SetCache = SetCache;

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

var _arraySome = arraySome;

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

var _cacheHas = cacheHas;

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$3 = 1,
    COMPARE_UNORDERED_FLAG$1 = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Check that cyclic values are equal.
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG$1) ? new _SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!_arraySome(other, function(othValue, othIndex) {
            if (!_cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

var _equalArrays = equalArrays;

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

var _mapToArray = mapToArray;

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

var _setToArray = setToArray;

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$2 = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto$1 = _Symbol ? _Symbol.prototype : undefined,
    symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new _Uint8Array(object), new _Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq_1(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = _mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;
      convert || (convert = _setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = _equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

var _equalByTag = equalByTag;

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$1 = 1;

/** Used for built-in method references. */
var objectProto$2 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$3 = objectProto$2.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1,
      objProps = _getAllKeys(object),
      objLength = objProps.length,
      othProps = _getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty$3.call(other, key))) {
      return false;
    }
  }
  // Check that cyclic values are equal.
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

var _equalObjects = equalObjects;

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag$1 = '[object Object]';

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto$1.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray_1(object),
      othIsArr = isArray_1(other),
      objTag = objIsArr ? arrayTag : _getTag(object),
      othTag = othIsArr ? arrayTag : _getTag(other);

  objTag = objTag == argsTag ? objectTag$1 : objTag;
  othTag = othTag == argsTag ? objectTag$1 : othTag;

  var objIsObj = objTag == objectTag$1,
      othIsObj = othTag == objectTag$1,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer_1(object)) {
    if (!isBuffer_1(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new _Stack);
    return (objIsArr || isTypedArray_1(object))
      ? _equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : _equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty$2.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty$2.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new _Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new _Stack);
  return _equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

var _baseIsEqualDeep = baseIsEqualDeep;

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike_1(value) && !isObjectLike_1(other))) {
    return value !== value && other !== other;
  }
  return _baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

var _baseIsEqual = baseIsEqual;

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return _baseIsEqual(value, other);
}

var isEqual_1 = isEqual;

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

var _arrayMap = arrayMap;

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray_1(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol_1(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

var _isKey = isKey;

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || _MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = _MapCache;

var memoize_1 = memoize;

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize_1(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

var _memoizeCapped = memoizeCapped;

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = _memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

var _stringToPath = stringToPath;

/** Used as references for various `Number` constants. */
var INFINITY$2 = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray_1(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return _arrayMap(value, baseToString) + '';
  }
  if (isSymbol_1(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY$2) ? '-0' : result;
}

var _baseToString = baseToString;

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : _baseToString(value);
}

var toString_1 = toString;

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray_1(value)) {
    return value;
  }
  return _isKey(value, object) ? [value] : _stringToPath(toString_1(value));
}

var _castPath = castPath;

/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : undefined;
}

var last_1 = last;

/** Used as references for various `Number` constants. */
var INFINITY$1 = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol_1(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
}

var _toKey = toKey;

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = _castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[_toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

var _baseGet = baseGet;

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

var _baseSlice = baseSlice;

/**
 * Gets the parent value at `path` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} path The path to get the parent value of.
 * @returns {*} Returns the parent value.
 */
function parent(object, path) {
  return path.length < 2 ? object : _baseGet(object, _baseSlice(path, 0, -1));
}

var _parent = parent;

/**
 * The base implementation of `_.unset`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The property path to unset.
 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
 */
function baseUnset(object, path) {
  path = _castPath(path, object);
  object = _parent(object, path);
  return object == null || delete object[_toKey(last_1(path))];
}

var _baseUnset = baseUnset;

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike_1(value) || _baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = _getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$1.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

var isPlainObject_1 = isPlainObject;

/**
 * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
 * objects.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {string} key The key of the property to inspect.
 * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
 */
function customOmitClone(value) {
  return isPlainObject_1(value) ? undefined : value;
}

var _customOmitClone = customOmitClone;

/** Built-in value references. */
var spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray_1(value) || isArguments_1(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

var _isFlattenable = isFlattenable;

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = _isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        _arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

var _baseFlatten = baseFlatten;

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? _baseFlatten(array, 1) : [];
}

var flatten_1 = flatten;

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

var _apply = apply;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$1 = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax$1(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax$1(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return _apply(func, this, otherArgs);
  };
}

var _overRest = overRest;

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

var constant_1 = constant;

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

var identity_1 = identity;

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !_defineProperty ? identity_1 : function(func, string) {
  return _defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant_1(string),
    'writable': true
  });
};

var _baseSetToString = baseSetToString;

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

var _shortOut = shortOut;

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = _shortOut(_baseSetToString);

var _setToString = setToString;

/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */
function flatRest(func) {
  return _setToString(_overRest(func, undefined, flatten_1), func + '');
}

var _flatRest = flatRest;

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * The opposite of `_.pick`; this method creates an object composed of the
 * own and inherited enumerable property paths of `object` that are not omitted.
 *
 * **Note:** This method is considerably slower than `_.pick`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to omit.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.omit(object, ['a', 'c']);
 * // => { 'b': '2' }
 */
var omit = _flatRest(function(object, paths) {
  var result = {};
  if (object == null) {
    return result;
  }
  var isDeep = false;
  paths = _arrayMap(paths, function(path) {
    path = _castPath(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  _copyObject(object, _getAllKeysIn(object), result);
  if (isDeep) {
    result = _baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, _customOmitClone);
  }
  var length = paths.length;
  while (length--) {
    _baseUnset(result, paths[length]);
  }
  return result;
});

var omit_1 = omit;

/**
 * Shortcut for quickly making a token
 */
function token(markdown, string) {
    return {
        markdown,
        string,
    };
}
const SPACE_REGEXP = new RegExp(/^\s+$/);
/**
 * Is this text pure spaces
 */
function isSpace$1(text) {
    return SPACE_REGEXP.test(text);
}
const NON_SPACE_REGEXP = new RegExp(/^\S+$/);
/**
 * Is this text pure non-spaces
 */
function isWord(text) {
    return NON_SPACE_REGEXP.test(text);
}
/**
 * Is this a text segment
 */
function isTextSegment(segment) {
    if (segment == null)
        return false;
    return segment != null && "text" in segment;
}
/**
 * Is this a text segment that contains pure spaces
 */
function isSpaceSegment(segment) {
    return (segment !== undefined && isTextSegment(segment) && isSpace$1(segment.text));
}
/**
 * Is this a link segment
 */
function isLinkSegment(segment) {
    return segment != null && "type" in segment && segment.type === "link";
}

const MARKS_TO_TOKENS = {
    bold: "**",
    italic: "_",
    ins: "++",
    del: "~~",
    sup: "^",
    sub: "~",
};
const MARKS_IN_ORDER = Object.keys(MARKS_TO_TOKENS);
/**
 * Returns marks in preferred order
 *
 * Exported for testing.
 */
function getMarksInOrder(x) {
    const marks = [];
    for (const markInOrder of MARKS_IN_ORDER) {
        if (x[markInOrder]) {
            marks.push(markInOrder);
        }
    }
    return marks;
}
/**
 * Remove marks in preferred order
 */
function removeMarksInOrder(prevMarks, nextMarkProps) {
    const targetMarks = getMarksInOrder(nextMarkProps);
    for (let i = 0; i < prevMarks.length; i++) {
        const prevMark = prevMarks[i];
        if (!targetMarks.includes(prevMark)) {
            return {
                innerMarks: [...prevMarks].slice(0, i),
                removeMarks: [...prevMarks].slice(i).reverse(),
            };
        }
    }
    return { innerMarks: prevMarks, removeMarks: [] };
}
/**
 * Takes a set of marks and then adds new marks until we match the target marks
 */
function addMarksInOrder(prevMarks, nextMarkProps) {
    const addMarks = [];
    const targetMarks = getMarksInOrder(nextMarkProps);
    for (const targetMark of targetMarks) {
        if (!prevMarks.includes(targetMark)) {
            addMarks.push(targetMark);
        }
    }
    return { addMarks, nextMarks: prevMarks.concat(addMarks) };
}
/**
 * Returns information about marks to add and remove but ignores `code` marks
 * because they are handled differently in Markdown.
 */
function diffMarksExceptCode({ prevMarks, nextMarkProps, }) {
    const { removeMarks, innerMarks } = removeMarksInOrder(prevMarks, nextMarkProps);
    const { addMarks, nextMarks } = addMarksInOrder(innerMarks, nextMarkProps);
    return { removeMarks, innerMarks, nextMarks, addMarks };
}
/**
 * Takes an array of marks and tokenizes them except for `code` marks because
 * they are handled differently in Markdown.
 */
function tokenizeMarksExceptCode(marks) {
    const tokens = [];
    for (const mark of marks) {
        if (mark !== "code") {
            tokens.push(MARKS_TO_TOKENS[mark]);
        }
    }
    return tokens.join("");
}

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject_1(object)) {
    return object;
  }
  path = _castPath(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = _toKey(path[index]),
        newValue = value;

    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
      return object;
    }

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject_1(objValue)
          ? objValue
          : (_isIndex(path[index + 1]) ? [] : {});
      }
    }
    _assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

var _baseSet = baseSet;

/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = _baseGet(object, path);

    if (predicate(value, path)) {
      _baseSet(result, _castPath(path, object), value);
    }
  }
  return result;
}

var _basePickBy = basePickBy;

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

var _baseHasIn = baseHasIn;

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = _castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = _toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength_1(length) && _isIndex(key, length) &&
    (isArray_1(object) || isArguments_1(object));
}

var _hasPath = hasPath;

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && _hasPath(object, path, _baseHasIn);
}

var hasIn_1 = hasIn;

/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @returns {Object} Returns the new object.
 */
function basePick(object, paths) {
  return _basePickBy(object, paths, function(value, path) {
    return hasIn_1(object, path);
  });
}

var _basePick = basePick;

/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */
var pick = _flatRest(function(object, paths) {
  return object == null ? {} : _basePick(object, paths);
});

var pick_1 = pick;

/**
 * Takes a TextSegment and returns its marks in preferred order.
 */
function getMarkPropsFromText(text) {
    return omit_1(text, ["text"]);
}
function getMarkPropsFromChildren(segment) {
    const segments = segment.children;
    let markProps = getMarkPropsFromText(segments[0]);
    for (let i = 1; i < segments.length; i++) {
        const segment = segments[i];
        if (isSpaceSegment(segment))
            continue;
        const currentMarks = getMarkPropsFromText(segment);
        markProps = pick_1(markProps, Object.keys(currentMarks));
    }
    return markProps;
}
/**
 * Takes a Segment and returns its marks in preferred order.
 *
 * Must handle segments with children
 */
function getMarkPropsFromSegment(segment) {
    if (segment === undefined)
        return {};
    if (isTextSegment(segment)) {
        return getMarkPropsFromText(segment);
    }
    else if (isLinkSegment(segment)) {
        return getMarkPropsFromChildren(segment);
    }
    else {
        throw new Error(`Unhandled segment ${JSON.stringify(segment)}`);
    }
}
function getMarkPropsFromMarks(marks) {
    return marks.reduce((o, mark) => {
        o[mark] = true;
        return o;
    }, {});
}

const BOUNDARY_REGEXP = new RegExp(/(\s+|\S+)/g);
/**
 * Split text segments at their whitespace boundaries.
 * Split link children at their whiespace boundaries.
 * Do not split code segments.
 *
 * ' a world ' => [' ', 'a', ' ', 'world']
 *
 */
function splitSegmentsAtBoundaries(segments) {
    const nextSegments = [];
    for (const segment of segments) {
        if (isTextSegment(segment)) {
            if (segment.code) {
                /**
                 * If it's a code segment, leave everything in it alone
                 */
                nextSegments.push(segment);
            }
            else {
                /**
                 * If it's not a code segment, then do some splitting
                 */
                const matches = segment.text.match(BOUNDARY_REGEXP) || [];
                for (const match of matches) {
                    if (isWord(match)) {
                        nextSegments.push(Object.assign(Object.assign({}, segment), { text: match }));
                    }
                    else {
                        nextSegments.push({ text: match });
                    }
                }
            }
        }
        else if (isLinkSegment(segment)) {
            nextSegments.push(Object.assign(Object.assign({}, segment), { children: splitSegmentsAtBoundaries(segment.children) }));
        }
        else {
            // throw new Error("Unhandled segment type")
            throw new Error(`Unhandled segment type ${JSON.stringify(segment)}`);
        }
    }
    return nextSegments;
}
/**
 * Merge adjacents spaces unless there are `code` segments
 *
 * ['a', ' ', ' ', 'b'] => ['a', '  ', 'b']
 */
function mergeSpaceSegments(segments) {
    const nextSegments = [];
    for (let i = 0; i < segments.length; i++) {
        const segment = segments[i];
        const lastSegment = segments[i - 1];
        if (isLinkSegment(segment)) {
            nextSegments.push(Object.assign(Object.assign({}, segment), { children: mergeSpaceSegments(segment.children) }));
            continue;
        }
        else if (isTextSegment(segment)) {
            /**
             * If the last segment is a space and the next segment is a space and
             * neither of those segments are code segments, then merge the spaces
             * together.
             */
            if (isSpaceSegment(lastSegment) &&
                isSpaceSegment(segment) &&
                !segment.code &&
                !lastSegment.code) {
                lastSegment.text = `${lastSegment.text}${segment.text}`;
                continue;
            }
            nextSegments.push(segment);
            // } else if (isCodeSegment(segment)) {
            //   nextSegments.push(segment)
        }
        else {
            throw new Error("Unhandled segment type");
        }
    }
    return nextSegments;
}
/**
 * Remove all the empty link segments (no text)
 */
function removeEmptyLinkSegments(segments) {
    const nextSegments = [];
    for (const segment of segments) {
        /** Remove empty segments */
        if (isLinkSegment(segment) &&
            (segment.children.length === 0 ||
                (segment.children.length === 1 && segment.children[0].text === ""))) {
            continue;
        }
        nextSegments.push(segment);
    }
    return nextSegments;
}
/**
 * Removing leading and trailing spaces but always leave at least one
 *
 * [' ', 'a', ' '] => ['a']
 * [' '] => ['']
 */
function trimSegments(segments, { trimStart, trimEnd }) {
    const nextSegments = cloneDeep_1(segments);
    for (const segment of nextSegments) {
        if (isLinkSegment(segment)) {
            segment.children = trimSegments(segment.children, {
                trimStart,
                trimEnd,
            });
        }
    }
    const firstSegment = nextSegments[0];
    if (trimStart && isSpaceSegment(firstSegment) && !firstSegment.code) {
        nextSegments.shift();
    }
    const lastSegment = nextSegments[nextSegments.length - 1];
    if (trimEnd && isSpaceSegment(lastSegment) && !lastSegment.code) {
        nextSegments.pop();
    }
    if (nextSegments.length === 0)
        nextSegments.push({ text: "" });
    return nextSegments;
}
/**
 * Add marks to the space segments depending on its surrounding segments.
 *
 * Must take into account that mark tokens in Markdown must surround only
 * non-space characters
 */
function remarkSpaceSegments(segments) {
    const nextSegments = [];
    let prevMarks = [];
    for (let i = 0; i < segments.length; i++) {
        const segment = segments[i];
        if (isTextSegment(segment)) {
            if (isSpaceSegment(segment)) {
                /**
                 * We note whether the space is a code segment or not at the beginning
                 * because we want to forcefully preserve this later
                 */
                const isCodeMark = !!segment.code;
                /**
                 * Remark the space segment based on the previous marks and the next marks
                 */
                const nextSegment = segments[i + 1];
                const nextMarkProps = getMarkPropsFromSegment(nextSegment);
                const { innerMarks } = diffMarksExceptCode({
                    prevMarks,
                    nextMarkProps: nextMarkProps,
                });
                prevMarks = innerMarks;
                const markProps = getMarkPropsFromMarks(innerMarks);
                /**
                 * This preserved whether the space was originally a code segment or
                 * not. We treat code marks a little differently for spaces because
                 * of how Markdown treats code marks. Namely, code spaces are visible
                 * whereas other marks are not. Also, backticks that are used as tokens
                 * for code marks don't have the requirement of not having a space
                 * inside. Code marks work in all cases whereas other mark types do not.
                 */
                if (isCodeMark) {
                    markProps.code = true;
                }
                else {
                    delete markProps.code;
                }
                nextSegments.push(Object.assign({ text: segment.text }, markProps));
                continue;
            }
            else {
                /**
                 * Set prev marks smartly which should text into account mark order
                 */
                nextSegments.push(Object.assign({}, segment));
                const markProps = getMarkPropsFromSegment(segment);
                const { nextMarks } = diffMarksExceptCode({
                    prevMarks,
                    nextMarkProps: markProps,
                });
                prevMarks = nextMarks;
            }
        }
        else if (isLinkSegment(segment)) {
            /**
             * If we're in a link, remark the inside of the link
             */
            nextSegments.push(Object.assign(Object.assign({}, segment), { children: remarkSpaceSegments(segment.children) }));
        }
    }
    return nextSegments;
}
function mergeSegmentsByMark(segments) {
    const nextSegments = [];
    for (let i = 0; i < segments.length; i++) {
        const segment = segments[i];
        const lastSegment = nextSegments[nextSegments.length - 1];
        if (isLinkSegment(segment)) {
            const children = mergeSegmentsByMark(segment.children);
            nextSegments.push(Object.assign(Object.assign({}, segment), { children }));
        }
        else if (isTextSegment(lastSegment) &&
            isTextSegment(segment) &&
            isEqual_1(omit_1(lastSegment, ["text"]), omit_1(segment, ["text"]))) {
            lastSegment.text = `${lastSegment.text}${segment.text}`;
        }
        else {
            nextSegments.push(Object.assign({}, segment));
        }
    }
    return nextSegments;
}
/**
 * Normalize a line by:
 *
 * - Moving marks so that they are around words
 * - Removing empty link segments
 * - Removing trailing spaces at start and end of lines
 *
 * Generally this means that once a document is normalized it is prepped for
 * serialization. After it's serialized and turned back to JSON, the JSON
 * should match the normalized line perfectly.
 */
function normalizeLine(segments) {
    const splitSegments = splitSegmentsAtBoundaries(segments);
    const mergedSpaceSegments = mergeSpaceSegments(splitSegments);
    const emptiedSegments = removeEmptyLinkSegments(mergedSpaceSegments);
    const trimmedSegments = trimSegments(emptiedSegments, {
        trimStart: true,
        trimEnd: true,
    });
    const remarkedSpaceSegments = remarkSpaceSegments(trimmedSegments);
    const mergedByMarkSegments = mergeSegmentsByMark(remarkedSpaceSegments);
    return mergedByMarkSegments;
}

const BR_REGEXP = /^([<]br\w*[/]?[>])$/;
/**
 * Parse an HTML node and turn it into a code segment (ie. converts inline
 * HTML into inline code)
 */
function parseHTMLNode(node, marks) {
    const markdown = node.value;
    if (markdown.match(BR_REGEXP)) {
        /**
         * It node contains a break, turn it into a newline
         */
        return [Object.assign({ text: "\n" }, marks)];
    }
    else {
        return [
            Object.assign({ text: node.value, code: true }, marks),
            // { type: "code-segment", children: [{ text: node.value, ...marks }] },
        ];
    }
}
/**
 * Parse a link node
 */
function parseLinkNode(node, marks) {
    return {
        type: "link",
        url: node.url,
        children: parseLine(node.children, marks),
    };
}
/**
 * Parse a single inline node which is an Mdast.PhrasingContent and turn it
 * into an array of segments.
 */
function parseInlineNode(node, marks) {
    switch (node.type) {
        case "text": {
            /**
             * Remove zero width spaces.
             *
             * Zero width spaces are sometimes used to preserve certain types of
             * line type styles with a prefix like a list item.
             *
             * If the line was provided as `- ` then it would not be interpreted as
             * a bullet because content is required.
             *
             * We end up using `- &ZeroWidthSpace;` to ensure it is handled as a
             * list item. We clean it up on the way back in and remove it.
             */
            const text = node.value.replace(/\u200B/g, "");
            return [Object.assign({ text }, marks)];
        }
        case "strong":
            return parseLine(node.children, Object.assign(Object.assign({}, marks), { bold: true }));
        case "delete":
            return parseLine(node.children, Object.assign(Object.assign({}, marks), { del: true }));
        case "emphasis":
            return parseLine(node.children, Object.assign(Object.assign({}, marks), { italic: true }));
        case "sub":
            return parseLine(node.children, Object.assign(Object.assign({}, marks), { sub: true }));
        case "sup":
            return parseLine(node.children, Object.assign(Object.assign({}, marks), { sup: true }));
        case "link":
            return [parseLinkNode(node, marks)];
        case "break":
            return [Object.assign({ text: "\n" }, marks)];
        case "inlineCode":
            return [Object.assign({ text: node.value, code: true }, marks)];
        case "html":
            return parseHTMLNode(node, marks);
        case "linkReference": {
            /**
             * The `remark-inline-links` plugin converts reference links to inline
             * links so we only expect to see a `linkReference` when the user has
             * forgotten to include the actual link to reference to.
             *
             * In this case, we don't convert the link and just leave it as
             * straight text.
             */
            const children = node.children;
            return children.map((child) => parseInlineNode(child, marks)).flat();
        }
        case "imageReference":
            return [Object.assign({ text: node.alt || "" }, marks)];
        // TODO: Find a way to handle image, footnot and footnoteReference inside a line
        case "image":
        case "footnote":
        case "footnoteReference":
            return [];
        default:
            assertUnreachable(node);
    }
}
/**
 * Takes a children which is expected to represent a line like the children
 * of a paragraph, heading or list item. Turns this into Segment[] which is
 * the Slate representation.
 */
function parseLine(nodes, marks = {}) {
    /**
     * If there are no nodes, make sure there is at least an empty text node
     */
    if (nodes.length === 0) {
        return [{ text: "" }];
    }
    const segments = [];
    for (const node of nodes) {
        segments.push(...parseInlineNode(node, marks));
    }
    return mergeSegmentsByMark(segments);
}

/**
 * Parse heading
 */
function parseHeadingNode(node) {
    const block = {
        type: "heading",
        level: Math.max(1, Math.min(node.depth, 6)),
        children: parseLine(node.children, {}),
    };
    return block;
}

/**
 * Text any node and extracts all the descendant `text` out of it and turns it
 * into a string
 */
function stringifyNode(node) {
    return convertNodeToTextArray(node).join("");
}
function convertNodeToTextArray(node) {
    if (node.type === "text" || node.type === "code" || node.type === "html")
        return [node.value];
    if (typeof node.children === "undefined")
        return [];
    const texts = [];
    for (const child of node.children) {
        const childTexts = convertNodeToTextArray(child);
        texts.push(...childTexts);
    }
    return texts;
}

/**
 * generate a list item element
 */
function generateListItemElement({ depth, ordered, checked, children, index, }) {
    if (typeof checked === "boolean") {
        return { type: "task-list-item", depth, checked, children };
    }
    else if (ordered) {
        return { type: "ordered-list-item", depth, children, number: index + 1 };
    }
    else {
        return { type: "unordered-list-item", depth, children };
    }
}
/**
 * Parse list item.
 *
 * When it has a child list, we increment the depth and then parse it.
 */
function parseListItemOrBlockquote(srcBlock, { depth, ordered, index }) {
    const blocks = [];
    for (const srcChild of srcBlock.children) {
        switch (srcChild.type) {
            case "paragraph":
            case "heading": {
                const children = srcChild
                    ? parseLine(srcChild.children, {})
                    : [{ text: "" }];
                blocks.push(generateListItemElement({
                    depth,
                    ordered,
                    checked: typeof srcBlock.checked === "boolean"
                        ? srcBlock.checked
                        : undefined,
                    children,
                    index,
                }));
                break;
            }
            case "blockquote":
                blocks.push(...parseListItemOrBlockquote(srcChild, { depth, ordered, index }));
                break;
            case "list":
                blocks.push(...parseListNode(srcChild, { depth: depth + 1 }));
                break;
            case "table":
            case "code":
            case "html": {
                const text = stringifyNode(srcChild);
                blocks.push(generateListItemElement({
                    depth,
                    ordered,
                    checked: typeof srcBlock.checked === "boolean"
                        ? srcBlock.checked
                        : undefined,
                    children: [{ text }],
                    index,
                }));
                break;
            }
            case "thematicBreak":
                /**
                 * Ignore a thematic break
                 */
                break;
            default:
                assertUnreachable(srcChild);
        }
    }
    return blocks;
}
/**
 * Parse an Mdast.List and returns an array of list item blocks
 */
function parseListNode(srcBlock, { depth }) {
    const blocks = [];
    srcBlock.children.forEach((childBlock, index) => {
        blocks.push(...parseListItemOrBlockquote(childBlock, {
            depth,
            ordered: !!srcBlock.ordered,
            index,
        }));
    });
    return blocks;
}

/**
 * Parse media node which comes in as an Mdast.Image
 */
function parseMediaNode(node) {
    return {
        type: "media",
        alt: node.alt || "",
        url: node.url,
        children: [{ text: "" }],
    };
}

/**
 * Parse paragraph
 */
function parseParagraphNode(node) {
    return {
        type: "p",
        children: parseLine(node.children, {}),
    };
}

function assertDefined(x, varName = "value") {
    if (x === undefined) {
        throw new Error(`Expected ${varName} to be defined`);
    }
}

/**
 * Parse table
 */
function parseTableNode(tableNode) {
    const firstRowCells = tableNode.children[0].children;
    assertDefined(tableNode.align, "tableNode.align");
    const align = [...tableNode.align];
    for (let i = align.length; i < firstRowCells.length; i++) {
        align[i] = "left";
    }
    assertDefined(align, "align");
    return {
        type: "table",
        columns: align.map((dir) => dir == null ? { align: "left" } : { align: dir }),
        children: tableNode.children.map((trNode) => ({
            type: "tr",
            children: trNode.children.map((tdNode, index) => ({
                type: "td",
                index: index,
                children: [{ type: "p", children: parseLine(tdNode.children, {}) }],
            })),
        })),
    };
}

/**
 * Parse a Thematic Break.
 *
 * Note that this doesn't actually use the `node` but we are assured that the
 * incoming ast is a Thematic Break. It was tested somewhere earlier to make
 * sure it is of the right type.
 *
 * We include the `node` in arguments so that this code is consistent with the
 * other parse code.
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function parseThematicBreakNode(node) {
    const block = {
        type: "hr",
        children: [{ text: "" }],
    };
    return block;
}

/**
 * Takes an Mdast node and turns it into a slate block
 */
function parseRootNode(node) {
    switch (node.type) {
        case "blockquote":
            return [parseBlockquote(node)];
        case "heading":
            return [parseHeadingNode(node)];
        case "paragraph":
            return [parseParagraphNode(node)];
        case "thematicBreak":
            return [parseThematicBreakNode()];
        case "code":
            return [parseCodeBlockNode(node)];
        case "html":
            return [parseHtmlBlockNode(node)];
        case "image":
            return [parseMediaNode(node)];
        case "list":
            return parseListNode(node, { depth: 0 });
        case "table":
            return [parseTableNode(node)];
        /**
         * This shouldn't happen because remark-inline-links should remove definitions
         *
         * Also ignore yaml front matter as it doesn't appear to get generated.
         * Looks like you need to use `remark-frontmatter` plugin.
         */
        case "definition":
        case "footnoteDefinition":
        case "yaml":
            return [];
        default:
            assertUnreachable(node);
    }
}
/**
 * Parse the root nodes `Mdast.Content[]`
 *
 * WARNING:
 * TODO:
 * This method is incorrectly named at the moment. It is used to parseRootNotes
 * but it is also used, at the moment, to parse the children of a blockquote.
 * We should probably rename this to something like `parseRootOrQuoteNodes`
 * to make this more clear.
 */
function parseRootNodes(nodes) {
    const blocks = [];
    for (const node of nodes) {
        blocks.push(...parseRootNode(node));
    }
    return blocks;
}
/**
 * Takes an array of root blocks at the very top of the AST and adds an empty
 * paragraph if the last block isn't a flush element like a `heading` or a `p`.
 */
function normalizeRootBlocks(blocks) {
    const lastBlock = blocks[blocks.length - 1];
    if (isFlushElement(lastBlock))
        return blocks;
    return [...blocks, { type: "p", children: [{ text: "" }] }];
}
/**
 * If there are no blocks, make sure there is at least one empty paragraph block
 */
function normalizeEmptyBlocks(blocks) {
    if (blocks.length > 0) {
        return blocks;
    }
    return [{ type: "p", children: [{ text: "" }] }];
}
/**
 * Takes markdown and returns a Slate Document
 */
function parse(markdown) {
    const rootNodes = parseAst(markdown);
    const rootBlocks = normalizeRootBlocks(parseRootNodes(rootNodes));
    const normalizedBlocks = normalizeEmptyBlocks(rootBlocks);
    return normalizedBlocks;
}

var ModalType;
(function (ModalType) {
    ModalType[ModalType["Toolbar"] = 0] = "Toolbar";
    ModalType[ModalType["Dialog"] = 1] = "Dialog";
    ModalType[ModalType["Tooltip"] = 2] = "Tooltip";
    ModalType[ModalType["Progress"] = 3] = "Progress";
    ModalType[ModalType["Error"] = 4] = "Error";
})(ModalType || (ModalType = {}));
const ModalsContext = React.createContext(null);
const InModalContext = React.createContext(null);
/**
 * Portal to `document.body`
 *
 * NOTE:
 * Consider creating a version of Portal with the reset in it.
 */
function Portal({ children }) {
    return ReactDOM.createPortal(children, document.body);
}
/**
 * Renders the modal in a portal with the proper context provided to it
 */
function ModalComponent({ data, index }) {
    if (data == null)
        return null;
    const { Component, props, modal } = data;
    const zIndex = 100000 + index;
    modal.zIndex = zIndex;
    const value = { Component, props, modal, index };
    return (React.createElement(Portal, null,
        React.createElement(InModalContext.Provider, { value: value },
            React.createElement(Component, Object.assign({}, props)))));
}
function ModalProvider({ children }) {
    const [modals, setModals] = useState([]);
    return (React.createElement(ModalsContext.Provider, { value: { modals, setModals } },
        children,
        modals.map((data, index) => (React.createElement(ModalComponent, { key: index, index: index, data: data })))));
}
/**
 * Wraps using a class Component because functional components cannot be
 * assigned a `ref` and sometimes the children (i.e. the modal) is passed in
 * as a functional component.
 */
class Wrapper extends React.Component {
    render() {
        const _a = this.props, { children } = _a, props = __rest(_a, ["children"]);
        return React.cloneElement(children, props);
    }
}
/**
 * Use this inside the modal to recalculate the position of the modal
 *
 * It can return values in one of two ways:
 *
 * - As a style object
 * - As an object that contains style objects (for example, tooltip needs to style the arrow and the bubble)
 */
function useReposition(fn, dependencies) {
    const [style, setStyle] = useState({});
    const reposition = throttle_1(() => {
        try {
            setStyle(fn());
        }
        catch (e) {
            // console.warn(e)
        }
    }, 100, { trailing: true });
    useEffect(() => {
        reposition();
        // setTimeout(reposition)
        window.addEventListener("resize", reposition);
        window.addEventListener("scroll", reposition);
        return () => {
            window.removeEventListener("resize", reposition);
            window.removeEventListener("scroll", reposition);
        };
    }, dependencies);
    return style;
}
/**
 * Helper utility that takes a `left` and `top` position (i.e. a style) along
 * with a `getBoundingClientRect` rect and makes sure it is in the viewport.
 */
function fitInViewport({ left, top }, srcRect) {
    // prefer using scrollWidth over innerWidth to account for scrollbar
    const innerWidth = document.body.scrollWidth;
    let nextLeft = left, nextTop = top;
    if (nextLeft + srcRect.width > innerWidth)
        nextLeft = innerWidth - srcRect.width;
    if (nextLeft < 0)
        nextLeft = 0;
    // if (nextTop + srcRect.height > innerHeight)
    //   nextTop = innerHeight - srcRect.height - 32 // padding on bottom
    if (nextTop < 0)
        nextTop = 0;
    return {
        left: nextLeft,
        top: nextTop,
    };
}
/**
 * Use this to open and close modals.
 *
 * Returns a `modal` object.
 */
function useModal(modalType) {
    const modalContext = useContext(ModalsContext);
    /**
     * NOTE:
     *
     * This is defensive. When we use the editor from `wysimark-demo`, calling
     * `useContext` (above) returns `null` on the first render which causes
     * errors.
     *
     * To get around this, we short-circuit and return a similar Object that
     * can't be used to execute; however, since it will remain in this state for
     * such a short period of time, there should be no chance that the user
     * executes the `open` or `close` method.
     */
    if (modalContext == null)
        return {
            // eslint-disable-next-line @typescript-eslint/no-empty-function
            open: () => { },
            // eslint-disable-next-line @typescript-eslint/no-empty-function
            close: () => { },
            zIndex: modalType * 100,
        };
    const { modals, setModals } = modalContext;
    function open(Component, props) {
        const modalData = modals[modalType];
        /**
         * Only set the modal if it has changed to prevent re-rendering
         */
        if (modalData != null &&
            modalData.Component === Component &&
            shallowEqual(modalData.props, props)) {
            return;
        }
        /**
         * Set Modal
         */
        setModals((modals) => {
            const nextModals = [...modals];
            nextModals[modalType] = { modal, Component, props };
            return nextModals;
        });
    }
    function close() {
        setModals((modals) => {
            const nextModals = [...modals];
            delete nextModals[modalType];
            return nextModals;
        });
    }
    const modal = {
        open,
        close,
        // modalType,
        zIndex: modalType * 100,
    };
    return modal;
}
/**
 * Use this to get the modal object from inside the modal
 */
function useInModal() {
    const context = useContext(InModalContext);
    if (context == null)
        throw new Error("Unexpected context returns null");
    const { modal } = context;
    return modal;
}

/* prettier-ignore */
const resetCss = css `
.wm-reset-1.wm-reset-2.wm-reset-3 {

/* Add Box Sizing Fix -SH */
box-sizing: border-box;
*, *::before, *:after {
	box-sizing: inherit;
}

/* Add back in the font awesome icons */
.fa {
  font-family: "Font Awesome 5 Pro";
  font-weight: 900;
}

/* A reset for the Div itself. Custom. */
-moz-osx-font-smoothing: grayscale;
-webkit-font-smoothing: antialiased;
border: 0;
font-family: -apple-system, BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
font-size: 16px;
line-height: 1;
margin: 0;
padding: 0;
vertical-align: baseline;

/* http://meyerweb.com/eric/tools/css/reset/ 
   v2.0 | 20110126
   License: none (public domain)
*/
div, span, applet, object, iframe,
h1, h2, h3, h4, h5, h6, p, blockquote, pre,
a, abbr, acronym, address, big, cite, code,
del, dfn, em, img, ins, kbd, q, s, samp,
small, strike, strong, sub, sup, tt, var,
b, u, i, center,
dl, dt, dd, ol, ul, li,
fieldset, form, label, legend,
table, caption, tbody, tfoot, thead, tr, th, td,
article, aside, canvas, details, embed, 
figure, figcaption, footer, header, hgroup, 
menu, nav, output, ruby, section, summary,
textarea,
time, mark, audio, video,
/* Added hr to this list as it was missing -sh */
hr {
	border: 0;
	font-size: 100%;
	font: inherit;
	margin: 0;
	padding: 0;
	vertical-align: baseline;
}
/* HTML5 display-role reset for older browsers */
article, aside, details, figcaption, figure, 
footer, header, hgroup, menu, nav, section {
	display: block;
}
/* body {
	line-height: 1;
} */
ol, ul {
	list-style: none;
}
blockquote, q {
	quotes: none;
}
blockquote:before, blockquote:after,
q:before, q:after {
	content: '';
	content: none;
}
table {
	border-collapse: collapse;
	border-spacing: 0;
}
}
`;

/**
 * This modifies emotion to prefix everything.
 *
 * Using instructions from here:
 * <https://stackoverflow.com/questions/60567233/how-to-move-global-styles-into-a-scope-for-emotion>
 *
 * Which uses this Stylis plugin:
 * <https://github.com/Andarist/stylis-plugin-extra-scope>
 */
const cache = createCache({
    stylisPlugins: [extraScopePlugin(".wm-reset-1.wm-reset-2.wm-reset-3")],
});
function Reset({ children }) {
    return (React.createElement(React.Fragment, null,
        React.createElement(Global, { styles: resetCss }),
        React.createElement(CacheProvider, { value: cache },
            React.createElement("div", { className: "wm-reset-1 wm-reset-2 wm-reset-3" }, children))));
}
function ResetContainer({ children }) {
    return React.createElement("div", { className: "wm-reset-1 wm-reset-2 wm-reset-3" }, children);
}

/**
 * Used to create an Editor Event for the `onChange` callback
 */
function getEditorEvent(editor) {
    return {
        getEditor() {
            return editor;
        },
        getMarkdown() {
            return editor.getMarkdown();
        },
        getData() {
            return {
                markdown: editor.getMarkdown(),
            };
        },
    };
}

const colors = {
    borderRadius: "0.25em",
    highlight: "#2888ff",
    blockquoteBar: "#ececec",
    editorBorderColor: "#dbdcdd",
    editorBorderRadius: "0.25em",
    editorBorderTransition: "300ms",
    toolbarBackgroundColor: "#f4f6f8",
    toolbarIconColor: "#808080",
    toolbarCaretColor: "#808080",
    tableBorderColor: "#dbdcdd",
    tableHeadBackgroundColor: "#f4f6f8",
};

function onDrop(e, editor) {
    const { dataTransfer } = e;
    if (dataTransfer.types.includes("Files")) {
        e.preventDefault();
        e.stopPropagation();
        if (editor.uploadOptions.type === "disabled")
            return true;
        editor.upload(dataTransfer.files);
        return true;
    }
    return false;
}

function stopEvent(event) {
    event.preventDefault();
    event.stopPropagation();
}

/**
 * Indent elements at the level of PrimaryBlockElement
 */
function blockquote(editor) {
    Transforms.wrapNodes(editor, { type: "blockquote", children: [] }, {
        match: isPrimaryBlockElement,
    });
}
/**
 * Unindent block quote from the selection
 */
function unblockquote(editor) {
    Transforms.unwrapNodes(editor, {
        match: (node) => Element.isElement(node) && node.type === "blockquote",
    });
}

/**
 * Gets all node entries that are selected and match as an array of nodes.
 *
 * If you pass in a type `T`, the `NodeEntry` returned is of that type.
 */
function getNodeEntries(editor, match) {
    return Array.from(Editor.nodes(editor, { match }));
}
/**
 * Returns an array of elements that match the given `type` using the current
 * selection range.
 *
 * The returned elements have a narrowed type using `type` as the discriminant.
 */
function getElementsByType(editor, type) {
    return getNodeEntries(editor, (node) => isElementByType(node, type));
}
const TOTAL_EDITOR_CONTAINER_PADDING = 32;
/**
 * Get the inner width of the editor (i.e. the area with the content in it).
 *
 * We use this for setting the maximum width of an uploaded image.
 */
function getEditorInnerWidth(editor) {
    const container = editor.containerRef.current;
    if (container == null) {
        throw new Error(`Could not find the container div for the editor`);
    }
    const rect = container.getBoundingClientRect();
    return rect.width - TOTAL_EDITOR_CONTAINER_PADDING;
}

/**
 * The list of all property keys other than `type` that need to be removed
 * if they aren't specified in a convertible element.
 *
 * For example, if we have a bulleted list, it has a `depth`. We need to make
 * sure that `number`, `checked` and `level` are removed before converting
 * to a bulleted list.
 */
const CONVERTIBLE_PROP_KEYS = ["depth", "number", "checked", "level"];
/**
 * Sets all convertible elements (ie. paragraphs, heading and lists) so that
 *
 * - All of the convertible elements in selection are converted to given type
 * - None of the non-convertible elements are converted
 * - Unused properties like a `checked` property in a `paragraph` are removed
 */
function setConvertibleElement(editor, getConvertibleElementProps, at) {
    if (at == null) {
        if (editor.selection == null)
            return;
        at = editor.selection;
    }
    // if (editor.selection == null) return
    const matches = Editor.nodes(editor, {
        at,
        match: isConvertibleBlockElement,
    });
    for (const [node, pos] of matches) {
        const convertibleElementProps = getConvertibleElementProps(node);
        Transforms.setNodes(editor, convertibleElementProps, { at: pos });
        const propKeysInElement = Object.keys(convertibleElementProps);
        const propKeysToRemove = CONVERTIBLE_PROP_KEYS.filter((k) => !propKeysInElement.includes(k));
        Transforms.unsetNodes(editor, propKeysToRemove, { at: pos });
    }
}
function setParagraph(editor) {
    setConvertibleElement(editor, () => ({
        type: "p",
    }));
}
/**
 * Toggle a heading. If it's not a heading or it's a heading but not at the
 * same level, then toggle to the heading at the given level. If it's
 * already a heading at the given level, then toggle to a paragraph.
 */
function toggleHeading(editor, level) {
    const textBlockPairs = getNodeEntries(editor, isConvertibleBlockElement);
    const isAllSameHeadingLevel = textBlockPairs.every(([block]) => Element.isElement(block) &&
        block.type == "heading" &&
        block.level === level);
    if (isAllSameHeadingLevel) {
        setParagraph(editor);
    }
    else {
        setConvertibleElement(editor, () => ({
            type: "heading",
            level,
        }));
    }
}

/**
 * When we are using a dialog box, Slate loses the selection.
 *
 * This method lets us return focus and select the last known select.
 *
 * If nothing was selected, we default to place the range in the first location.
 */
function reselect(editor) {
    var _a;
    function getDefaultRange() {
        const defaultPoint = Editor.start(editor, [0]);
        return {
            anchor: defaultPoint,
            focus: defaultPoint,
        };
    }
    ReactEditor.focus(editor);
    Transforms.select(editor, (_a = editor.lastSelection) !== null && _a !== void 0 ? _a : getDefaultRange());
}

/**
 * Move the selection at the start of the element at the given path. In a
 * nested element like a table, this would be the first cell of the table.
 */
function selectIn(editor, path) {
    Transforms.select(editor, Editor.start(editor, path));
    return path;
}
/**
 * Move the selection at the start of the next sibling element at the given
 * path. Uses `selectIn` to drill into first element like the first cell of
 * a table.
 */
function selectAfter(editor, afterPath) {
    /**
     * `selectAfter` is only called when we know that there is a `nextNodeEntry`
     */
    const nextNodeEntry = Editor.next(editor, { at: afterPath });
    if (nextNodeEntry == null)
        throw new Error(`Unexpected as there should always be a nextNodeEntry`);
    return selectIn(editor, nextNodeEntry[1]);
}
/**
 * When we insert a block into the document with this method, the selection
 * always ends up inside the inserted block at the start. The way it inserts
 * depends on where it is being inserted into.
 *
 * - Into a Convertible: The block is split
 * - Into a Nested or Void: Inserted after the element we are inserting into
 *
 * Note that for a VoidElement, we don't want the cursor inside but the rest
 * of that logic is handled in the `insertVoidBlock` method that calls this
 * method.
 *
 * This method is not to be used directly.
 */
function insertAndSelectInBlock(editor, srcNode) {
    /**
     * If there's no selection, don't insert
     */
    if (editor.selection == null)
        return null;
    const destPoint = editor.selection.anchor;
    const destNodeEntry = Editor.above(editor, {
        at: destPoint,
        match: isPrimaryBlockElement,
        mode: "lowest",
    });
    /**
     * This shouldn't happen but it helps with type narrowing and if it does
     * happen, it will fail quietly.
     */
    if (destNodeEntry == null)
        return null;
    const [destNode, destPath] = destNodeEntry;
    const isConvertible = isConvertibleBlockElement(destNode);
    /**
     * If the element is convertible, we insert the element into it which will
     * split the convertible block.
     */
    if (isConvertible) {
        /**
         * When the cursor is at the start of a convertible, the inserted element
         * will be at the path that we are inserting into it.
         */
        const isAtStart = Editor.isStart(editor, destPoint, destPath);
        const isEmpty = Node.string(destNode) === "";
        /**
         * Insert the node
         */
        Transforms.insertNodes(editor, srcNode);
        /**
         * If we are inserting into an empty convertible, Slate keeps the empty
         * convertible and inserts the element underneath it. This is unexpected
         * behavior since when we insert at the start of a convertible element
         * with content, it doesn't keep that line.
         *
         * To normalize this we delete the empty convertible first and then select
         * into the nested element we inserted.
         *
         * There seems to be a bug somewhere, it might be in the browser, where
         * the cursor appears to not be in the text area when inserting into a table;
         * however, in checking the selection, it is in the proper place and the
         * cursor behaves properly apart from the original visual location so we
         * leave it as is for now.
         */
        if (isEmpty) {
            Transforms.delete(editor, { at: destPath });
            return selectIn(editor, destPath);
        }
        else if (isAtStart) {
            /**
             * If we're at the start, the inserted nested will be in the `destPath`
             * position so we select into it.
             */
            return selectIn(editor, destPath);
        }
        else {
            /**
             * If we're not at the start of the convertible, the inserted nested will
             * be after the `destPath` position so we select after it.
             */
            return selectAfter(editor, destPath);
        }
    }
    /**
     * If it's not convertible, then we are inserting into either a Nested
     * Element (like a table or code block) or a void element like an image or
     * hr Element.
     *
     * We insert into the position following the `PrimaryBlockElement`.
     */
    const insertPath = Path.next(destPath);
    Transforms.insertNodes(editor, srcNode, { at: insertPath });
    return selectAfter(editor, destPath);
}

/**
 * When we insert a nested block into the document, the selection always
 * ends up at the start of the inserted nested block. The way it inserts
 * depends on what it is being inserted into.
 *
 * - Convertible: The block is split
 * - Nested or Void: Inserted after the Nested or Void Element
 */
function insertNestedBlock(editor, srcNode) {
    insertAndSelectInBlock(editor, srcNode);
}

/**
 * When inserting a void block like an image or a horizontal rule, we don't
 * want the cursor to remain in the void block because the cursor in a void
 * block is hard to see and is a little unnatural because it doesn't look
 * like a blinking | like it usually does.
 *
 * For example, on an <hr>, it turns into a blue line. The first reaction
 * may be to think that we just inserted a blue line and the cursor has
 * disappeared.
 *
 * Usually, a user doesn't want the cursor there anyways. There is nothing
 * the user can do except delete the <hr>. Instead, we normally want the
 * cursor to be on the next line.
 */
function insertVoidBlock(editor, srcNode) {
    const insertPath = insertAndSelectInBlock(editor, srcNode);
    if (insertPath == null)
        return;
    /**
     * If the next path adjacent sibling to the insertion path is a convertible
     * element, then move the cursor to the beginning of the convertible element.
     *
     * An easy way to do this is to just move the cursor over by one which is
     * what we do.
     */
    const nextPath = Path.next(insertPath);
    const hasNext = Node.has(editor, nextPath);
    if (hasNext) {
        const nextNode = Node.get(editor, nextPath);
        if (isConvertibleBlockElement(nextNode)) {
            /**
             * Move cursor one to the right
             */
            Transforms.move(editor);
            return;
        }
    }
    /**
     * If the next adjacent sibling does not exist, then make it exist by adding
     * a paragraph. For example, this might happen if you insert a void at the
     * end of a blockquote.
     *
     * Also, if the next adjacent sibling is not a convertible element like a
     * nested element (table, code block) or a void element (image, hr) then we
     * also want to insert a paragraph.
     *
     * The general idea is that we want to make sure that after an insert, there
     * is a place for a natural looking cursor to go which blinks.
     */
    Transforms.insertNodes(editor, { type: "p", children: [{ text: "" }] }, { at: nextPath });
    /**
     * Move the cursor into the paragraph
     */
    Transforms.move(editor);
}

/**
 * Insert a paragraph at the given path, select into it then focus the editor.
 *
 * It's used in:
 *
 * - keydown/handle-key-down-enter-void.ts
 * - render/seamless
 */
function insertParagraphAt(editor, path) {
    Transforms.insertNodes(editor, { type: "p", children: [{ text: "" }] }, { at: path });
    focusAtStart(editor, path);
}

/**
 * Insert a code block
 */
function insertCodeBlock(editor, language) {
    insertNestedBlock(editor, {
        type: "code-block",
        language,
        children: [{ type: "code-line", children: [{ text: "" }] }],
    });
}
/**
 * Insert a horizontal rule
 */
function insertHorizontalRule(editor) {
    insertVoidBlock(editor, {
        type: "hr",
        children: [{ text: "" }],
    });
}
/**
 * Insert a link
 */
function insertLink(editor, url, label) {
    Transforms.insertNodes(editor, {
        type: "link",
        url,
        children: [{ text: label }],
    });
}
function insertLinkBlock(editor, url, label) {
    Transforms.insertNodes(editor, {
        type: "p",
        children: [
            { text: "" },
            {
                type: "link",
                url,
                children: [{ text: label }],
            },
            { text: "" },
        ],
    });
}
/**
 * Insert media block
 */
function insertMedia(editor, url, alt = url) {
    insertVoidBlock(editor, {
        type: "media",
        url,
        alt,
        children: [{ text: "" }],
    });
}
/**
 * Insert newline (not a paragraph)
 */
function insertNewline(editor) {
    editor.insertText("\n");
}

/**
 * Returns a collapsed Range at the start of the Editor as a default location
 * for insertion. Normally, this shouldn't happen unless the user clicks the
 * insert link button without selecting anything in the Editor.
 */
function getStartRange(editor) {
    return {
        anchor: Editor.start(editor, [0]),
        focus: Editor.start(editor, [0]),
    };
}
/**
 * Uses the editor's `lastSelection` to learn about what the current link
 * should be and if there is no current link, returns "" for text and url
 * and a collapsed range which would be the insertion point.
 */
function getLinkInfo(editor) {
    try {
        /**
         * If no selection, use start of document
         */
        if (editor.lastSelection == null)
            return { text: "", url: "", path: null, range: getStartRange(editor) };
        /**
         * Look for a link element starting from the collapsed selection
         */
        const linkEntry = Editor.above(editor, {
            match: (node) => Element.isElement(node) && node.type === "link",
        });
        if (linkEntry == null) {
            /**
             * If we can't find a link entry from the collapsed selection, then we
             * look to the lastSelection to tell us the text for the link (if any)
             * and the Range for the link.
             */
            const fragment = Node.fragment(editor, editor.lastSelection);
            const text = fragment.map(Node.string).join("");
            return { text, url: "", path: null, range: editor.lastSelection };
        }
        else {
            /**
             * If we do find a link entry, then we use the link for the range and
             * to populate text and url
             */
            return {
                text: Node.string(linkEntry[0]),
                url: linkEntry[0].url,
                path: linkEntry[1],
                range: {
                    anchor: Editor.start(editor, linkEntry[1]),
                    focus: Editor.end(editor, linkEntry[1]),
                },
            };
        }
        // }
    }
    catch (e) {
        /**
         * If error, use start of document
         */
        console.warn("Warning in getLastSelectedText. Error thrown so returning ''");
        return { text: "", url: "", path: null, range: getStartRange(editor) };
    }
}

/**
 * Handle tabs in list. Use to indent list items and tasks.
 */
function tabInList(editor, delta) {
    const liEntries = getNodeEntries(editor, (n) => isListItemElement(n));
    if (liEntries == null)
        return;
    let maxDepth = 0;
    let minDepth = 8;
    for (const [node] of liEntries) {
        if (node.depth < minDepth)
            minDepth = node.depth;
        if (node.depth > maxDepth)
            maxDepth = node.depth;
    }
    if (delta === -1 && minDepth === 0)
        return;
    if (delta === 1 && maxDepth === 8)
        return;
    for (const [node, pos] of liEntries) {
        const nextDepth = node.depth + delta;
        Transforms.setNodes(editor, { depth: nextDepth }, { at: pos });
    }
}

/**
 * https://fettblog.eu/typescript-hasownproperty/
 *
 * A version of `hasOwnProperty` that correctly does type narrowing.
 */
function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
}
/**
 * Returns true if all selected blocks that are convertible match the passed
 * in convertible type.
 **/
function isSelectedConvertibleTypesAllMatch(editor, convertibleType) {
    if (editor.selection == null)
        return false;
    const matches = Array.from(Editor.nodes(editor, {
        at: editor.selection,
        match: isConvertibleBlockElement,
    }));
    for (const [node] of matches) {
        if (node.type !== convertibleType) {
            return false;
        }
    }
    return true;
}
/**
 * Set list item type keeping in mind the special attributes of ordered
 * list items and task list items.
 */
function toggleListItem(editor, targetType) {
    if (editor.selection == null)
        return;
    const isAllConvertibleElementsMatch = isSelectedConvertibleTypesAllMatch(editor, targetType);
    if (isAllConvertibleElementsMatch) {
        setParagraph(editor);
        return;
    }
    else {
        switch (targetType) {
            case "unordered-list-item":
                setConvertibleElement(editor, (node) => ({
                    type: "unordered-list-item",
                    depth: hasOwnProperty(node, "depth") ? node.depth : 0,
                }));
                break;
            case "ordered-list-item":
                setConvertibleElement(editor, (node) => ({
                    type: "ordered-list-item",
                    depth: hasOwnProperty(node, "depth") ? node.depth : 0,
                    number: null,
                }));
                break;
            case "task-list-item":
                setConvertibleElement(editor, (node) => ({
                    type: "task-list-item",
                    depth: hasOwnProperty(node, "depth") ? node.depth : 0,
                    checked: hasOwnProperty(node, "checked") ? node.checked : false,
                }));
                break;
        }
    }
}

/**
 * Returns true if the passed in `mark` key is active at the moment.
 *
 * Optionally, you can pass in a `markValue` but if it's not passed in, it
 * is assume to be true so we can check for most marks like `bold` like this:
 *
 * `Custom.isMarkActive(editor, 'bold')`
 */
function isMarkActive(editor, mark, markValue = true) {
    const marks = Editor.marks(editor);
    return marks ? marks[mark] === markValue : false;
}
/**
 * If mark doesn't exist, add it with the value set to `markValue`.
 * This properly handles that `pos` can only be `sup` or `sub` but not
 * both at the same time.
 */
function toggleMark(editor, mark, markValue = true) {
    const isActive = isMarkActive(editor, mark, markValue);
    if (isActive) {
        Editor.removeMark(editor, mark);
    }
    else {
        Editor.addMark(editor, mark, markValue);
    }
}
/**
 * remove all marks
 */
function removeAllMarks(editor) {
    MARK_KEYS.forEach((mark) => {
        Editor.removeMark(editor, mark);
    });
}

/**
 * Check if a descendant node exists at a specific path and returns it if it
 * exists and return `undefined` if it does not.
 *
 * TODO: Add `Node.getIf` to `slate` itself
 */
function getNodeIf(root, path) {
    let node = root;
    for (let i = 0; i < path.length; i++) {
        const p = path[i];
        if (Text.isText(node) || !node.children[p]) {
            return undefined;
        }
        node = node.children[p];
    }
    return [node, path];
}
function getNodeBeforeIf(root, path) {
    if (path[path.length - 1] <= 0)
        return undefined;
    return getNodeIf(root, Path.previous(path));
}
function getNodeAfterIf(root, path) {
    return getNodeIf(root, Path.next(path));
}

/**
 * Selects at the given path which can be a Node and not a Text.
 *
 * We make sure that we select the first text node by using Editor.start so
 * as not to throw errors.
 *
 * We then make the editor get the focus. This is useful if the user clicked
 * a user interface element and the editor did not yet have the focus at the
 * time the UI element was clicked.
 *
 * If you don't want to give the editor focus, use `selectAt` instead.
 */
function focusAtStart(editor, path) {
    selectAtStart(editor, path);
    ReactEditor.focus(editor);
}
function focusAtEnd(editor, path) {
    selectAtEnd(editor, path);
    ReactEditor.focus(editor);
}
/**
 * Selects at the given path which can be a Node and not a Text.
 *
 * We make sure that we select the first text node by using Editor.start so
 * as not to throw errors.
 *
 * This does not force the Editor to get the focus. For that, use `focusAt`
 */
function selectAtStart(editor, path) {
    Transforms.select(editor, Editor.start(editor, path));
}
function selectAtEnd(editor, path) {
    Transforms.select(editor, Editor.end(editor, path));
}

/**
 * Returns true initially and then on the next tick returns false.
 *
 * Useful when we want the initial value to always be some value but then we
 * quickly switch to another value. This is usually used for CSS transitions.
 */
function useInitial(showInitial = true) {
    const [initial, setInitial] = useState(showInitial);
    useEffect(() => {
        /**
         * The 50ms delay is important.
         *
         * In our lazy loaded editor, we use `externalModule` from not showing a
         * loader to showing a loader at 1000ms. If the module takes exactly 1000ms
         * to load, there is something funky that happens along that transition
         * where the transition never happens.
         *
         * I theorize that it is because the initial className never makes it to
         * the DOM due to a timing issue.
         *
         * I thought maybe we were just punting the problem to 950ms instead, but
         * testing with 950ms delay (950ms + 50ms = 1000ms) seems to work fine.
         *
         * So unless we can clearly rule out the cause, I suggest we keep this
         * code in.
         */
        const timeoutId = setTimeout(() => {
            setInitial(false);
        }, 50);
        return () => {
            clearTimeout(timeoutId);
        };
    }, [showInitial]);
    return initial;
}
/**
 * A shortcut version for the most common use case of `useInitial` which is to
 * add an `--initial` className immediately and then remove it.
 *
 * This allows us to do things like add a fade-in.
 *
 * Note: This doesn't support a fade-out but, pragmatically, it seems to matter
 * less and the complexity of a fade-out is higher. This is because we need a
 * way to preserve the React Element after it has been removed.
 */
function useInitialClassName(className = "--initial", showInitial = true) {
    const initial = useInitial(showInitial);
    return initial ? className : "";
}

/**
 * Styled Components
 */
styled.div `
  padding: 0 0 1em;
  &.--initial {
    opacity: 0;
  }
  opacity: 1;
  transition: opacity 500ms;
  /**
   * NOTE:
   * We are targeted an inner element with a class of .--highlight-target
   * because the actual highlighted element is not the container itself.
   */
  &.--highlighted .--highlight-target {
    box-shadow: rgb(38, 132, 255) 0 0 0 2px !important;
  }
  .--highlight-target {
    transition: box-shadow 150ms linear;
  }
`;
styled.div `
  position: relative;
  padding-top: 75%;
  background-color: #f0f1f2;
  max-width: 320px;
`;
styled.iframe `
  position: absolute;
  top: 0;
  width: 100%;
  height: 100%;
`;
styled.div `
  background: #f0f1f2;
  padding: 1em 1.5em;
  .__title {
  }
  .__link {
    line-height: 1.2em;
    a {
      font-size: 0.9em;
    }
  }
`;
const YOUTUBE_PATTERN = /^(?:https?:\/\/(?:www\.youtube\.com\/watch\?v=|youtu\.be\/))([^?&]+)((?:.*?)(?:[&?]t=(?:([0-9]+)m)?([0-9]+)s)?)$/i;
const VIMEO_PATTERN = /^https?:\/\/vimeo\.com\/(?:.*\/)?([0-9]+)$/i;
const GOOGLE_MAPS_PLACE_PATTERN = /^(https:\/\/www\.google\.[^/]+\/maps\/place\/([^/]+)([/].*)?)/i;
const GOOGLE_MAPS_COORD_PATTERN = /^(?:https:\/\/www\.google\.[^/]+\/maps\/(?:.*[/])?@([^,]+),([^,]+),([^z]+)z)/i;
// Based on <https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img> less tif/tiff
const IMAGE_PATTERN = /^.*[.](apng|bmp|gif|ico|cur|jpg|jpeg|jfif|pjpeg|pjp|png|svg|webp)$/i;
/**
 * Used by `paste/index` to see if pasted text points to a link
 */
const MEDIA_REGEXPS = [
    YOUTUBE_PATTERN,
    VIMEO_PATTERN,
    GOOGLE_MAPS_PLACE_PATTERN,
    GOOGLE_MAPS_COORD_PATTERN,
    IMAGE_PATTERN,
];
/**
 * Image
 */
styled.img `
  /* max-width: 360px;
  width: 360px;
  border-radius: 0.5rem; */
`;

function onPaste(e, editor) {
    const x = pick_1(e, ["type", "clipboardData"]);
    const { files, types } = e.clipboardData;
    /**
     * Upload file
     */
    if (files.length > 0) {
        stopEvent(e);
        if (editor.uploadOptions.type === "disabled")
            return true;
        editor.upload(files);
        return true;
    }
    else if (types.includes("text/plain")) {
        const text = x.clipboardData.getData("text/plain");
        if (!isUrl(text))
            return false;
        stopEvent(e);
        const isMedia = MEDIA_REGEXPS.some((re) => !!text.match(re));
        if (isMedia) {
            insertMedia(editor, text);
        }
        else {
            if (editor.selection && Range.isExpanded(editor.selection)) {
                Transforms.wrapNodes(editor, {
                    type: "link",
                    url: text,
                    children: [],
                }, { at: editor.selection, split: true });
            }
            else {
                insertLink(editor, text, text);
            }
        }
        return true;
    }
    return false;
}

const IS_MAC_REGEX = /mac os x/i;
let isMacValue = undefined;
/**
 * `isMac` is a function and not a const because `window.navigator` only exists
 * on the browser and will throw an Error on the server.
 */
function isMac() {
    /**
     * Memoized for performance
     */
    if (isMacValue !== undefined)
        return isMacValue;
    const { userAgent } = window.navigator;
    isMacValue = IS_MAC_REGEX.test(userAgent);
    return isMacValue;
}

function isHotkeyPlus(hotkey) {
    const modifiedHotkey = hotkey.replace(/\bsuper\b/g, isMac() ? "cmd+alt" : "ctrl+shift");
    return isHotkey(modifiedHotkey);
}

/**
 * Creates a `keyDown` handler from an object where the keys are the shortcut
 * and the values are the `KeyboardAction` function to execute. If the
 * function returns `true`, the event is considered handled and the event
 * is stopped.
 *
 * In some situations, we don't want the event to be stopped.
 *
 * For example, hitting `up` or `down` in a table, starts a `setTimeout` but
 * we want the original keyboard event to be handled by the browser.
 */
function createKeyDownHandler(shortcutsObject) {
    /**
     * Don't populate the shortcuts at this point because it will run on the
     * server. We can't run it on the server because we need to determine if we
     * are on Mac or Windows and checking `window.navigate.userAgent` will cause
     * a failure.
     */
    let shortcuts = null;
    return function handleShortcuts(event, editor) {
        /**
         * We initialize shortcuts once on first usage.
         */
        if (shortcuts == null) {
            shortcuts = Object.entries(shortcutsObject).map(([shortcut, fn]) => [
                isHotkeyPlus(shortcut),
                fn,
            ]);
        }
        for (const [isShortcut, action] of shortcuts) {
            if (isShortcut(event)) {
                /**
                 * If the keyboardAction returns true then the event has been handled.
                 * We can stop the event at this point and exit the loop.
                 */
                if (action(editor)) {
                    stopEvent(event);
                    return true;
                }
            }
        }
        return false;
    };
}

const handleKeyDownCore = createKeyDownHandler({
    "shift+enter"(editor) {
        insertNewline(editor);
        return true;
    },
    tab(editor) {
        tabInList(editor, 1);
        return true;
    },
    "shift+tab"(editor) {
        tabInList(editor, -1);
        return true;
    },
    "mod+b"(editor) {
        toggleMark(editor, "bold", true);
        return true;
    },
    "mod+i"(editor) {
        toggleMark(editor, "italic", true);
        return true;
    },
    "mod+j"(editor) {
        toggleMark(editor, "code", true);
        return true;
    },
    "mod+d"(editor) {
        toggleMark(editor, "code", true);
        return true;
    },
    "super+c"(editor) {
        toggleMark(editor, "code", true);
        return true;
    },
    "super+-"(editor) {
        insertHorizontalRule(editor);
        return true;
    },
    "super+p"(editor) {
        toggleMark(editor, "sup", true);
        return true;
    },
    "super+b"(editor) {
        toggleMark(editor, "sub", true);
        return true;
    },
    "super+x"(editor) {
        toggleMark(editor, "del", true);
        return true;
    },
    "super+0"(editor) {
        setParagraph(editor);
        return true;
    },
    "super+1"(editor) {
        toggleHeading(editor, 1);
        return true;
    },
    "super+2"(editor) {
        toggleHeading(editor, 2);
        return true;
    },
    "super+3"(editor) {
        toggleHeading(editor, 3);
        return true;
    },
    "super+4"(editor) {
        toggleHeading(editor, 4);
        return true;
    },
    "super+5"(editor) {
        toggleHeading(editor, 5);
        return true;
    },
    "super+6"(editor) {
        toggleHeading(editor, 6);
        return true;
    },
    "super+7"(editor) {
        toggleListItem(editor, "ordered-list-item");
        return true;
    },
    "super+8"(editor) {
        toggleListItem(editor, "unordered-list-item");
        return true;
    },
    "super+9"(editor) {
        toggleListItem(editor, "task-list-item");
        return true;
    },
});

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil = Math.ceil,
    nativeMax = Math.max;

/**
 * The base implementation of `_.range` and `_.rangeRight` which doesn't
 * coerce arguments.
 *
 * @private
 * @param {number} start The start of the range.
 * @param {number} end The end of the range.
 * @param {number} step The value to increment or decrement by.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Array} Returns the range of numbers.
 */
function baseRange(start, end, step, fromRight) {
  var index = -1,
      length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
      result = Array(length);

  while (length--) {
    result[fromRight ? length : ++index] = start;
    start += step;
  }
  return result;
}

var _baseRange = baseRange;

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject_1(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike_1(object) && _isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq_1(object[index], value);
  }
  return false;
}

var _isIterateeCall = isIterateeCall;

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber_1(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

var toFinite_1 = toFinite;

/**
 * Creates a `_.range` or `_.rangeRight` function.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new range function.
 */
function createRange(fromRight) {
  return function(start, end, step) {
    if (step && typeof step != 'number' && _isIterateeCall(start, end, step)) {
      end = step = undefined;
    }
    // Ensure the sign of `-0` is preserved.
    start = toFinite_1(start);
    if (end === undefined) {
      end = start;
      start = 0;
    } else {
      end = toFinite_1(end);
    }
    step = step === undefined ? (start < end ? 1 : -1) : toFinite_1(step);
    return _baseRange(start, end, step, fromRight);
  };
}

var _createRange = createRange;

/**
 * Creates an array of numbers (positive and/or negative) progressing from
 * `start` up to, but not including, `end`. A step of `-1` is used if a negative
 * `start` is specified without an `end` or `step`. If `end` is not specified,
 * it's set to `start` with `start` then set to `0`.
 *
 * **Note:** JavaScript follows the IEEE-754 standard for resolving
 * floating-point values which can produce unexpected results.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {number} [start=0] The start of the range.
 * @param {number} end The end of the range.
 * @param {number} [step=1] The value to increment or decrement by.
 * @returns {Array} Returns the range of numbers.
 * @see _.inRange, _.rangeRight
 * @example
 *
 * _.range(4);
 * // => [0, 1, 2, 3]
 *
 * _.range(-4);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 5);
 * // => [1, 2, 3, 4]
 *
 * _.range(0, 20, 5);
 * // => [0, 5, 10, 15]
 *
 * _.range(0, -4, -1);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 4, 0);
 * // => [1, 1, 1]
 *
 * _.range(0);
 * // => []
 */
var range = _createRange();

var range_1 = range;

/**
 * Returns true if the `focus` of the selection is inside the given element
 * type.
 *
 * Note:
 * `Editor.above` returns `undefined`, erroneously in my opinion, if we try
 * to match based on a range, even if `match` returns `true`.
 *
 * Because of this, we elect to only check the `focus`.
 *
 * This may cause unexpected because which side is in the element type matters.
 *
 * That said, pragmatically, both are unusual behaviors from the perspective
 * of the user and should both be considered edge cases. For this reason,
 * we just make a choice.
 */
function isFocusInside(editor, type) {
    if (editor.selection == null)
        return false;
    const above = Editor.above(editor, {
        at: editor.selection.focus,
        match: (n) => {
            return Element.isElement(n) && n.type === type;
        },
    });
    return !!above;
}
/**
 * Takes a string and returns the number of leading spaces
 *
 * <https://stackoverflow.com/questions/25823914/javascript-count-spaces-before-first-character-of-a-string>
 */
function countLeadingSpaces(s) {
    return s.search(/[^ ]|$/);
}

/**
 * Looks for the nearest ancestor that matches the given type.
 *
 * returns a tuple with `[element, path, lastIndex]`
 */
function getMatch(editor, type, at) {
    const match = Editor.above(editor, {
        at,
        // at: editor.selection!.focus,
        match: IsElementByType(type),
    });
    if (match == null)
        throw new Error(`Could not find node of type ${type}`);
    const [el, path] = match;
    return [
        el,
        path,
        path[path.length - 1],
    ];
}
/**
 * get table info
 */
function getTableInfo(editor, at = editor.selection) {
    if (at == null)
        throw new Error(`Expected at or editor.selection to have a value`);
    const start = Editor.start(editor, at);
    const [td, tdPath, tdIndex] = getMatch(editor, "td", start);
    const [tr, trPath, trIndex] = getMatch(editor, "tr", start);
    const [table, tablePath, tableIndex] = getMatch(editor, "table", start);
    const trs = table.children;
    const trCount = trs.length;
    const tdCount = tr.children.length;
    return {
        td,
        tdPath,
        tdIndex,
        tdCount,
        tr,
        trPath,
        trIndex,
        trCount,
        trs,
        table: table,
        tablePath,
        tableIndex,
    };
}

/**
 * Tab forward in a table.
 *
 * Create a new row if needed.
 */
function tabForward(editor) {
    const { tdIndex, tdCount, trIndex, trCount, tablePath } = getTableInfo(editor);
    /**
     * Increment column
     */
    let nextTdIndex = tdIndex + 1;
    let nextTrIndex = trIndex;
    /**
     * If we're past the last column, go to the first cell in the next row
     */
    if (nextTdIndex >= tdCount) {
        nextTdIndex = 0;
        nextTrIndex++;
        /**
         * If we're past the last row, insert a new one
         */
        if (nextTrIndex >= trCount) {
            Table$1.insertRow(editor, 1);
        }
    }
    Transforms.select(editor, Editor.start(editor, [...tablePath, nextTrIndex, nextTdIndex]));
}
/**
 * Tab backward in a table
 */
function tabBackward(editor) {
    const { tdIndex, tdCount, trIndex, tablePath } = getTableInfo(editor);
    let nextTdIndex = tdIndex - 1;
    let nextTrIndex = trIndex;
    /**
     * What happens if we tab backward past the first column
     */
    if (nextTdIndex < 0) {
        /**
         * If we're in the first row, do nothing. Just leave the cursor where it is.
         */
        if (nextTrIndex === 0)
            return;
        nextTdIndex = tdCount - 1;
        nextTrIndex--;
    }
    Transforms.select(editor, Editor.start(editor, [...tablePath, nextTrIndex, nextTdIndex]));
}

/**
 * Takes a TableInfo from before and a TableInfo from after and compares them.
 *
 * If they are the same, return true.
 */
function isSameCell(before, after) {
    return isEqual_1(before.tdPath, after.tdPath);
}
/**
 * returns true if the cursor should be repositioned verticalled compared to
 * the previous position.
 *
 * The logic is:
 *
 * - if the cursor left the table entirely, no need to reposition
 * - If the cursor is in the same cell, no need to reposition
 */
function shouldRepositionVertical(prev, editor) {
    if (!Table$1.isInside(editor))
        return false;
    const after = Table$1.getTableInfo(editor);
    if (isSameCell(prev, after))
        return false;
    return true;
}
/**
 * Special handling for pressing up in a table. If the cursor escaped the
 * table cell, we want to move the cursor into the cell above.
 *
 * The actual event must not be stopped for this to work
 */
function delayedUpReposition(editor) {
    const beforeTable = Table$1.getTableInfo(editor);
    setTimeout(() => {
        if (!shouldRepositionVertical(beforeTable, editor))
            return;
        const aboveTrIndex = beforeTable.trIndex - 1;
        if (aboveTrIndex < 0) {
            /**
             * Get the point immediately before the table
             */
            const beforePoint = Editor.before(editor, beforeTable.tablePath);
            /**
             * If there's not `beforePoint`, we are at the top of the document.
             * In this scenario, we don't want to end up in a different column so
             * reselect the previous cell.
             */
            if (beforePoint == null) {
                Transforms.select(editor, Editor.start(editor, beforeTable.tdPath));
            }
            else {
                Transforms.select(editor, beforePoint);
            }
            return;
        }
        /**
         * Move the cell in the row above the current one
         */
        Transforms.select(editor, Editor.start(editor, [
            ...beforeTable.tablePath,
            aboveTrIndex,
            beforeTable.tdIndex,
        ]));
    }, 50);
}
/**
 * Special handling for pressing down in a table. If the cursor escaped the
 * table cell, we want to move the cursor into the cell below.
 *
 * The actual event must not be stopped for this to work
 */
function delayedDownReposition(editor) {
    const beforeTable = Table$1.getTableInfo(editor);
    setTimeout(() => {
        if (!shouldRepositionVertical(beforeTable, editor))
            return;
        const belowTrIndex = beforeTable.trIndex + 1;
        /**
         * If we the next row is beyond the table, the cursor moved into an adjacent
         * cell. In this case, we want to move to the start of the element after
         * the table.
         */
        if (belowTrIndex >= beforeTable.trCount) {
            /**
             * Get the point immediately after the table
             */
            const belowPoint = Editor.after(editor, beforeTable.tablePath);
            /**
             * This shouldn't happen as there will always be something underneat
             * if the normalization rules have been followed with a trailing
             * paragraph but it does help narrow the type
             */
            if (belowPoint == null)
                return;
            Transforms.select(editor, belowPoint);
            return;
        }
        /**
         * Move to the cell in the row beneath the current one
         */
        Transforms.select(editor, Editor.start(editor, [
            ...beforeTable.tablePath,
            belowTrIndex,
            beforeTable.tdIndex,
        ]));
    }, 50);
}

/**
 * Simplifies creating an empty `td` element
 */
function createTd(index, stringOrLeaf = "") {
    const leaf = typeof stringOrLeaf === "string" ? { text: stringOrLeaf } : stringOrLeaf;
    return {
        type: "td",
        index,
        children: [{ type: "p", children: [leaf] }],
    };
}
/**
 * Simplifies creating an empty `tr` element
 *
 * Note:
 * We take either a `number` or `TableColumn[]` but eventually, we'll want to
 * take only `TableColumn[]` because instead of an `index` we are eventually
 * going to want to have an `id` of some sort. Probably a `nanoid`.
 *
 * This is because it will play nicer once we have collaborative editing working
 * where we can uniquely identify each column.
 */
function createEmptyTr(columnDefs) {
    const columns = typeof columnDefs === "number"
        ? range_1(columnDefs).map(() => ({ align: "left" }))
        : columnDefs;
    return {
        type: "tr",
        children: columns.map((_, index) => createTd(index)),
    };
}
/**
 * Create a table with the given specifications. The columnDefs can be
 * supplied as a single nuber which results in a that many columns all aligned
 * left or it can be supplied as an array of `Align` to specify the alignment
 * of each column.
 */
function createTable(columnDefs, rowCount) {
    const columns = typeof columnDefs === "number"
        ? range_1(columnDefs).map(() => ({ align: "left" }))
        : columnDefs;
    return {
        type: "table",
        columns,
        children: range_1(rowCount).map(() => createEmptyTr(columns)),
    };
}
/**
 * Reindex Table Cells
 *
 * Each of the cells in a row of a table has an `index` that indicates its
 * position. This is important because when rendering we need to know what
 * `Column` each cell is referring to but the `render` method doesn't know
 * about its current `Path`. Because it doesn't know its path, it can't tell
 * what `Column` it is in.  Adding the `index` property solves this.
 */
function reindexTable(editor) {
    const { tablePath, trs } = getTableInfo(editor);
    Editor.withoutNormalizing(editor, () => {
        trs.forEach((tr, trIndex) => {
            tr.children.forEach((td, tdIndex) => {
                if (tdIndex !== td.index) {
                    const tdPath = [...tablePath, trIndex, tdIndex];
                    Transforms.setNodes(editor, { index: tdIndex }, { at: tdPath });
                }
            });
        });
    });
}
/**
 * Is the current selection inside a table?
 */
function isInside(editor) {
    return isFocusInside(editor, "td");
}
/**
 * Insert a column in table
 *
 * Make sure to create the `table.align` values and to reindex `td.index`
 */
function insertColumn(editor, offset) {
    Editor.withoutNormalizing(editor, () => {
        const { tdIndex, table, tablePath } = getTableInfo(editor);
        // Set the new `align` value based on the current `td` column (not the position
        // to insert at)
        const columns = table.columns.slice();
        columns.splice(tdIndex, 0, table.columns[tdIndex]);
        Transforms.setNodes(editor, { columns }, { at: tablePath });
        // Insert the `td` in every row
        const insertTdIndex = tdIndex + offset;
        table.children.forEach((tr, trIndex) => {
            const at = tablePath.concat([trIndex, insertTdIndex]);
            Transforms.insertNodes(editor, createTd(tdIndex), { at });
        });
        reindexTable(editor);
    });
}
/**
 * Insert row in table
 */
function insertRow(editor, offset) {
    const { table, trPath } = getTableInfo(editor);
    const trToInsert = createEmptyTr(table.columns);
    const at = trPath.slice(0, -1).concat([trPath[trPath.length - 1] + offset]);
    Transforms.insertNodes(editor, trToInsert, { at });
}
/**
 * Remove table
 */
function removeTable(editor) {
    const { tablePath } = getTableInfo(editor);
    Transforms.removeNodes(editor, { at: tablePath });
}
/**
 * Remove row in table
 */
function removeRow(editor) {
    const { tablePath, tdIndex, trPath, trIndex, trCount } = getTableInfo(editor);
    if (trCount === 1) {
        return removeTable(editor);
    }
    Editor.withoutNormalizing(editor, () => {
        Transforms.removeNodes(editor, { at: trPath });
        Transforms.select(editor, Editor.start(editor, [
            ...tablePath,
            Math.min(trIndex, trCount - 2),
            tdIndex,
        ]));
    });
}
/**
 * Remove column in table
 */
function removeColumn(editor) {
    const { table, tablePath, tdIndex, tdCount, trIndex, trs } = getTableInfo(editor);
    if (tdCount === 1) {
        return removeTable(editor);
    }
    Editor.withoutNormalizing(editor, () => {
        // Set the new `align` value based on the current `td` column (not the position
        // to insert at)
        const columns = table.columns.slice();
        columns.splice(tdIndex, 1);
        Transforms.setNodes(editor, { columns }, { at: tablePath });
        trs.forEach((tr, trIndex) => {
            Transforms.removeNodes(editor, { at: [...tablePath, trIndex, tdIndex] });
        });
        reindexTable(editor);
        const selection = Editor.start(editor, [
            ...tablePath,
            trIndex,
            Math.min(tdIndex, tdCount - 2),
        ]);
        Transforms.select(editor, selection);
    });
}
/**
 * Remove a character from a backspace or forward delete.
 *
 * Takes an `isIgnore` function.
 */
function shouldIgnoreRemove(editor, isIgnore) {
    const { selection } = editor;
    if (selection == null)
        return false;
    if (Range.isExpanded(selection))
        return false;
    const { anchor } = selection;
    const [, tdPath] = getMatch(editor, "td", selection);
    const ignore = isIgnore(editor, anchor, tdPath);
    if (ignore) {
        return true;
    }
    else {
        return false;
    }
}
/**
 * Handle backspace
 */
function shouldIgnoreBackspace(editor) {
    return shouldIgnoreRemove(editor, Editor.isStart);
}
/**
 * Handle forward delete
 */
function shouldIgnoreDelete(editor) {
    return shouldIgnoreRemove(editor, Editor.isEnd);
}
/**
 * This should be checked everywhere, not just within the table like the other
 * ignore functions. We want to check if either the anchor or focus are in a
 * table and ignore the remove if either end is in a `td` and the other end is
 * not in the same `td`.
 *
 * This is not great because it just cancels the delete, but for now it is
 * better than leaving the table in an inconsistent state.
 */
function shouldIgnoreRemoveGlobal(editor) {
    const { selection } = editor;
    if (selection == null)
        return false;
    if (Range.isCollapsed(selection))
        return false;
    const { anchor, focus } = selection;
    const anchorMatch = Editor.above(editor, {
        at: anchor,
        match: (n) => Element.isElement(n) && n.type === "td",
    });
    const focusMatch = Editor.above(editor, {
        at: focus,
        match: (n) => Element.isElement(n) && n.type === "td",
    });
    /**
     * If the anchor and focus is not in a table, let the remove happen
     */
    if (!anchorMatch && !focusMatch)
        return false;
    /**
     * If one of the anchor or the focus is in a table, prevent the remove
     * because you are deleting part of a table
     */
    if (!anchorMatch || !focusMatch)
        return true;
    /**
     * If the anchor and focus are in the same cell, let the remove happen
     */
    if (isEqual_1(anchorMatch[1], focusMatch[1]))
        return false;
    return true;
}
/**
 * Put the selection anywhere in a table and then
 */
function setColumnAlign(editor, alignToSet) {
    if (!isInside(editor))
        return;
    const tableInfo = getTableInfo(editor);
    const { table, tablePath, tdIndex } = tableInfo;
    const columns = [...table.columns];
    columns[tdIndex] = { align: alignToSet };
    Transforms.setNodes(editor, { columns }, { at: tablePath });
}
/**
 * Insert table
 */
function insertTable(editor, { rowCount, colCount }) {
    const tableNode = createTable(colCount, rowCount);
    insertNestedBlock(editor, tableNode);
}
/**
 * Table
 */
const Table$1 = {
    getTableInfo,
    createTable,
    insertColumn,
    insertRow,
    insertTable,
    isInside,
    removeColumn,
    removeRow,
    removeTable,
    setColumnAlign,
    shouldIgnoreBackspace,
    shouldIgnoreDelete,
    shouldIgnoreRemoveGlobal,
};

const isEnter$3 = isHotkey("enter");
// Array<[RegExp, NodeFromMatchDataFn]>
const completions = [
    /**
     * Autocomplete Code blocks
     */
    {
        regexp: /^```([a-z]+)?$/i,
        createBlockFn: () => {
            return {
                type: "code-block",
                language: "text",
                children: [{ type: "code-line", children: [{ text: "" }] }],
            };
        },
        pathTail: [0, 0],
    },
    /**
     * Autocomplete Tables
     */
    {
        regexp: /^\|(\|+)$/i,
        createBlockFn: (matchData) => {
            const columnCount = matchData[1].length;
            const table = createTable(columnCount, 2);
            return table;
        },
        pathTail: [0, 0, 0],
    },
    /**
     * Autocomplete Horizontal Rules
     */
    {
        regexp: /^---+$/i,
        createBlockFn: () => {
            return {
                type: "hr",
                children: [{ text: "" }],
            };
        },
        pathTail: [],
    },
];
function handleKeyDownEnterAutocomplete(event, editor) {
    if (!isEnter$3(event.nativeEvent))
        return false;
    const { selection } = editor;
    if (selection === null)
        return false;
    if (Range.isExpanded(selection))
        return false;
    const { anchor } = selection;
    const block = Editor.above(editor, {
        match: (n) => Editor.isBlock(editor, n),
    });
    const path = block ? block[1] : [];
    const start = Editor.start(editor, path);
    const range = { anchor, focus: start };
    const beforeText = Editor.string(editor, range);
    for (const { regexp, createBlockFn, pathTail } of completions) {
        const matchData = beforeText.match(regexp);
        if (matchData) {
            event.preventDefault();
            event.stopPropagation();
            const blockToInsert = createBlockFn(matchData, editor);
            const isVoid = editor.isVoid(blockToInsert);
            Transforms.removeNodes(editor, { at: path });
            Transforms.insertNodes(editor, blockToInsert, { at: path });
            if (!isVoid) {
                const selectionPath = [...path, ...pathTail];
                setTimeout(() => {
                    Transforms.setSelection(editor, {
                        anchor: { path: selectionPath, offset: 0 },
                        focus: { path: selectionPath, offset: 0 },
                    });
                }, 0);
            }
            else {
                const nextBlockPath = [path[0] + 1];
                Transforms.insertNodes(editor, { type: "p", children: [{ text: "" }] }, { at: nextBlockPath });
                const selectionPath = [...nextBlockPath, 0];
                setTimeout(() => {
                    Transforms.setSelection(editor, {
                        anchor: { path: selectionPath, offset: 0 },
                        focus: { path: selectionPath, offset: 0 },
                    });
                });
            }
            return true;
        }
    }
    return false;
}

const isEnter$2 = isHotkey("enter");
const isShiftEnter = isHotkey("shift+enter");
function handleKeyDownEnterVoid(event, editor) {
    const enter = isEnter$2(event.nativeEvent);
    const shiftEnter = isShiftEnter(event.nativeEvent);
    if (!enter && !shiftEnter)
        return false;
    if (editor.selection == null)
        return false;
    const aboveEntry = Editor.above(editor, {
        at: editor.selection.focus,
        match: (n) => {
            return isVoidElement(n);
        },
    });
    if (aboveEntry) {
        stopEvent(event);
        const [, path] = aboveEntry;
        /**
         * If it's `shift+enter` then insert above. Otherwise insert below.
         */
        const nextPath = shiftEnter ? path : Path.next(path);
        insertParagraphAt(editor, nextPath);
        return true;
    }
    else {
        return false;
    }
}

const isTab = isHotkey("tab");
const isShiftTab = isHotkey("shift+tab");
/**
 * If we are in a code-block, we handle `tab` and `shift+tab` which indents
 * and outdents code by 2 spaces.
 */
const handleKeyDownInCodeBlock = (e, editor) => {
    if (!isFocusInside(editor, "code-block")) {
        return false;
    }
    if (isTab(e.nativeEvent)) {
        e.preventDefault();
        e.stopPropagation();
        const codeLines = getElementsByType(editor, "code-line");
        /**
         * Insert two spaces at the beginning of each line
         */
        for (const [, path] of codeLines) {
            Transforms.insertText(editor, "  ", {
                at: { path: [...path, 0], offset: 0 },
            });
        }
        return true;
    }
    if (isShiftTab(e.nativeEvent)) {
        e.preventDefault();
        e.stopPropagation();
        const codeLines = getElementsByType(editor, "code-line");
        /**
         * If there are any lines with less than 2 leading spaces, we abort
         * because we can't outdent.
         */
        if (!canOutdent(codeLines))
            return true;
        /**
         * Remove the first two spaces of each line
         */
        for (const [, path] of codeLines) {
            Transforms.delete(editor, {
                unit: "character",
                distance: 2,
                at: {
                    path: [...path, 0],
                    offset: 0,
                },
            });
        }
        return true;
    }
    return false;
};
/**
 * Tells us if the codeLines passed in can be outdented. They can be outdented
 * if every line has at least two leading spaces.
 */
function canOutdent(codeLines) {
    if (codeLines.length === 0)
        return false;
    for (const [node] of codeLines) {
        const leadingSpaces = countLeadingSpaces(Node.string(node));
        if (leadingSpaces < 2)
            return false;
    }
    return true;
}

const isSpace = isHotkey("space");
const UnorderedListItem$1 = () => {
    return (node) => ({
        type: "unordered-list-item",
        level: null,
        depth: "depth" in node ? node.depth : 0,
        checked: null,
    });
};
const OrderedListItem$1 = () => {
    return (node) => ({
        type: "ordered-list-item",
        level: null,
        depth: "depth" in node ? node.depth : 0,
        checked: null,
    });
};
const TaskListItem$1 = (checked) => {
    return (node) => ({
        type: "task-list-item",
        level: null,
        depth: "depth" in node ? node.depth : 0,
        checked,
    });
};
const Heading$2 = (level) => {
    return () => ({
        type: "heading",
        level,
        depth: null,
        checked: null,
    });
};
const AUTOCOMPLETE = {
    "*": UnorderedListItem$1(),
    "-": UnorderedListItem$1(),
    "+": UnorderedListItem$1(),
    "1.": OrderedListItem$1(),
    o: TaskListItem$1(false),
    x: TaskListItem$1(true),
    "[]": TaskListItem$1(false),
    "[ ]": TaskListItem$1(false),
    "[x]": TaskListItem$1(true),
    "#": Heading$2(1),
    "##": Heading$2(2),
    "###": Heading$2(3),
    "####": Heading$2(4),
    "#####": Heading$2(5),
    "######": Heading$2(6),
};
function handleKeyDownSpaceAutocomplete(event, editor) {
    if (!isSpace(event.nativeEvent))
        return false;
    const { selection } = editor;
    if (selection === null)
        return false;
    if (Range.isExpanded(selection))
        return false;
    const { anchor } = selection;
    const block = Editor.above(editor, {
        match: (n) => Editor.isBlock(editor, n),
    });
    const path = block ? block[1] : [];
    const start = Editor.start(editor, path);
    const range = { anchor, focus: start };
    const beforeText = Editor.string(editor, range);
    const props = AUTOCOMPLETE[beforeText];
    if (props == null)
        return false;
    event.preventDefault();
    event.stopPropagation();
    Transforms.select(editor, range);
    Transforms.delete(editor);
    Transforms.select(editor, start);
    /**
     * We know the return type will be an Element
     */
    const [[node, pos]] = Editor.nodes(editor, {
        match: (n) => Editor.isBlock(editor, n),
    });
    /**
     * We type the return here as our original type definition allows us to
     * include `null` to unset certain values. This is valid in `setNodes`
     */
    const nextProps = props(node);
    Transforms.setNodes(editor, nextProps, { at: pos });
    return true;
}

const handleKeyDownInTable = createKeyDownHandler({
    "mod+enter"(editor) {
        Table$1.insertRow(editor, 1);
        return true;
    },
    "mod+shift+enter"(editor) {
        Table$1.insertRow(editor, 0);
        return true;
    },
    // "mod+alt+enter"(editor) {
    //   Table.insertColumn(editor, 1)
    //   return true
    // },
    // "mod+alt+shift+enter"(editor) {
    //   Table.insertColumn(editor, 0)
    //   return true
    // },
    // "mod+backspace"(editor) {
    //   Table.removeRow(editor)
    //   return true
    // },
    // "mod+alt+backspace"(editor) {
    //   Table.removeColumn(editor)
    //   return true
    // },
    // "mod+shift+backspace"(editor) {
    //   Table.removeTable(editor)
    //   return true
    // },
    tab(editor) {
        tabForward(editor);
        return true;
    },
    "shift+tab"(editor) {
        tabBackward(editor);
        return true;
    },
    up(editor) {
        delayedUpReposition(editor);
        return false; // must not stop event
    },
    down(editor) {
        delayedDownReposition(editor);
        return false; // must not stop event
    },
});
function handleKeyDownTable(event, editor) {
    if (Table$1.isInside(editor)) {
        if (handleKeyDownInTable(event.nativeEvent, editor))
            return true;
    }
}

const isUp = isHotkey("up");
/**
 * If our cursor is located at the top of the document inside a seamless
 * element, pressing the `up` key probably indicates a desire to find space
 * above the seamless element to type in.
 *
 * This code creates a paragraph in this situation.
 *
 * There may be other scenarios where the user desires to put in an empty
 * paragraph, perhaps at the top of a blockquote; however, in these other areas
 * the intention is ambiguous. For example, is it meant to access the inside
 * of the blockquote or just outside it?
 *
 * The top of the document is not ambiguous and also, since a title usually
 * goes up there, or we may want to add content to the top of the document,
 * this seems a common enough desire to warrant a special case.
 */
function handleKeyDownUp(event, editor) {
    if (!isUp(event.nativeEvent))
        return false;
    const { selection } = editor;
    if (selection == null)
        return false;
    if (Range.isExpanded(selection))
        return false;
    const isStart = Editor.isStart(editor, selection.anchor, [0]);
    if (!isStart)
        return false;
    if (!isSeamlessElement(Node.get(editor, [0])))
        return false;
    insertParagraphAt(editor, [0]);
    return true;
}

function onKeyDown(event, editor) {
    if (handleKeyDownInCodeBlock(event, editor))
        return;
    if (handleKeyDownTable(event, editor))
        return;
    if (handleKeyDownSpaceAutocomplete(event, editor))
        return;
    if (handleKeyDownEnterVoid(event, editor))
        return;
    if (handleKeyDownEnterAutocomplete(event, editor))
        return;
    if (handleKeyDownCore(event.nativeEvent, editor))
        return;
    if (handleKeyDownUp(event, editor))
        return;
}

function useHover() {
    const [isHover, setIsHover] = useState(false);
    const onMouseEnter = useCallback(() => setIsHover(true), [setIsHover]);
    const onMouseLeave = useCallback(() => setIsHover(false), [setIsHover]);
    return { isHover, onMouseEnter, onMouseLeave };
}

const $SeamlessContainer = styled.div `
  position: relative;
`;
const $InsertLine = styled.div `
  position: absolute;
  left: 0;
  right: 0;
  height: 1px;
  /**
   * How to make dashes with css linear-gradient
   *
   * https://stackoverflow.com/questions/32500570/gradient-line-with-dashed-pattern
   */
  /* background: linear-gradient(to right, #e0e0e0 67%, transparent 33%); */
  background: linear-gradient(to right, #e0e0e0 67%, transparent 33%);
  background-size: 8px 2px, 100% 2px;
  opacity: 1;
  &.--hover {
    background: linear-gradient(to right, #2880ff 67%, transparent 33%);
    background-size: 8px 2px, 100% 2px;
  }
  &.--previous {
    top: -1px;
  }
  &.--next {
    bottom: 0px;
  }
`;
const $InsertButton = styled.div `
  cursor: pointer;
  position: absolute;
  width: 24px;
  height: 18px;
  line-height: 18px;
  right: 0;
  color: #c0c0c0; // If we can remove the *
  background: white;
  border: 1px solid #e0e0e0;
  text-align: center;
  font-size: 12px;
  border-radius: 5px;
  transition: background-color 0.2s;
  &.--hover {
    color: white;
    background: #2880ff;
    border: white;
  }
  &.--previous {
    top: -9px;
  }
  &.--next {
    bottom: -9px;
  }
`;

function SeamlessContainer({ attributes, children, element, }) {
    /**
     * Get Slate objects and values
     */
    const editor = useSlateStatic();
    const selected = useSelected();
    const focused = useFocused();
    const highlighted = selected && focused;
    const { isHover, onMouseEnter, onMouseLeave } = useHover();
    const showInsertBefore = useMemo(() => {
        if (!highlighted && !isHover)
            return false;
        const path = ReactEditor.findPath(editor, element);
        const entry = getNodeBeforeIf(editor, path);
        if (!entry)
            return true;
        return isSeamlessElement(entry[0]);
    }, [editor, highlighted, element, isHover]);
    const showInsertAfter = useMemo(() => {
        if (!highlighted && !isHover)
            return false;
        const path = ReactEditor.findPath(editor, element);
        const entry = getNodeAfterIf(editor, path);
        if (!entry)
            return true; // if no element after, we want to allow to add one like last item in blockquote
        return isSeamlessElement(entry[0]);
    }, [editor, highlighted, element, isHover]);
    const insertPrevious = useCallback((e) => {
        stopEvent(e);
        const path = ReactEditor.findPath(editor, element);
        insertParagraphAt(editor, path);
    }, [editor, element]);
    const insertNext = useCallback((e) => {
        stopEvent(e);
        const path = ReactEditor.findPath(editor, element);
        insertParagraphAt(editor, Path.next(path));
    }, [editor, element]);
    return (React.createElement($SeamlessContainer, Object.assign({}, attributes, { onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave }),
        children,
        showInsertBefore && (React.createElement(Insert, { className: "--previous", onMouseDown: insertPrevious })),
        showInsertAfter && (React.createElement(Insert, { className: "--next", onMouseDown: insertNext }))));
}
function Insert({ className, onMouseDown, }) {
    const { isHover, onMouseEnter, onMouseLeave } = useHover();
    const calculatedClassName = cx(className, {
        "--hover": isHover,
    });
    return (React.createElement(React.Fragment, null,
        React.createElement($InsertLine, { contentEditable: false, className: calculatedClassName }),
        React.createElement($InsertButton, { contentEditable: false, className: calculatedClassName, onMouseDown: onMouseDown, onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave }, "\u23CE")));
}

/**
 * Block Quote
 */
function BlockQuote({ attributes, children, element, }) {
    return (React.createElement(SeamlessContainer, { attributes: attributes, element: element },
        React.createElement("blockquote", null, children)));
}

/**
 * Code
 */
function CodeBlock({ attributes, element, children, }) {
    return (React.createElement(SeamlessContainer, { attributes: attributes, element: element },
        React.createElement("div", { style: { padding: "0.5em 0" } },
            React.createElement("pre", null,
                React.createElement("code", { spellCheck: false }, children)))));
}
/**
 * Codeline
 */
function CodeLine({ attributes, children, }) {
    return (React.createElement("div", Object.assign({}, attributes, { spellCheck: false }), children));
}

/**
 * Horizontal Rule
 */
function HorizontalRule({ attributes, children, element, }) {
    const selected = useSelected();
    const focused = useFocused();
    const highlighted = selected && focused;
    const containerClassName = cx({ "--highlighted": highlighted });
    /**
     * TODO: Click on `hr` does not focus and therefore `backspace` or `delete` won't work
     *
     * The current theor is that it's a WebKit related issue. The issues
     * manifests on Chrome and Safari but not on Firefox.
     *
     * Thing that worked, kind of:
     *
     * - Change `hr` to an `img` and it works
     * - It works in Firefox
     * - It doesn't work in Chrome
     *
     * Things that didn't work
     *
     * - Change css `user-select` (it's the same)
     * - Change display to `block` or `inline-block`
     * - Change `hr` to `div`
     * - Change `hr` height to be taller
     * - Looked at all the css differences between `img` and `hr` and added
     *   all the differences to `hr` and it still didn't work. See below.
     *
     * Things that were curious
     *
     * - If I use img with height 1px, it fails
     * - If I have `hr` and `img` together, the `hr` still fails
     *
     * Difference between `img` and `hr`
     *
     * - border-radius: just a style we added
     * - display: `inline` vs `block`
     * - overflow-x and overflow-y: `visislbe` vs `hidden`
     * - unicode-bidi: `normal` vs `isolate`
     */
    return (React.createElement(SeamlessContainer, { attributes: attributes, element: element },
        children,
        React.createElement($OuterContainer$1, { contentEditable: false, draggable: true },
            React.createElement($HorizontalRuleContainer, { className: containerClassName },
                React.createElement("hr", null)))));
}
const $HorizontalRuleContainer = styled.div `
  padding: 1em 0;
  img {
    width: 100%;
    height: 50px;
  }
  hr {
    display: block;
    /* The styles in img that aren't in hr */
    /* unicode-bidi: normal;
    overflow-y: visible;
    overflow-x: visible; */
    border-radius: 1px;
    width: 100%;
    height: 1px; // at 1px does not work
  }
  &.--highlighted hr,
  &.--highlighted img {
    box-shadow: 0 0 0 1px white, 0 0 0 3px ${colors.highlight};
  }
`;
const $OuterContainer$1 = styled.div `
  padding-top: 8px;
  padding-bottom: 8px;
  position: relative;
`;

const unselectable = css `
  user-select: none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
`;
function horizontalScrollbar({ thumbColor, borderColor, backgroundColor, height, }) {
    return css `
    overflow-x: auto;
    &::-webkit-scrollbar-track {
      background-color: ${backgroundColor};
      border-radius: ${height / 2}px;
    }

    &::-webkit-scrollbar {
      height: ${height}px;
      background-color: ${backgroundColor};
      border-radius: ${height / 2}px;
    }

    &::-webkit-scrollbar-thumb {
      background-color: ${thumbColor};
      border: 1px solid ${borderColor};
      border-radius: ${height / 2}px;
    }
  `;
}
const Mask$1 = styled.div `
  position: fixed;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  background: rgba(0, 0, 0, 0.75);
`;
styled(Mask$1) `
  background: rgba(127, 127, 127, 0.25);
`;
css `
  box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
`;
css `
  font-size: 0.75em;
  font-weight: 600;
  letter-spacing: 1px;
`;
styled.div `
  position: absolute;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
`;

const $OuterContainer = styled.div `
  padding: 1em 0;
  position: relative;
`;
const $TightContainer = styled.div `
  position: relative;
  display: inline-block;
  /**
   * This is required so that we don't get an extra gap at the bottom.
   * When display is 'inline-block' we get some extra space at the bottom
   * for the descenders because the content is expected to co-exist with text.
   *
   * Setting vertical-align to top, bottom or middle fixes this because it is
   * no longer baseline which causes the issue.
   *
   * This is usually an issue with 'img' but also affects this scenario.
   *
   * https://stackoverflow.com/questions/5804256/image-inside-div-has-extra-space-below-the-image
   */
  vertical-align: top;
`;
const $Image = styled.img `
  display: block;
  border-radius: ${colors.borderRadius};
  transition: box-shadow ${colors.editorBorderTransition};
  &.--focused {
    /* box-shadow: 0 0 0 2px ${colors.highlight}; */
    box-shadow: 0 0 0 1px white, 0 0 0 3px ${colors.highlight};
  }
`;
const $Size = styled.div `
  position: absolute;
  bottom: 4px;
  &.--small {
    bottom: -24px;
  }
  transition: bottom 250ms;
  left: 4px;
  min-width: 50px;
  font: 10px/20px arial, sans-serif;
  padding: 0 7px;
  color: white;
  background: #404040;
  /* box-shadow: 0px 0px 2px 2px rgba(255, 255, 255, 1); */
  box-shadow: 0px 0px 0 1px rgba(255, 255, 255, 0.5);
  border-radius: 3px;
  ${unselectable}
`;
const $InvisibleHandle = styled.div `
  position: absolute;
  right: -9px;
  top: 0;
  bottom: 0;
  width: 18px;
  background: rgba(127, 127, 127, 0.01);
  /* background: green; */
  cursor: ew-resize;
  ${unselectable}
`;
const $Handle = styled.div `
  position: absolute;
  width: 15px;
  height: 30px;
  /* background-color: #1060d0; */
  background-color: ${colors.highlight};
  border-radius: 3px;
  right: -9px;
  margin-top: -15px;
  top: 50%;
  box-shadow: 0px 0px 0px 1px rgba(255, 255, 255, 0.75);

  .--bar {
    position: absolute;
    top: 7px;
    width: 1px;
    height: 15px;
    background: rgba(255, 255, 255, 0.5);
  }
  .--bar-1 {
    left: 7px;
  }
  .--bar-2 {
    left: 10px;
  }
  .--bar-3 {
    left: 4px;
  }
  ${unselectable}
`;

const MIN_WIDTH = 40;
const MAX_WIDTH = 1024;
function Media({ attributes, children, element, }) {
    /**
     * Get Slate objects and values
     */
    const editor = useSlateStatic();
    const selected = useSelected();
    const focused = useFocused();
    const highlighted = selected && focused;
    /**
     * Return the `activeImage` which tells us if the image can be resized and
     * the current width/height as well as the original width/heigh information.
     */
    const activeImage = useMemo(() => editor.createActiveImage(element.url), [element.url]);
    /**
     * Are we in ready or dragging mode
     */
    const [mode, setMode] = useState(() => ({ type: "ready" }));
    /**
     * When the user is dragging, we use a max size image to display. This is
     * because if the image starts small and we resize to big, it becomes
     * blurry. By using the max image size, we are always dragging a high
     * fidelity image
     */
    const displayUrl = useMemo(() => {
        if (mode.type !== "drag" || activeImage.type !== "dynamic") {
            return activeImage.url;
        }
        const width = Math.min(MAX_WIDTH, activeImage.originalWidth);
        const height = (width * activeImage.originalHeight) / activeImage.originalWidth;
        return activeImage.resize(width, height);
    }, [activeImage, mode.type]);
    /**
     * What is the display size from the URL of the image. Note: The image size
     * can be `undefined` which means that it is a static image (i.e. an image
     * that we don't know how to resize)
     */
    const [size, setSize] = useState(() => activeImage.type === "dynamic"
        ? {
            width: activeImage.width,
            height: activeImage.height,
        }
        : { width: undefined, height: undefined });
    const sizeRef = useRef(size);
    /**
     * Mouse down starts the resize
     */
    const onMouseDown = useCallback((e) => {
        if (activeImage.type === "static")
            return;
        if (sizeRef.current.width == undefined)
            return;
        if (sizeRef.current.height == undefined)
            return;
        setMode({ type: "drag" });
        const startX = e.clientX;
        const startWidth = sizeRef.current.width;
        let currentSize = sizeRef.current;
        /**
         * Handle resize dragging through an event handler on mouseMove on the
         * document.
         */
        function onDocumentMouseMove(e) {
            if (activeImage.type === "static")
                return;
            const maxWidth = Math.min(getEditorInnerWidth(editor), activeImage.originalWidth, MAX_WIDTH);
            /**
             * Calculate the proposed width based on drag position
             */
            const proposedWidth = startWidth + e.clientX - startX;
            /**
             * Constrain the proposed with between min, max and original width
             */
            const nextWidth = Math.min(maxWidth, Math.max(MIN_WIDTH, proposedWidth));
            /**
             * Calculate the inverseAspect (used to calculate height)
             */
            const inverseAspect = activeImage.originalHeight / activeImage.originalWidth;
            /**
             * Calculate height
             */
            const nextHeight = Math.round(nextWidth * inverseAspect);
            /**
             * Set size on the state (to show resize) and the ref (for use in this
             * method)
             */
            currentSize = { width: nextWidth, height: nextHeight };
            setSize(currentSize);
            sizeRef.current = currentSize;
        }
        const originalCursor = document.body.style.cursor;
        /**
         * When the user releases the mouse, remove all the event handlers
         */
        function onDocumentMouseUp() {
            document.removeEventListener("mousemove", onDocumentMouseMove);
            document.removeEventListener("mouseup", onDocumentMouseUp);
            setMode({ type: "ready" });
            document.body.style.cursor = originalCursor;
            /**
             * Set the image url for the new size of image
             */
            if (activeImage.type === "static")
                return;
            const url = activeImage.resize(currentSize.width, currentSize.height);
            Transforms.setNodes(editor, { url });
        }
        /**
         * Attach document event listeners
         */
        document.addEventListener("mousemove", onDocumentMouseMove);
        document.addEventListener("mouseup", onDocumentMouseUp);
        /**
         * While dragging, we want the cursor to be `ew-resize` (left-right arrow)
         * even if the cursor happens to not be exactly on the handle at the moment
         * due to a delay in the cursor moving to a location and the image resizing
         * to it.
         *
         * Also, image has max width/height and the cursor can fall outside of it.
         */
        document.body.style.cursor = "ew-resize";
    }, []);
    const imageClassName = cx({ "--focused": highlighted });
    return (React.createElement(SeamlessContainer, { attributes: attributes, element: element },
        React.createElement($OuterContainer, null,
            children,
            React.createElement($TightContainer, { contentEditable: false },
                React.createElement($Image, { src: displayUrl, width: size.width, height: size.height, className: imageClassName }),
                highlighted ? (React.createElement(React.Fragment, null,
                    mode.type === "drag" ? (React.createElement($Size, { className: cx({
                            "--small": typeof size.width === "number" && size.width <= 75,
                        }) },
                        size.width,
                        " \u00D7 ",
                        size.height)) : null,
                    activeImage.type === "dynamic" ? (React.createElement(React.Fragment, null,
                        React.createElement($Handle, null,
                            React.createElement("div", { className: "--bar --bar-1" }),
                            React.createElement("div", { className: "--bar --bar-2" }),
                            React.createElement("div", { className: "--bar --bar-3" })),
                        React.createElement($InvisibleHandle, { onMouseDown: onMouseDown }))) : null)) : null))));
}

const ArrowLineUpIcon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16, d: "M128 224V72M56 144l72-72 72 72M40 40h176" })));
const TrashIcon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16, d: "M216 56H40M104 104v64M152 104v64M200 56v152a8 8 0 0 1-8 8H64a8 8 0 0 1-8-8V56M168 56V40a16 16 0 0 0-16-16h-48a16 16 0 0 0-16 16v16" })));
const AlignLeftIcon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16, d: "M40 68h176M40 108h128M40 148h176M40 188h128" })));
const AlignCenterIcon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16, d: "M40 68h176M64 108h128M40 148h176M64 188h128" })));
const AlignRightIcon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16, d: "M40 68h176M88 108h128M40 148h176M88 188h128" })));

const PlainTextIcon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16, d: "M152 192 80 56 8 192" }),
    React.createElement("ellipse", { cx: 208, cy: 166.9, rx: 32, ry: 28, fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16 }),
    React.createElement("path", { d: "M184 112.4a34.1 34.1 0 0 1 24-9.5c17.7 0 32 12.5 32 28V192M130.8 152H29.2", fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16 })));
const HtmlIcon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16, d: "M120 176H88M104 216v-40M36 176v40M64 176v40M36 196h28M212 176v40h24M144 216v-40l20 28 20-28v40M48 136V40a8 8 0 0 1 8-8h96l56 56v48" }),
    React.createElement("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16, d: "M152 32v56h56" })));
const CssIcon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("path", { d: "M80 210.5a21 21 0 0 1-14 5.5c-12.2 0-22-10.7-22-24s9.8-24 22-24a21 21 0 0 1 14 5.5M112 212a25.2 25.2 0 0 0 15 5c9 0 17-3 17-13 0-16-32-9-32-24 0-8 6-13 15-13a25.2 25.2 0 0 1 15 5M176 212a25.2 25.2 0 0 0 15 5c9 0 17-3 17-13 0-16-32-9-32-24 0-8 6-13 15-13a25.2 25.2 0 0 1 15 5M48 128V40a8 8 0 0 1 8-8h96l56 56v40", fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16 }),
    React.createElement("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16, d: "M152 32v56h56" })));
const JsIcon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("path", { d: "M72 168v32a16 16 0 0 1-32 0M176 224h24a8 8 0 0 0 8-8V88l-56-56H56a8 8 0 0 0-8 8v88", fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16 }),
    React.createElement("path", { d: "M104 212a25.2 25.2 0 0 0 15 5c9 0 17-3 17-13 0-16-32-9-32-24 0-8 6-13 15-13a25.2 25.2 0 0 1 15 5M152 32v56h56", fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16 })));
const FileCodeIcon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16, d: "M152 32v56h56M148 128l24 24-24 24M108 128l-24 24 24 24" }),
    React.createElement("path", { d: "M200 224a8 8 0 0 0 8-8V88l-56-56H56a8 8 0 0 0-8 8v176a8 8 0 0 0 8 8Z", fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16 })));

const CheckIcon$1 = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 32, d: "M216 72 104 184l-56-56" })));
const XCircleIcon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("circle", { cx: 128, cy: 128, r: 96, fill: "none", stroke: "currentColor", strokeMiterlimit: 10, strokeWidth: 16 }),
    React.createElement("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16, d: "m160 96-64 64M160 160 96 96" })));
const PlusIcon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16, d: "M40 128h176M128 40v176" })));
/**
 * Converted from
 *
 * https://phosphoricons.com/
 * https://github.com/phosphor-icons/phosphor-home
 *
 * using
 *
 * https://react-svgr.com/playground/
 *
 * Online editing tool
 *
 * https://www.svgviewer.dev/s/47853/symbol
 */
const CheckedIcon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: 192, height: 192, viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("path", { fill: "#2888ff", d: "M208 32H48a16 16 0 0 0-16 16v160a16 16 0 0 0 16 16h160a16 16 0 0 0 16-16V48a16 16 0 0 0-16-16Zm-30.5 77.8-58.6 56a8.1 8.1 0 0 1-5.6 2.2 7.9 7.9 0 0 1-5.5-2.2l-29.3-28a8 8 0 1 1 11-11.6l23.8 22.7 53.2-50.7a8 8 0 0 1 11 11.6Z" })));
function UncheckedIcon(props) {
    return (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: 192, height: 192, viewBox: "0 0 256 256" }, props),
        React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
        React.createElement("rect", { x: 40, y: 40, width: 176, height: 176, rx: 8, fill: "none", stroke: "#d0d0d0", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16 })));
}
const H1Icon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("path", { fill: "none", stroke: "currentColor", strokeLinecap: "square", strokeLinejoin: "miter", strokeWidth: 16, d: "M40 56v120M144 116H40M144 56v120M196 124l24-16v92" })));
const H2Icon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("path", { fill: "none", stroke: "currentColor", strokeLinecap: "square", strokeLinejoin: "miter", strokeWidth: 16, d: "M40 56v120M144 116H40M144 56v120M193.9 118.7A24 24 0 0 1 240 128a23.6 23.6 0 0 1-4.1 13.4h0L192 200h48" })));
const H3Icon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("path", { fill: "none", stroke: "currentColor", strokeLinecap: "square", strokeLinejoin: "miter", strokeWidth: 16, d: "M40 56v120M144 116H40M144 56v120M192 108h48l-28 40a28 28 0 1 1-19.8 47.8" })));
const BoldIcon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("path", { d: "M64 120h88a40 40 0 0 1 0 80H64V48h76a36 36 0 0 1 0 72", fill: "none", stroke: "currentColor", strokeLinecap: "square", strokeLinejoin: "miter", strokeWidth: 24 })));
const ItalicIcon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("path", { fill: "none", stroke: "currentColor", strokeLinecap: "square", strokeLinejoin: "miter", strokeWidth: 16, d: "m152 56-48 144M64 200h80M112 56h80" })));
const LinkIcon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("path", { d: "m132.5 61.3 9.6-9.7a44.1 44.1 0 0 1 62.3 62.3l-30.3 30.2a43.9 43.9 0 0 1-62.2 0", fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16 }),
    React.createElement("path", { d: "m123.5 194.7-9.6 9.7a44.1 44.1 0 0 1-62.3-62.3l30.3-30.2a43.9 43.9 0 0 1 62.2 0", fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16 })));
const QuoteIcon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("path", { d: "M108 144H40a8 8 0 0 1-8-8V72a8 8 0 0 1 8-8h60a8 8 0 0 1 8 8v88a40 40 0 0 1-40 40M224 144h-68a8 8 0 0 1-8-8V72a8 8 0 0 1 8-8h60a8 8 0 0 1 8 8v88a40 40 0 0 1-40 40", fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16 })));
const BlockquoteIndentIcon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16, d: "M32 128h152M112 56l72 72-72 72M216 40v176" })));
const BlockquoteOutdentIcon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("path", { fill: "none", stroke: "#000", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16, d: "M224 128H72M144 56l-72 72 72 72M40 40v176" })));
const TableIcon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("path", { d: "M32 56h192v136a8 8 0 0 1-8 8H40a8 8 0 0 1-8-8V56h0ZM32 104h192M32 152h192M88 104v96", fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 12 })));
const CodeIcon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16, d: "m64 88-48 40 48 40M192 88l48 40-48 40M160 40 96 216" })));
const ImageIcon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("rect", { x: 32, y: 48, width: 192, height: 160, rx: 8, fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 14 }),
    React.createElement("path", { d: "m32 168 50.3-50.3a8 8 0 0 1 11.4 0l44.6 44.6a8 8 0 0 0 11.4 0l20.6-20.6a8 8 0 0 1 11.4 0L224 184", fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 14 }),
    React.createElement("circle", { cx: 156, cy: 100, r: 12, fill: "currentColor" })));
const EllipsisIcon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("circle", { cx: 128, cy: 128, r: 16, fill: "currentColor" }),
    React.createElement("circle", { cx: 192, cy: 128, r: 16, fill: "currentColor" }),
    React.createElement("circle", { cx: 64, cy: 128, r: 16, fill: "currentColor" })));
/**
 * Modified `arrows-in-line-vertical`
 */
const HrIcon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16, d: "M216 128H40" })));
const CaretDown = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16, d: "m208 96-80 80-80-80" })));
const StrikeIcon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16, d: "M40 128h176M76.3 96a25.3 25.3 0 0 1-1.2-8c0-22.1 22-40 52.9-40 23.8 0 42.3 10.6 49.5 25.5M72 168c0 22.1 25.1 40 56 40s56-17.9 56-40c0-23.8-21.6-33-45.6-40" })));
const IndentIcon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16, d: "M112 128h104M112 64h104M40 192h176M40 56l40 40-40 40" })));
const OutdentIcon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16, d: "M112 128h104M112 64h104M40 192h176M72 56 32 96l40 40" })));
const ChecklistIcon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("path", { fill: "none", stroke: "#000", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16, d: "M128 128h88M128 64h88M128 192h88M92 48 57.3 80 40 64M92 112l-34.7 32L40 128M92 176l-34.7 32L40 192" })));
const UnorderedListIcon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16, d: "M88 64h128M88 128h128M88 192h128" }),
    React.createElement("circle", { cx: 44, cy: 64, r: 12, fill: "currentColor" }),
    React.createElement("circle", { cx: 44, cy: 128, r: 12, fill: "currentColor" }),
    React.createElement("circle", { cx: 44, cy: 192, r: 12, fill: "currentColor" })));
const OrderedListIcon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("path", { stroke: "#000", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16, d: "M104 128h112M104 64h112M104 192h112" }),
    React.createElement("path", { fill: "none", stroke: "#000", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16, d: "m40 60 16-8v56M41.1 152.6a14 14 0 1 1 24.5 13.2L40 200h28" })));
const SuperscriptIcon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("rect", { x: 40, y: 40, width: 176, height: 176, rx: 8, fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16 }),
    React.createElement("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16, d: "M94.1 121.9 128 88l33.9 33.9M128 168V88" })));
const SubscriptIcon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("rect", { x: 40, y: 40, width: 176, height: 176, rx: 8, fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16 }),
    React.createElement("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16, d: "M94.1 134.1 128 168l33.9-33.9M128 88v80" })));

const CheckIcon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16, d: "M216 72 104 184l-56-56" })));
const ClipboardTextIcon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16, d: "M96 152h64M96 120h64M160 40h40a8 8 0 0 1 8 8v168a8 8 0 0 1-8 8H56a8 8 0 0 1-8-8V48a8 8 0 0 1 8-8h40" }),
    React.createElement("path", { d: "M88 72v-8a40 40 0 0 1 80 0v8Z", fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16 })));
const PencilIcon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("path", { d: "M92.7 216H48a8 8 0 0 1-8-8v-44.7a7.9 7.9 0 0 1 2.3-5.6l120-120a8 8 0 0 1 11.4 0l44.6 44.6a8 8 0 0 1 0 11.4l-120 120a7.9 7.9 0 0 1-5.6 2.3ZM136 64l56 56M164 92l-96 96M95.5 215.5l-55-55", fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16 })));
const LinkBreakIcon = (props) => (React.createElement("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 256 256" }, props),
    React.createElement("path", { fill: "none", d: "M0 0h256v256H0z" }),
    React.createElement("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 16, d: "M96 72V48M160 208v-24M72 96H48M208 160h-24M71 128.4l-11.3 11.3a40 40 0 0 0 56.6 56.6l11.3-11.3M185 127.6l11.3-11.3a40 40 0 0 0-56.6-56.6L128.4 71" })));

const Fault$1 = styled.div `
  color: #cc0000;
  font-weight: 600;
  font-size: 14px;
  line-height: 20px;
  margin-top: 4px;
`;

const Hint = styled.div `
  color: #8b91a4;
  font-size: 14px;
  line-height: 20px;
  margin-top: 4px;
`;

const Label = styled.div `
  color: #8b91a4;
  font-size: 14px;
  margin-bottom: 6px;
`;

const $Block = styled.div `
  margin: 18px 32px;
  &:first-of-type {
    margin-top: 0;
    margin-bottom: 30px;
  }
  &:last-of-type {
    margin-bottom: 0;
  }
  &.--align-right {
    text-align: right;
  }
  &.--divider-bottom {
    border-bottom: 1px solid silver;
  }
  p {
    line-height: 1.5em;
    margin-bottom: 1em;
  }
`;
function Block(_a) {
    var { children, fault, hint, label } = _a, props = __rest(_a, ["children", "fault", "hint", "label"]);
    return (React.createElement($Block, Object.assign({}, props),
        label ? React.createElement(Label, null, label) : null,
        children,
        fault ? React.createElement(Fault$1, null, fault) : null,
        hint ? React.createElement(Hint, null, hint) : null));
}

const Focus = css `
  border-color: #80bdff;
  border: 1px solid rgb(128, 189, 255);
  box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.25);
  outline: none;
`;
const InputBox = css `
  background-color: rgb(250, 251, 252);
  border-radius: 4px;
  border: 1px solid rgb(206, 212, 218);
  box-shadow: inset 0 1px 2px rgba(27, 31, 35, 0.075);
  color: rgb(73, 80, 87);
  font-size: 14px;
  line-height: 36px;
  padding: 0 12px;
  width: 100%;
  /**
   * Added this to override "user-select: none" because I wasn't able to get
   * a focus in the input for HabitStack for the link modal. But it works
   * everywhere else and this change didn't fix this issue. 
   *
   * So, I don't think this does anything but I'm leaving it for now.
   *
   * If we fix the HabitStack issue, try removing this and if it still works
   * then we should remove the code below.
   */
  user-select: text;
  &:focus {
    ${Focus}
  }
  &::placeholder {
    font-style: italic;
    color: rgba(0, 0, 0, 0.2);
  }
`;
const Style = { Focus, InputBox };

const $Button = styled.button `
  /* display: inline-block not necessary for a button element but we also
   * style a div for use in Form.File which does need this.
   */
  display: inline-block;

  background-color: #1b7eea;
  background-image: linear-gradient(180deg, #068dff 0%, #007bf8 100%);
  border-radius: 5px;
  border-radius: 5px;
  border: 1px solid #007bf8;
  box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.2),
    inset 0 1px 0 0 rgba(255, 255, 255, 0.05);
  color: white;
  cursor: pointer;
  font-size: 16px;
  font-weight: 500;
  line-height: 34px;
  padding: 0 24px;
  &:focus {
    ${Style.Focus}
  }
  &:hover {
    filter: brightness(107%);
  }
  &:active {
    ${Style.Focus}
  }
  .fa {
    margin-right: 0.25em;
  }
`;
function Button$1(props) {
    return React.createElement($Button, Object.assign({}, props));
}
styled.div `
  margin-top: 24px;
`;

const $Close = styled.div `
  color: #8b91a4;
  cursor: pointer;
  font-size: 30px;
  font-weight: 300;
  position: absolute;
  right: 32px;
  top: 24px;
  &:hover {
    color: black;
  }
`;
function Close(props) {
    return React.createElement($Close, Object.assign({}, props), "\u00D7");
}

const initialStyles = css `
  &.--initial {
    opacity: 0;
    transform: translateY(-4px);
  }
  opacity: 1;
  transform: translateY(0);
  /**
   * Looks better when the element appears a little before movement has stopped.
   */
  transition: opacity linear 100ms, transform linear 150ms;
`;

const Dialog$1 = styled.div `
  ${initialStyles}
  background: white;
  border-radius: 8px;
  border: 1px solid #dde3e8;
  box-shadow: 0 4px 8px 4px rgba(0, 16, 32, 0.05);
  padding: 30px 0 30px;
  position: relative;

  /**
   * Formatting specifically to work well with modal library
   */
  @media (max-width: 767px) {
    width: calc(100% - 2em);
  }

  /**
   * Give us some extra space at the bottom for the gutter. We can't easily
   * set is in JavaScript because we are using absolute positioning.
   */
  margin-bottom: 1em;

  /**
   * The minimal amount of CSS to force the iPhone to make space underneath
   * the position absolute. To be clear, all of 'width', 'height' and 'content'
   * are required.
   */
  &::after {
    position: absolute;
    content: " ";
    width: 1px;
    height: 1px;
    bottom: -1em;
  }
`;

/**
 * Full Width divider
 */
const Divider = styled.div `
  border-bottom: 1px solid #dde3e8;
`;

const $Label = styled.label ``;
const $Input$1 = styled.input `
  display: none;
`;
const $DivButton = $Button.withComponent("div");
function File({ onChange, children, }) {
    return (React.createElement($Label, null,
        React.createElement($Input$1, { type: "file", multiple: true, onChange: onChange }),
        React.createElement($DivButton, null, children)));
}

const Heading$1 = styled.h1 `
  color: #46535e;
  font-size: 20px;
  font-weight: 500;
`;

const $Input = styled.input(InputBox);
const isEnter$1 = isHotkey("enter");
const isModEnter$1 = isHotkey("mod+enter");
function Input(_a) {
    var { onKeyDown, onSubmit } = _a, props = __rest(_a, ["onKeyDown", "onSubmit"]);
    function handleKeyDown(e) {
        if (isEnter$1(e.nativeEvent) || isModEnter$1(e.nativeEvent)) {
            e.preventDefault();
            e.stopPropagation();
            if (onSubmit == null)
                return;
            onSubmit(e);
        }
        if (onKeyDown == null)
            return;
        onKeyDown(e);
    }
    return React.createElement($Input, Object.assign({ onKeyDown: handleKeyDown }, props));
}

const $Progress = styled.div `
  background: #e8e9ea;
  background-image: linear-gradient(
    180deg,
    rgba(255, 255, 255, 0.02) 0%,
    rgba(0, 0, 0, 0.02) 100%
  );
  height: 24px;
  border-radius: 4px;
`;
const $ProgressBar = styled.div `
  display: inline-block;
  background-color: #1b7eea;
  background-image: linear-gradient(180deg, #068dff 0%, #007bf8 100%);
  height: 24px;
  border-radius: 4px;
  /**
   * Smooth the progress bar moving animation
   */
  transition: width 100ms linear;
`;
/**
 * Show a progress bar.
 *
 * `progress` shall be from 0 to 1.
 */
function Progress(_a) {
    var { progress } = _a, props = __rest(_a, ["progress"]);
    const width = Math.round(progress * 100);
    return (React.createElement($Progress, Object.assign({}, props),
        React.createElement($ProgressBar, { style: { width: `${width}%` } })));
}

const $TextArea = styled.textarea(InputBox);
const isEnter = isHotkey("enter");
const isModEnter = isHotkey("mod+enter");
function TextArea(_a) {
    var { onKeyDown, onSubmit } = _a, props = __rest(_a, ["onKeyDown", "onSubmit"]);
    function handleKeyDown(e) {
        if (isEnter(e.nativeEvent) || isModEnter(e.nativeEvent)) {
            e.preventDefault();
            e.stopPropagation();
            if (onSubmit == null)
                return;
            onSubmit(e);
        }
        if (onKeyDown == null)
            return;
        onKeyDown(e);
    }
    return React.createElement($TextArea, Object.assign({ onKeyDown: handleKeyDown }, props));
}

const Form$1 = {
    Block,
    Button: Button$1,
    Close,
    Dialog: Dialog$1,
    Divider,
    Fault: Fault$1,
    File,
    Heading: Heading$1,
    Hint,
    Input,
    Label,
    Progress,
    TextArea,
};

function useHotkey(key, callback, deps, isEnabled = () => true) {
    const isKey = isHotkey(key);
    return useEffect(() => {
        if (!isEnabled())
            return;
        function keyDownHandler(e) {
            if (isKey(e)) {
                e.preventDefault();
                e.stopPropagation();
                callback();
            }
        }
        document.addEventListener("keydown", keyDownHandler);
        return () => {
            document.removeEventListener("keydown", keyDownHandler);
        };
    }, deps);
}

var Position$1;
(function (Position) {
    Position[Position["Below"] = 0] = "Below";
    Position[Position["BelowLeft"] = 1] = "BelowLeft";
    Position[Position["Inside"] = 2] = "Inside";
})(Position$1 || (Position$1 = {}));
function positionBelow(srcRect, destRect) {
    return { left: destRect.left, top: destRect.bottom };
}
function positionBelowLeft(srcRect, destRect) {
    return {
        left: destRect.left + destRect.width - srcRect.width,
        top: destRect.bottom,
    };
}
function positionInside(srcRect, destRect) {
    return {
        left: destRect.left + (destRect.width - srcRect.width) / 2,
        top: destRect.top,
    };
}
function getPosition(position, srcRect, destRect) {
    switch (position) {
        case Position$1.Below:
            return positionBelow(srcRect, destRect);
        case Position$1.Inside:
            return positionInside(srcRect, destRect);
        case Position$1.BelowLeft:
            return positionBelowLeft(srcRect, destRect);
    }
    throw new Error(`Unhandled position value ${position}`);
}
/**
 * Reposition under an element, usually the button that opened the container
 */
function useContainerReposition({ dest, ref, position = Position$1.Below, }) {
    // is.object(ref)
    // useLockBodyScroll()
    return useReposition(() => {
        const { innerWidth } = window;
        if (ref.current == null)
            throw new Error(`Ref not assigned but should be I think`);
        const srcRect = ref.current.getBoundingClientRect();
        const destRect = dest.getBoundingClientRect();
        if (innerWidth < 768) {
            /**
             * TODO:
             *
             * There are still two issues:
             *
             * - If there is a scrolled sticky, the position is wrong. May be a bug
             *   in the browser in how it returns the position of a sticky.
             *
             * - If the container ends up below the fold, we get two scrollbars which
             *   feels weird. Probably should have the one scrollbar that scrolls
             *   both. The second scrollbar visually looks wrong and confusing.
             *   A temporary improvement could be to change the design of the second
             *   scrollbar (the inner one). Long term, I think if the item is bigger,
             *   pushing the bottom of the page to grow longer should be okay.
             */
            const pos = { left: 20, top: destRect.bottom };
            return fitInViewport(pos, srcRect);
        }
        else {
            const rect = getPosition(position, srcRect, destRect);
            // const rect =
            //   position === Position.Below
            //     ? positionBelow(srcRect, destRect)
            //     : positionInside(srcRect, destRect)
            const fitRect = fitInViewport(rect, srcRect);
            return fitRect;
        }
    }, [dest]);
}
const CONTAINER_STYLE = css `
  background: white;
  border: 1px solid #00000030;
  border-radius: 5px;
  box-shadow: 0 3px 5px rgba(0, 0, 0, 0.1);
`;
const Container$1 = styled.div `
  ${CONTAINER_STYLE}
  ${initialStyles}
  position: absolute;
  width: auto;
  min-width: 10rem;
  left: 1600px;
  border: 1px solid silver;
  @media (max-width: 767px) {
    width: calc(100% - 2em);
  }
  @media (min-width: 768px) {
  }
  /**
   * Give us some extra space at the bottom for the gutter. We can't easily
   * set is in JavaScript because we are using absolute positioning.
   */
  margin-bottom: 1em;
  /**
   * The minimal amount of CSS to force the iPhone to make space underneath
   * the position absolute. To be clear, all of 'width', 'height' and 'content'
   * are required.
   */
  &::after {
    position: absolute;
    content: " ";
    width: 1px;
    height: 1px;
    bottom: -1em;
  }
`;

const $Mask = styled.div `
  position: fixed;
  user-select: none;
  /* background: rgba(0, 0, 0, 0.5); */
  /* background: rgba(127, 127, 127, 0.5); */
  /* background: #80808040; */
  box-shadow: 0 3px 5px rgba(0, 0, 0, 0.1);
  min-width: 10rem;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  overflow-y: auto;
`;
function Mask({ children }) {
    const ref = useRef(null);
    const modal = useInModal();
    function close(e) {
        if (ref.current === e.target) {
            modal.close();
        }
    }
    return (React.createElement($Mask, { ref: ref, onClick: close, style: { zIndex: modal.zIndex } }, children));
}

function Body(props) {
    return React.createElement("div", Object.assign({ className: "modal-body" }, props));
}
function Dialog({ dest, title, children, position, width, }) {
    const ref = useRef(null);
    const modal = useInModal();
    const initial = useInitial();
    useHotkey("escape", () => modal.close(), [modal]);
    const pos = useContainerReposition({
        dest,
        ref,
        position,
    });
    const className = cx({ "--initial": initial });
    /**
     * TODO:
     * Fix as const and provide the proper CSS type for a div
     */
    const style = Object.assign({ position: "absolute", width }, pos);
    return (React.createElement(ResetContainer, null,
        React.createElement(Mask, null,
            React.createElement(Form$1.Dialog, { ref: ref, style: style, className: className },
                React.createElement(Form$1.Block, null,
                    title ? React.createElement(Form$1.Heading, null, title) : null,
                    React.createElement(Form$1.Close, { onClick: modal.close })),
                children))));
}
Dialog.Body = Body;

class Fault {
    constructor(value) {
        // Identify a Fault object by this boolean property
        this.__isFault__ = true;
        const MyError = Error;
        // method not available on some browsers (e.g. iOS)
        if (typeof MyError.captureStackTrace !== "undefined") {
            MyError.captureStackTrace(this, Fault);
        }
        this.value = value;
    }
    toJSONValue() {
        return this.value;
    }
    // Used to display error message to console
    toString() {
        return `Fault: ${JSON.stringify(this.value, null, 2)}`;
    }
    static isFault(object) {
        if (typeof object !== "object")
            return false;
        return !!object.__isFault__;
    }
}

class Field {
    constructor(form, key) {
        this.form = form;
        this.key = key;
        this.setValue = (value) => {
            const nextValues = Object.assign({}, this.form.values);
            nextValues[this.key] = value;
            this.form.setValues(nextValues);
        };
        this.setFault = (value) => {
            if (value == null) {
                delete this.form.faults[this.key];
                return;
            }
            else {
                this.form.setFaults(Object.assign(Object.assign({}, this.form.faults), { [this.key]: value }));
            }
        };
        this.onChange = (e) => {
            /**
             * A bit of a kludge because we can assign a `string` which is what
             * `e.currentTarget.value` is to a `number` type which is wrong and bad!
             */
            const value = e.currentTarget.value;
            this.setValue(value);
        };
        /**
         * Identical to `setValue` but is a more descriptive way of reacting to
         * a change event on certain types of custom components that won't event
         * an `event` object to capture a change.
         */
        this.onChangeValue = (value) => {
            this.setValue(value);
        };
    }
    get value() {
        return this.form.values[this.key];
    }
    get fault() {
        return this.form.faults[this.key];
    }
}
class Form {
    constructor(values, setValues, faults, setFaults) {
        this.values = values;
        this.setValues = setValues;
        this.faults = faults;
        this.setFaults = setFaults;
        this.submit = (fn) => __awaiter(this, void 0, void 0, function* () {
            try {
                yield fn(this.values);
            }
            catch (error) {
                if (Fault.isFault(error)) {
                    this.setFaults(error.value);
                }
                else {
                    // TODO:
                    // rethrow for now but switch to modal.open(ErrorDialog, ...)
                    throw error;
                }
            }
        });
    }
    field(key) {
        return new Field(this, key);
    }
}
function useForm(initialValues, initialFaults = {}) {
    const [values, setValues] = useState(initialValues);
    const [faults, setFaults] = useState(initialFaults);
    return new Form(values, setValues, faults, setFaults);
}

/**
 * Insert Link Dialog
 */
function InsertLinkDialog({ dest, editor, }) {
    const modal = useInModal();
    /**
     * We use a refer so that we only calculate the linkInfo at the time the
     * dialog is called. If we call it later, the selection will have changed
     * and we won't have the right information.
     */
    const linkInfoRef = useRef(getLinkInfo(editor));
    const linkInfo = linkInfoRef.current;
    const form = useForm(() => ({ url: linkInfo.url, label: linkInfo.text }));
    const urlField = form.field("url");
    const labelField = form.field("label");
    function submit() {
        form.submit(({ url, label }) => __awaiter(this, void 0, void 0, function* () {
            /**
             * If there is no URL, close the insert link dialog.
             */
            if (url.length === 0) {
                modal.close();
                return;
            }
            /**
             * If there is a URL but it is invalid, ask user to enter a valid URL
             */
            if (!isUrl(url)) {
                urlField.setFault("Please enter a valid URL");
                return;
            }
            /**
             * If the label is empty, we use the URL
             */
            const labelToInsert = label.length === 0 ? url : label;
            ReactEditor.focus(editor);
            Transforms.select(editor, linkInfo.range);
            insertLink(editor, url, labelToInsert);
            modal.close();
        }));
    }
    const title = linkInfo.text.length > 0 ? "Edit link" : "Insert link";
    return (React.createElement(Dialog, { title: title, dest: dest, width: 320 },
        React.createElement(Form$1.Block, { label: "URL", fault: urlField.fault },
            React.createElement(Form$1.Input, { value: urlField.value, onChange: urlField.onChange, onSubmit: submit, autoFocus: true })),
        React.createElement(Form$1.Block, { label: "Link text", fault: labelField.fault },
            React.createElement(Form$1.Input, { value: labelField.value, onChange: labelField.onChange, onSubmit: submit, placeholder: "Use URL above when empty" })),
        React.createElement(Form$1.Block, null,
            React.createElement(Form$1.Button, { onClick: submit },
                React.createElement("i", { className: "fa fa-link" }),
                "Insert Link"))));
}

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return _setToString(_overRest(func, start, identity_1), func + '');
}

var _baseRest = baseRest;

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

var _baseFindIndex = baseFindIndex;

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

var _baseIsNaN = baseIsNaN;

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

var _strictIndexOf = strictIndexOf;

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? _strictIndexOf(array, value, fromIndex)
    : _baseFindIndex(array, _baseIsNaN, fromIndex);
}

var _baseIndexOf = baseIndexOf;

/**
 * This function is like `baseIndexOf` except that it accepts a comparator.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOfWith(array, value, fromIndex, comparator) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (comparator(array[index], value)) {
      return index;
    }
  }
  return -1;
}

var _baseIndexOfWith = baseIndexOfWith;

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * The base implementation of `_.pullAllBy` without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to remove.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns `array`.
 */
function basePullAll(array, values, iteratee, comparator) {
  var indexOf = comparator ? _baseIndexOfWith : _baseIndexOf,
      index = -1,
      length = values.length,
      seen = array;

  if (array === values) {
    values = _copyArray(values);
  }
  if (iteratee) {
    seen = _arrayMap(array, _baseUnary(iteratee));
  }
  while (++index < length) {
    var fromIndex = 0,
        value = values[index],
        computed = iteratee ? iteratee(value) : value;

    while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
      if (seen !== array) {
        splice.call(seen, fromIndex, 1);
      }
      splice.call(array, fromIndex, 1);
    }
  }
  return array;
}

var _basePullAll = basePullAll;

/**
 * This method is like `_.pull` except that it accepts an array of values to remove.
 *
 * **Note:** Unlike `_.difference`, this method mutates `array`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {Array} values The values to remove.
 * @returns {Array} Returns `array`.
 * @example
 *
 * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
 *
 * _.pullAll(array, ['a', 'c']);
 * console.log(array);
 * // => ['b', 'b']
 */
function pullAll(array, values) {
  return (array && array.length && values && values.length)
    ? _basePullAll(array, values)
    : array;
}

var pullAll_1 = pullAll;

/**
 * Removes all given values from `array` using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
 * to remove elements from an array by predicate.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {...*} [values] The values to remove.
 * @returns {Array} Returns `array`.
 * @example
 *
 * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
 *
 * _.pull(array, 'a', 'c');
 * console.log(array);
 * // => ['b', 'b']
 */
var pull = _baseRest(pullAll_1);

var pull_1 = pull;

/**
 * Character Reference
 *
 * Ctrl+P Ctrl+Shift+P Ctrl+Alt+P
 * P P P
 */
const UNICODE_CMD = "\u2318";
const UNICODE_CTRL = "\u2303";
const UNICODE_SHIFT = "";
const UNICODE_OPT = "";
const UNICODE_ENTER = "";
const MAC_KEYS = {
    alt: UNICODE_OPT,
    ctrl: UNICODE_CTRL,
    opt: UNICODE_OPT,
    shift: UNICODE_SHIFT,
    mod: UNICODE_CMD,
    cmd: UNICODE_CMD,
    enter: UNICODE_ENTER,
    super: `${UNICODE_OPT}${UNICODE_CMD}`,
};
const PC_KEYS = {
    alt: "ALT",
    ctrl: "CTRL",
    opt: "ALT",
    shift: "SHIFT",
    mod: "CTRL",
    cmd: "CTRL",
    enter: UNICODE_ENTER,
    super: "CTRL+SHIFT",
};
function formatMac(segments) {
    const result = [];
    Object.entries(MAC_KEYS).forEach(([key, symbol]) => {
        if (segments.includes(key)) {
            result.push(symbol);
            pull_1(segments, key);
        }
    });
    result.push(...segments.map((s) => s.toUpperCase()));
    return result.join("");
}
function formatPC(segments) {
    const result = [];
    Object.entries(PC_KEYS).forEach(([key, symbol]) => {
        if (segments.includes(key)) {
            result.push(symbol);
            pull_1(segments, key);
        }
    });
    result.push(...segments.map((s) => s.toUpperCase()));
    return result.join("+");
}
function formatHotkey(shortcut) {
    const segments = shortcut.toLowerCase().split("+");
    if (isMac()) {
        return formatMac(segments);
    }
    else {
        return formatPC(segments);
    }
}

const TRIANGLE_WIDTH = 9;
const TRIANGLE_HEIGHT = 6;
const CALLOUT_HEIGHT = 28;
const BACKGROUND_COLOR = "#202020";
const $TriangleBase = styled.div `
  position: fixed;
  top: -1000px;
  left: -1000px;
  width: 0;
  height: 0;
  border-left: ${TRIANGLE_WIDTH / 2}px solid transparent; /* width/2 */
  border-right: ${TRIANGLE_WIDTH / 2}px solid transparent; /* width/2 */
`;
const $TopTriangle = styled($TriangleBase) `
  border-bottom: ${TRIANGLE_HEIGHT}px solid ${BACKGROUND_COLOR}; /* height */
`;
const $BottomTriangle = styled($TriangleBase) `
  border-top: ${TRIANGLE_HEIGHT}px solid ${BACKGROUND_COLOR}; /* height */
`;
const $Callout = styled.div `
  position: fixed;
  color: #e0e0e0;
  /* background: ${BACKGROUND_COLOR};
  background-image: */
  background: rgb(0, 0, 0);
  background: linear-gradient(
    335deg,
    rgba(0, 0, 0, 1) 0%,
    rgba(65, 65, 65, 1) 100%
  );

  box-shadow: 0 2px 3px rgba(0, 0, 0, 0.15);
  top: -1000px;
  left: -1000px;
  border-radius: 4px;
  padding: 0 0.75em;
  line-height: ${CALLOUT_HEIGHT}px;
  .label {
    font: 500 14px -apple-system, sans-serif;
  }
  .hotkey {
    margin-left: 0.5em;
    font-size: 12px;
  }
`;
function Callout({ dest, hotkey, label, className, }) {
    const tooltipRef = useRef(null);
    const modal = useInModal();
    /**
     * Easiest way I could find to make sure the callout is hidden when a user
     * click a button to open another Dialog.
     *
     * Even though technically that should be an `onMouseLeave` event, it
     * is not called.
     */
    useEffect(() => {
        document.body.addEventListener("click", modal.close);
        return () => {
            document.body.removeEventListener("click", modal.close);
        };
    });
    const { position, trianglePos, tooltipPos } = useReposition(() => {
        /* If tooltip doesn't exist yet set the position offscreen */
        if (!tooltipRef.current)
            return {
                trianglePos: { left: -1000, top: 0 },
                tooltipPos: { left: -1000, top: 0 },
            };
        const tooltipRect = tooltipRef.current.getBoundingClientRect();
        const destRect = dest.getBoundingClientRect();
        const { position, triangleRect, tooltipPos } = getPositions(destRect, tooltipRect);
        const fitTooltipPos = fitInViewport(tooltipPos, tooltipRect);
        return { position, trianglePos: triangleRect, tooltipPos: fitTooltipPos };
    }, [dest]);
    return (React.createElement(ResetContainer, null,
        position === Position.Above ? (React.createElement($BottomTriangle, { className: className, style: Object.assign({ zIndex: modal.zIndex }, trianglePos) })) : (React.createElement($TopTriangle, { className: className, style: Object.assign({ zIndex: modal.zIndex }, trianglePos) })),
        React.createElement($Callout, { ref: tooltipRef, style: Object.assign({ zIndex: modal.zIndex }, tooltipPos), className: className },
            React.createElement("span", { className: "label" }, label),
            hotkey ? React.createElement("span", { className: "hotkey" }, formatHotkey(hotkey)) : null)));
}
var Position;
(function (Position) {
    Position[Position["Above"] = 0] = "Above";
    Position[Position["Below"] = 1] = "Below";
})(Position || (Position = {}));
const TOP_OFFSET = 4;
const BOTTOM_OFFSET = 2;
function getPositions(destRect, tooltipRect) {
    const triangleLeft = destRect.left + destRect.width / 2 - TRIANGLE_WIDTH / 2;
    const tooltipLeft = destRect.left + destRect.width / 2 - tooltipRect.width / 2;
    if (destRect.top > CALLOUT_HEIGHT + TRIANGLE_HEIGHT) {
        return {
            position: Position.Above,
            triangleRect: {
                left: triangleLeft,
                top: destRect.top - TRIANGLE_HEIGHT - TOP_OFFSET,
            },
            tooltipPos: {
                left: tooltipLeft,
                top: destRect.top - TRIANGLE_HEIGHT - CALLOUT_HEIGHT - TOP_OFFSET,
            },
        };
    }
    else {
        return {
            position: Position.Below,
            triangleRect: {
                left: triangleLeft,
                top: destRect.bottom + BOTTOM_OFFSET,
            },
            tooltipPos: {
                left: tooltipLeft,
                top: destRect.bottom + TRIANGLE_HEIGHT + BOTTOM_OFFSET,
            },
        };
    }
}

function Tooltip({ children, hotkey, label, }) {
    const modal = useModal(ModalType.Tooltip);
    function openTooltip(e) {
        modal.open(Callout, { dest: e.currentTarget, hotkey, label });
    }
    function closeTooltip() {
        modal.close();
    }
    return React.cloneElement(children, {
        onMouseDown: (e) => {
            closeTooltip();
            children.props.onMouseDown(e);
        },
        onMouseMove: openTooltip,
        onMouseLeave: closeTooltip,
        onMouseUp: closeTooltip,
    });
}

const $LinkDialog = styled.div `
  position: absolute;
  /* Container style with background, border, radius, drop shadow */
  ${CONTAINER_STYLE}
  padding: 0.75em 0.75em 0.75em 2em;
  z-index: 1;
  width: 320px;
  color: #c0c0c0;
  ${unselectable}
  div.--globe-icon {
    position: absolute;
    color: #a0a0a0;
    font-size: 1em;
    left: 12px;
    top: 16px;
  }
  a {
    ${unselectable}
    color: #0366d6;
    font-size: 14px;
    line-height: 28px;
    display: inline-block;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 180px;
    text-decoration: none;
    &:hover {
      text-decoration: underline;
    }
  }
  line-height: 24px;
  div.--icons {
    font-size: 17px;
    position: absolute;
    top: 14px;
    right: 0.5em;
  }
  span.--icon {
    ${unselectable}
    display: inline-block;
    width: 28px;
    height: 28px;
    border-radius: 4px;
    background: rgba(0, 0, 0, 0.05);
    margin-left: 2px;
    color: #808080;
    text-align: center;
    cursor: pointer;
    padding-top: 5px;
    &:hover {
      color: #404040;
      background: #e0e0e0;
    }
  }
  /**
   * Fade in using 'useInitialClassName'
   */
  &.--initial {
    opacity: 0;
  }
  opacity: 1;
  transition: opacity linear 200ms;
`;
function LinkPopup({ element, linkRef, copy, }) {
    const modal = useModal(ModalType.Dialog);
    const editor = useSlateStatic();
    const [copied, setCopied] = useState(false);
    const className = useInitialClassName();
    /**
     * Copy the link URL to clipboard
     */
    const clickCopy = useCallback(() => {
        copy(element.url);
        setCopied(true);
        setTimeout(() => {
            setCopied(false);
        }, 1000);
    }, [element]);
    /**
     * Open the edit link dialog
     */
    const clickEdit = useCallback(() => {
        if (linkRef.current == null)
            return;
        modal.open(InsertLinkDialog, { dest: linkRef.current, editor });
    }, [element]);
    /**
     * Unlink the current link
     */
    const clickRemove = useCallback(() => {
        const linkInfo = getLinkInfo(editor);
        if (linkInfo.path != null) {
            Transforms.unwrapNodes(editor, { at: linkInfo.path });
            ReactEditor.focus(editor);
        }
    }, [element]);
    if (linkRef.current == null)
        return null;
    const rect = linkRef.current.getBoundingClientRect();
    /**
     * Set the `width` to 324px to give us a 4px margin over 320px on the right
     */
    const style = Object.assign(Object.assign({}, fitInViewport({ left: rect.left, top: rect.bottom + 4 + window.scrollY }, { width: 324 })), { 
        // Same z-index as Dialog.TOOLBAR
        zIndex: 10000 });
    return (React.createElement(Portal, null,
        React.createElement(Reset, null,
            React.createElement($LinkDialog, { style: style, className: className },
                React.createElement("div", { className: "--globe-icon" },
                    React.createElement(LinkIcon, null)),
                React.createElement(Tooltip, { label: "Open URL in new tab" },
                    React.createElement("a", { href: element.url, target: "_blank", rel: "noreferrer", onMouseDown: stopEvent }, element.url)),
                React.createElement("div", { className: "--icons" },
                    React.createElement(Tooltip, { label: "Copy URL to clipboard" },
                        React.createElement("span", { className: "--icon", onMouseDown: clickCopy }, copied == false ? React.createElement(ClipboardTextIcon, null) : React.createElement(CheckIcon, null))),
                    React.createElement(Tooltip, { label: "Edit link" },
                        React.createElement("span", { className: "--icon", onMouseDown: clickEdit },
                            React.createElement(PencilIcon, null))),
                    React.createElement(Tooltip, { label: "Unlink" },
                        React.createElement("span", { className: "--icon", onMouseDown: clickRemove },
                            React.createElement(LinkBreakIcon, null))))))));
}

/**
 * Link
 */
function Link({ attributes, children, element, }) {
    /**
     * Used for positioning the Dialog.
     */
    const linkRef = useRef(null);
    const editor = useSlateStatic();
    const selected = useSelected();
    const focused = useFocused();
    const highlighted = selected && focused;
    /**
     * We add an `isCopying` state because `copyToClipboard` requires a loss of
     * focus to start. When the loss of focus happens, `highlighted` is no
     * longer true and the `<LinkDialog>` will flicker.
     *
     * By setting `isCopying` to true during the copyToClipboard, we can make
     * sure that the `<LinkDialog>` stays visible.
     */
    const [isCopying, setIsCopying] = useState(false);
    const isPopupVisible = isCopying ||
        (highlighted && checkIsPopupVisible(editor, element, highlighted));
    const copy = useCallback(() => {
        setIsCopying(true);
        copyToClipboard(element.url);
        setTimeout(() => {
            setIsCopying(false);
        });
    }, []);
    return (React.createElement("a", Object.assign({}, attributes, { href: element.url, ref: linkRef }),
        isPopupVisible ? (React.createElement(LinkPopup, { linkRef: linkRef, element: element, copy: copy })) : null,
        children));
}
/**
 * Checks to see if the popup is visible.
 *
 * It is visible if the selection is fully inside of the element. If part of
 * the selection is outside, we don't show the popup.
 */
function checkIsPopupVisible(editor, element, highlighted) {
    if (!highlighted)
        return false;
    if (!editor.selection)
        return false;
    const elementPath = ReactEditor.findPath(editor, element);
    /**
     * This trickiness in the code is how we find whether the element range includes
     * the selection. A few notes:
     *
     * - `Range.includes` does not do what it sounds like. It returns true if there
     *   is an intersection.
     * - We compare the points of the start and end instead of the Range because
     *   the `Range.equals` method only returns true if the range is in the same
     *   direction. We don't care about the direction.
     */
    const elementRange = Editor.range(editor, elementPath);
    const intersection = Range.intersection(editor.selection, elementRange);
    if (!intersection)
        return false;
    return (Point.equals(Range.start(editor.selection), Range.start(intersection)) &&
        Point.equals(Range.end(editor.selection), Range.end(intersection)));
}

/**
 * Create indent styling for list items
 */
function getIndentStyle(element) {
    return { marginLeft: `${element.depth * 1.5}em` };
}
/**
 * Return className with `--is-editing` if we are in editing mode.
 */
function useListItemClassName(className) {
    const readOnly = useReadOnly();
    return cx(className, { "--is-editing": !readOnly });
}
/**
 * Task list item
 */
function TaskListItem({ attributes, element, children, }) {
    const editor = useSlateStatic();
    const className = useListItemClassName("--task");
    const style = getIndentStyle(element);
    const clickTaskListElement = useCallback(function clickTaskListElement(checked) {
        const path = ReactEditor.findPath(editor, element);
        Transforms.setNodes(editor, { checked }, { at: path });
    }, []);
    return (React.createElement("ul", Object.assign({}, attributes, { className: className, style: style }),
        React.createElement("li", null,
            React.createElement("span", { contentEditable: false }, element.checked ? (React.createElement(CheckedIcon, { onClick: () => clickTaskListElement(false), width: "1.25em", height: "1.25em" })) : (React.createElement(UncheckedIcon, { onClick: () => clickTaskListElement(true), width: "1.25em", height: "1.25em" }))),
            children)));
}
/**
 * Unordered list item
 */
function UnorderedListItem({ attributes, element, children, }) {
    const className = useListItemClassName("--unordered");
    const style = getIndentStyle(element);
    return (React.createElement("ul", Object.assign({}, attributes, { className: className, style: style }),
        React.createElement("li", null, children)));
}
/**
 * Ordered list item
 *
 * Note: Note the same as `UnorderedListItem` it has a `value` attribute.
 */
function OrderedListItem({ attributes, element, children, }) {
    const className = useListItemClassName("--ordered");
    const style = getIndentStyle(element);
    return (React.createElement("ol", Object.assign({}, attributes, { className: className, style: style }),
        React.createElement("li", { value: element.number }, children)));
}

/**
 * Generic Element where `tag` is passed in from `props.element.type`
 */
function Heading(props) {
    const level = props.element.level;
    const Tag = `h${level}`;
    const text = Node.string(props.element);
    return (React.createElement(Tag, Object.assign({}, props.attributes, { id: text }), props.children));
}
/**
 * Paragraph
 */
function Paragraph(props) {
    return React.createElement("p", Object.assign({}, props.attributes), props.children);
}

const TableContext = createContext({});
/**
 * Render `table` including context
 */
function Table({ attributes, children, element, }) {
    const initialClassName = useInitialClassName();
    const contextValue = useMemo(() => {
        return { columns: element.columns };
    }, [element.columns]);
    return (React.createElement(TableContext.Provider, { value: contextValue },
        React.createElement(SeamlessContainer, { attributes: attributes, element: element },
            React.createElement("table", { className: initialClassName },
                React.createElement("tbody", null, children)))));
}
/**
 * Render `tr`
 */
function Tr({ attributes, children }) {
    return React.createElement("tr", Object.assign({}, attributes), children);
}
/**
 * Render `td`
 */
function Td(props) {
    const { attributes, children, element } = props;
    const { columns } = useContext(TableContext);
    const align = columns[element.index].align;
    const style = { textAlign: align };
    return (React.createElement("td", Object.assign({}, attributes, { style: style }), children));
}

/**
 * `renderElement`
 */
function renderElement(props) {
    const { element } = props;
    switch (element.type) {
        /**
         * Simple
         */
        case "heading":
            return React.createElement(Heading, Object.assign({}, props, { element: element }));
        case "p":
            return React.createElement(Paragraph, Object.assign({}, props, { element: element }));
        /**
         * Inline Segments
         */
        case "link":
            return React.createElement(Link, Object.assign({}, props, { element: element }));
        /**
         * Block Quote
         */
        case "blockquote":
            return React.createElement(BlockQuote, Object.assign({}, props, { element: element }));
        /**
         * Code Block
         */
        case "code-block":
            return React.createElement(CodeBlock, Object.assign({}, props, { element: element }));
        case "code-line":
            return React.createElement(CodeLine, Object.assign({}, props, { element: element }));
        /**
         * Media
         */
        case "media":
            return React.createElement(Media, Object.assign({}, props, { element: element }));
        /**
         * Horizontal Rule
         */
        case "hr":
            return React.createElement(HorizontalRule, Object.assign({}, props, { element: element }));
        /**
         * List
         */
        case "unordered-list-item":
            return React.createElement(UnorderedListItem, Object.assign({}, props, { element: element }));
        case "ordered-list-item":
            return React.createElement(OrderedListItem, Object.assign({}, props, { element: element }));
        case "task-list-item":
            return React.createElement(TaskListItem, Object.assign({}, props, { element: element }));
        /**
         * Table
         */
        case "table":
            return React.createElement(Table, Object.assign({}, props, { element: element }));
        case "tr":
            return React.createElement(Tr, Object.assign({}, props, { element: element }));
        case "td":
            return React.createElement(Td, Object.assign({}, props, { element: element }));
        default:
            return assertUnreachable(element);
    }
}

/**
 * Styled Leaf with Syntax Highlighting classes.
 *
 * Note: We turn a Prism token of `comment` into className `token-comment`
 */
const $Leaf = styled.span `
  &.token-comment {
    span[data-slate-string] {
      color: slategray;
    }
  }
  &.token-operator,
  &.token-url {
    span[data-slate-string] {
      color: #9a6e3a;
    }
  }
  &.token-keyword {
    span[data-slate-string] {
      color: #07a;
    }
  }
  &.token-variable,
  &.token-regex {
    span[data-slate-string] {
      color: #e90;
    }
  }

  &.token-number,
  &.token-boolean,
  &.token-tag,
  &.token-constant,
  &.token-symbol,
  &.token-attr-name,
  &.token-selector {
    span[data-slate-string] {
      color: #905;
    }
  }

  &.token-punctuation {
    span[data-slate-string] {
      color: #999;
    }
  }

  &.token-string,
  &.token-char {
    span[data-slate-string] {
      color: #690;
    }
  }

  &.token-function,
  &.token-class-name {
    span[data-slate-string] {
      color: #dd4a68;
    }
  }
`;
/**
 * `renderLeaf`
 */
function renderLeaf(props) {
    const { attributes, leaf, children } = props;
    /**
     * Same as `leaf` but with the decorate mark types on it so they can be
     * extracted without TypeScript errors.
     *
     * We don't add this to `CustomText` because the types shouldn't be used
     * for manipulation or serialization as they only appear during rendering.
     */
    const decoratedLeaf = leaf;
    const className = cx({
        bold: leaf.bold,
        del: leaf.del,
        italic: leaf.italic,
        sup: leaf.sup,
        sub: leaf.sub,
        code: leaf.code,
    }, decoratedLeaf.token ? `token-${decoratedLeaf.token}` : "");
    /**
     * We only want to set the `spellCheck` attribute to `true` if we are in a
     * code segment. Otherwise, we want it `undefined`. This is because in a
     * `codeline` we set the entire element to `spellCheck=false`. If a leaf
     * is set to `spellCheck=true` it will override the `spellCheck` value from
     * the `codeline`
     */
    const spellCheck = leaf.code ? false : undefined;
    return (React.createElement($Leaf, Object.assign({}, attributes, { className: className, spellCheck: spellCheck }), children));
}

/**
 * Decorate Overview:
 *
 * We decorate the entire `code-block` at once because if we do it by line,
 * code that continues through multiple lines is not higlighted correctly.
 *
 * In order to higlight the entire `code-block` at once, we need to add a
 * newline to the end of each `code-line`. We cannot use `Node.string` on the
 * entire `code-block`.
 *
 * Once we receive the Prism tokens back, we need to create the ranges.
 *
 * The important part is that we track the offsets from the start. With the
 * offsets, we need to map those back to a `path` and `offset` of each
 * `code-line`. We also need to take into consideration that we have added
 * newlines to the end of each line so the algorithm needs to account for that.
 */
/**
 * Takes an array of text lines and returns an array with the offset
 * in characters of the start of each line.
 */
function getLineOffsets(lines) {
    let offset = 0;
    const lineOffsets = [];
    for (const line of lines) {
        lineOffsets.push(offset);
        offset = offset + line.length;
    }
    return lineOffsets;
}
/**
 * `decorate` method passed to `Editable`
 */
function decorate(nodeEntry) {
    const [node, path] = nodeEntry;
    if (!Element.isElement(node))
        return [];
    if (node.type !== "code-block")
        return [];
    const lang = Prism.languages[node.language];
    if (lang === undefined)
        return [];
    /**
     * To decorate a code-block, we need to look at all the code in a code-block.
     *
     * We can't `Node.string` the entire block because it will join lines
     * together without newlines.
     *
     * For this reason, we create an array of `textLines` which is the text of
     * each codeLine plus a newline on the end of it.
     *
     * Then we join all of those together to get the text that was pass into
     * Prism.
     *
     * We need to keep `textLines` around so that we can extract the
     * `linePositions`
     */
    const codeLineElements = node.children;
    const textLines = codeLineElements.map((node) => `${Node.string(node)}\n`);
    const text = textLines.join("");
    const lineOffsets = getLineOffsets(textLines);
    /**
     * Takes a character offset from the beginning of the `code-block` and
     * returns the `path` to the `code-line` and the `offset` within the
     * `code-line` which Slate needs to make the decoration.
     */
    function getPointFromOffset(offset) {
        for (let i = lineOffsets.length; i >= 0; i--) {
            const lineOffset = lineOffsets[i];
            if (lineOffset <= offset) {
                return {
                    path: [...path, i],
                    offset: offset - lineOffset,
                };
            }
        }
        throw new Error("This shouldn't happen and indicates a bug in the logic");
    }
    const ranges = [];
    const tokens = Prism.tokenize(text, lang);
    /**
     * Track current character offset from beginning of `textLines` joined
     * together.
     */
    let offset = 0;
    /**
     * Tokens are either:
     *
     * - string: which means it is not syntax highlighted
     * - { type: string, content: string, length: number }: the highlight and content
     */
    for (const token of tokens) {
        if (typeof token === "string") {
            offset += token.length;
        }
        else {
            const anchor = getPointFromOffset(offset);
            const focus = getPointFromOffset(offset + token.length);
            ranges.push({
                anchor,
                focus,
                token: token.type,
            });
            offset += token.length;
        }
    }
    return ranges;
}

const blockQuoteCss = css `
  /**
   * Blockquote
   */

  blockquote {
    &::before {
      background: ${colors.blockquoteBar};
      position: absolute;
      left: 0;
      width: 0.25em;
      top: 0.75em;
      bottom: 0.75em;
      border-radius: 0.125em;
      content: "";
    }
    /* border-left: 0.25em solid #ececec; */
    padding: 1.5em 0 1.5em 1.75em;
    position: relative;
  }
`;

const codeCss = css `
  pre {
    background: #f4f6f8;
    border-radius: ${colors.borderRadius};
    font-family: "menlo", monospace;
    font-size: 0.85em;
    padding: 1em 1.25em;
    white-space: pre;

    ${horizontalScrollbar({
    height: 16,
    thumbColor: "rgba(0,0,0,0.05)",
    borderColor: "#e0e0e0",
    backgroundColor: "rgba(0,0,0,0.02)",
})}

    @media print {
      color: black;
      background: white;
      border-color: black;
    }
  }
`;

const flushCss = css `
  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    line-height: 1.2;
    padding-bottom: 0.25em;
  }
  h1 {
    font-size: 2em;
    font-weight: 600;
    line-height: 1.1;
  }
  h2 {
    font-size: 1.6em;
    font-weight: 600;
  }
  h3 {
    font-size: 1.36em;
    font-weight: 600;
  }
  h4 {
    font-size: 1.22em;
    font-weight: 600;
  }
  h5 {
    font-size: 1.13em;
    font-weight: 600;
  }
  h6 {
    font-size: 1em;
    font-weight: 600;
  }

  p {
    color: #202020;
    font-size: 1em;
  }

  /*
   * Flush Margins
   *
   * We only want spaces between headings if the heading is not at the top of
   * the document. This is because we don't want a gap at the top of the
   * document if the first element is a heading.
   */

  * + h1,
  * + h2,
  * + h3 {
    /* padding-top: 0.5em;
    padding-bottom: 0.5em; */
    padding: 0.5em 0 0.25em;
    /* margin-top: 1em; */
  }
  * + h4,
  * + h5,
  * + h6 {
    padding: 1em 0 0.25em;
    /* margin-top: 1.5em; */
  }
  * + p {
    /* margin-top: 1em; */
    padding: 0.5em 0;
  }
  h4 + p,
  h5 + p,
  h6 + p {
    /* margin-top: 0.5em; */
  }
`;

const LINE_COLOR = "#e0e0e0";
const hrCss = css `
  /**
   * Horizontal Rule
   */

  hr {
    border: none;
    height: 1px;
    background: ${LINE_COLOR};
  }
`;

const linkCss = css `
  /**
   * The "*" is needed to override the "*" in "styled-editable.ts"
   */
  a * {
    color: #0366d6;
    text-decoration: underline;
  }
`;

const listCss = css `
  ul,
  ol {
    padding-left: 16px;
  }
  li {
    display: list-item;
    position: relative;
    padding-left: 0.25em;
    margin-top: 0.5em;
    margin-bottom: 0.5em;
    margin-left: 1em;
  }
  /**
   * Ordered List
   */
  ol li {
    list-style: decimal outside;
  }
  /**
   * Bulleted list
   */
  ul.--unordered li {
    list-style-type: disc;
  }
  /**
   * Task List
   */
  ul.--task li {
    /**
     * We don't want a bullet or numbers so we specify this as none
     */
    list-style-type: none;

    /**
     * Checkbox
     *
     * Position the checkbox
     */

    svg {
      cursor: pointer;
      position: absolute;
      top: 2px;
      left: -1.25em;
    }

    &.--is-editing {
      .fa {
        cursor: pointer;
      }
      /**
       * TODO: Get hover styles on checkbox working.
       *
       * These hover styled don't work and it's related to the "*" selector
       * from above or the fact that we are using svg now and :hover doesn't
       * work with it. Not sure but it would be nice to have these working.
       *
       * We can also use mouse event handlers to do this if required.
       */
      /**
      .fa-check-square * {
        &:hover * {
          color: #0060e0;
        }
      }
      .fa-square * {
        &:hover * {
          color: #808080;
        }
      }
      */
    }
  }

  p + ol,
  h1 + ol,
  h2 + ol,
  h3 + ol,
  h4 + ol,
  h5 + ol,
  h6 + ol,
  p + ul,
  h1 + ul,
  h2 + ul,
  h3 + ul,
  h4 + ul,
  h5 + ul,
  h6 + ul {
    margin-top: 1.25rem;
  }
`;

const markCss = css `
  /* Code */

  span.code {
    padding: 0.4em 0.2em;
    color: #404040;
    background: #f0f2f4;
    font-family: monospace;
    font-size: 0.85em;
    border-radius: 0.5em;
  }

  /* Bold */

  span.bold {
    /**
     * Look better in San Francisco at 600 instead of bold.
     * Fonts without 600 (semi-bold) should fallback to bold.
     */
    font-weight: bold;
    font-weight: 600;
    color: black;
  }

  /* Italic */

  span.italic {
    font-style: italic;
  }

  /* Strikeout */

  span.del {
    text-decoration: line-through;
  }

  /* Superscript */

  span.sup {
    vertical-align: super;
    font-size: 0.75em;
  }

  /* Subscript */

  span.sub {
    vertical-align: sub;
    font-size: 0.75em;
  }

  /*
   * Bold in heading should render extra bold
   */

  h1 .bold,
  h2 .bold,
  h3 .bold,
  h4 .bold,
  h5 .bold,
  h6 .bold {
    font-weight: 800;
  }
`;

const mediaCss = css `
  /* It's inside 'render/render-element/image/styles now' */
`;

const tableCss = css `
  /**
   * Table
   */

  table {
    padding: 1em 0;
    display: block;
    overflow-x: auto;
    border-collapse: separate;

    /**
     * Fade in animation for tables
     */
    &.--initial {
      opacity: 0;
    }
    opacity: 1;
    transition: opacity linear 200ms;

    /**
     * First row of Table
     */

    tr:first-of-type td {
      background: ${colors.tableHeadBackgroundColor};
    }

    tr:first-of-type td:first-of-type {
      border-top-left-radius: ${colors.borderRadius};
    }
    tr:first-of-type td:last-of-type {
      border-top-right-radius: ${colors.borderRadius};
    }
    tr:last-of-type td:first-of-type {
      border-bottom-left-radius: ${colors.borderRadius};
    }
    tr:last-of-type td:last-of-type {
      border-bottom-right-radius: ${colors.borderRadius};
    }
    td:last-of-type {
      border-right: 1px solid ${colors.tableBorderColor};
    }
    tr:last-of-type td {
      border-bottom: 1px solid ${colors.tableBorderColor};
    }

    /**
     * Table cells
     */

    td {
      padding: 0.5em 1em;
      border-left: 1px solid ${colors.tableBorderColor};
      border-top: 1px solid ${colors.tableBorderColor};
      min-width: 6em;
      @media print {
        border: 1px solid black;
      }
    }
  }
`;

const $Editable = styled(Editable) `
  color: #101010;
  background: #ffffff;

  /**
   * Reflects the border radius around the editor
   */
  border-radius: ${colors.editorBorderRadius};

  /**
   * This allows us to win the selector when the target of a selector outside
   * of Wysimark is of the innermost element. We may have more selector
   * specificity, but the inner most selector will be the displayed style.
   */
  * {
    color: #101010;
  }

  /**
   * Fade in effect. "--initial-editor-content" is set very quickly on first
   * load to allow animation to happen.
   */

  opacity: 1;
  transition: opacity 1s;
  .--initial-editor-content & {
    opacity: 0;
  }

  /**
   * Padding around content area
   */

  padding: 1em 1.5em;

  /**
   * IMPORTANT!
   *
   * This provides important flex styling related to its parent container
   * "editor-with-toolbar.tsx".
   *
   * See that file on why this is necessary.
   */

  flex: 1 1 auto;
  overflow-y: auto;

  /* On iPhone, it doesn't use the full width and the toolbar doesn't size
   * correctly above it so we have to add this. May have something to do with
   * the fact it is in a flex container. Works fine in Chrome without it.
   */

  width: 100%;

  /**
   * Default font size
   */

  font-size: 16px;

  /**
   * Default line height
   */

  line-height: 1.5;

  /**
   * Imported CSS styles in alphabetical order
   */

  ${blockQuoteCss}
  ${codeCss}
  ${flushCss}
  ${hrCss}
  ${linkCss}
  ${listCss}
  ${markCss}
  ${mediaCss}
  ${tableCss}
`;

/**
 * Returns an `Editable` customized with:
 *
 * - Emotion styling
 * - Event handlers
 * - Renderers
 */
function CustomEditable({ "data-cy": dataCy, readOnly, className: classNameProp, onBlur, }) {
    const editor = useSlate();
    /**
     * Adding these props to `editor` makes them available wherever `editor` is
     * available. This won't affect or cause any renders if the value changes
     * here.
     *
     * That gets handled by the `onRenderElement` and `onRenderLeaf` methods.
     */
    editor.modalDialog = useModal(ModalType.Dialog);
    // TODO: iPhone may require useLockBodyScroll
    // if (isAppleIphone()) {
    //   useLockBodyScroll(!readOnly)
    // }
    /**
     * toggle className for focus outline
     */
    const className = cx(classNameProp, {
        "--focus": ReactEditor.isFocused(editor),
    });
    /**
     * onKeyDown with Editor
     */
    const onBoundKeyDown = useCallback((e) => onKeyDown(e, editor), [editor]);
    /**
     * onPaste with Editor
     */
    const onBoundPaste = useCallback((e) => onPaste(e, editor), [editor]);
    /**
     * onDrop with Editor
     */
    const onBoundDrop = useCallback((e) => onDrop(e, editor), [editor]);
    /**
     * onSelect with Editor
     */
    const onSelect = useCallback(() => {
        /**
         * Set the `lastSelection` property on the `Editor` object.
         *
         * The property is used in the toolbar/modals when there is a loss of
         * focus from the `Editor`. We need to reselect the previously held
         * selection so we know what to apply the command to.
         */
        if (editor.selection) {
            editor.lastSelection = editor.selection;
        }
    }, [editor]);
    /**
     * HELP:
     *
     * If we don't provide `spellCheck`, `autoCorrect` and `autoCapitalize` and
     * set their value to the string "false" (although spellCheck can be set to
     * the boolean value `false` for some reason), we get this warning:
     *
     * ```
     * react-dom.development.js?a814:67 Warning: Extra attributes from the server: spellcheck,autocorrect,autocapitalize
     * ```
     *
     * The closest relevant Slate code is here
     * https://github.com/ianstormtaylor/slate/blob/f40e515dc7f956b7fd859688c0170f2c1763fecf/packages/slate-react/src/components/editable.tsx
     *
     * But it may also be a Next.js issue
     * https://www.google.com/search?q=nextjs+extra+attributes+spellcheck
     */
    return (React.createElement($Editable, { spellCheck: "false", autoCorrect: "false", autoCapitalize: "false", className: className, "data-cy": dataCy, decorate: decorate, readOnly: readOnly, renderElement: renderElement, renderLeaf: renderLeaf, onKeyDown: onBoundKeyDown, onPaste: onBoundPaste, onDrop: onBoundDrop, onSelect: onSelect, onBlur: onBlur }));
}

/**
 * Insert image dialog
 *
 */
function InsertImageDialog({ dest, editor, }) {
    function onChange(e) {
        return __awaiter(this, void 0, void 0, function* () {
            if (e.target.files == null || e.target.files.length === 0)
                return;
            editor.upload(e.target.files);
        });
    }
    return (React.createElement(Dialog, { title: "Insert image", dest: dest, width: 320 },
        React.createElement(Form$1.Block, { label: "Select image file to upload", hint: "Works with .gif, .jpg/.jpeg and .png" },
            React.createElement(Form$1.File, { onChange: onChange },
                React.createElement("i", { className: "fa fa-upload" }),
                " Upload Image"))));
}

/**
 * Styled Components
 */
const $Menu = styled(Container$1) `
  display: block;
  margin-top: 0;
  color: rgba(0, 0, 0, 0.75);
  padding: 4px 0;
  text-align: left;
  list-style: none;
  max-width: 640px;
  @media (max-width: 767px) {
    font-size: 20px;
    font-weight: 400;
    border-radius: 0.5rem;
  }
  @media (min-width: 768px) {
    font-size: 1rem;
    border-radius: 4px;
  }
`;
const $Item = styled.div `
  cursor: pointer;
  font: 400 18px/25px -apple-system, sans-serif;
  display: flex;
  padding: 0 1em 0 0.25em;
  color: #404040;
  svg {
    display: block;
    flex: 0 0 auto;
    margin-top: 3px;
    width: 18px;
    height: 18px;
    margin-right: 12px;
    &.--check {
      color: rgba(0, 0, 0, 0);
      width: 16px;
      margin-right: 4px;
    }
  }
  div.text {
    flex: 1 1 auto;
    padding-right: 2em;
    font-size: 14px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  div.shortcut {
    font-size: 12px;
    line-height: 25px;
  }
  &.--selected {
    background: #f0f0f0;
  }
  &.--active {
    svg.--check {
      color: #00a000;
    }
  }
  &:active {
    color: black; /* Bootstrap flickers to white. This overrides it. */
  }
  &:hover {
    color: black;
    background-color: rgba(0, 0, 0, 0.05);
  }
`;
/**
 * Menu Item
 */
function Item({ SvgIcon, iconProps, active = false, hotkey, children, onClick, onMouseDown, danger, muted, }) {
    const modal = useInModal();
    useHotkey("escape", () => modal.close(), [modal]);
    const className = cx("dropdown-item", { "--active": active });
    const textClassName = cx("text", {
        "text-danger": danger,
        "text-muted": muted,
    });
    function clickItem(e) {
        modal.close();
        if (onClick) {
            onClick(e);
        }
    }
    return (React.createElement($Item, { className: className, onClick: clickItem, onMouseDown: onMouseDown },
        React.createElement(CheckIcon$1, { className: "--check" }),
        SvgIcon ? React.createElement(SvgIcon, Object.assign({}, iconProps)) : null,
        React.createElement("div", { className: textClassName }, children),
        hotkey ? React.createElement("div", { className: "shortcut" }, formatHotkey(hotkey)) : null));
}
/**
 * Menu Heading
 */
const $Heading = styled.div `
  cursor: default;
  font-family: sans-serif;
  font-size: 13px;
  padding: 8px 16px 4px 16px;
  color: #808080;
`;
/**
 * Menu Divider
 */
const $Divider = styled.div `
  margin: 0.15em 0;
  border-bottom: 1px solid rgba(0, 0, 0, 0.075);
`;
/**
 * Menu Container
 */
function Menu({ children, dest, position = Position$1.Below, }) {
    const ref = useRef();
    const style = useContainerReposition({ dest, ref, position });
    const initial = useInitial();
    const className = cx({ "--initial": initial, "--not-initial": !initial });
    return (React.createElement(ResetContainer, null,
        React.createElement(Mask, null,
            React.createElement($Menu, { ref: ref, style: style, className: className }, children))));
}
Menu.Item = Item;
Menu.Heading = $Heading;
Menu.Divider = $Divider;

function ToolbarMenu({ children, // use this to pass in a header at top of Menu
items, dest, editor, toolbarState, }) {
    const modal = useInModal();
    return (React.createElement(Menu, { dest: dest },
        children,
        items.map((item, index) => {
            if (isCommand(item)) {
                // const { faIcon, label, hotkey, action } = item
                const active = item.isActive ? item.isActive(toolbarState) : false;
                const action = item.action;
                const onMouseDown = () => {
                    /**
                     * close modal first as call to `action` might open a new modal.
                     * We don't want to close the one that's supposed to be opened.
                     */
                    modal.close();
                    reselect(editor);
                    action({ editor, dest, modal, toolbarState });
                    setTimeout(() => {
                        ReactEditor.focus(editor);
                    }, 0);
                };
                return (React.createElement(Menu.Item, { key: item.label, SvgIcon: item.SvgIcon, iconProps: item.iconProps, hotkey: item.hotkey, onMouseDown: onMouseDown, active: active }, item.label));
            }
            else {
                return React.createElement(Menu.Divider, { key: index });
            }
        })));
}

const TableCommands = [
    { divider: true },
    {
        SvgIcon: ArrowLineUpIcon,
        label: "Insert row above",
        hotkey: "mod+shift+enter",
        action({ editor }) {
            Table$1.insertRow(editor, 0);
        },
    },
    {
        SvgIcon: ArrowLineUpIcon,
        iconProps: { transform: "rotate(180)" },
        label: "Insert row below",
        hotkey: "mod+enter",
        action({ editor }) {
            Table$1.insertRow(editor, 1);
        },
    },
    { divider: true },
    {
        SvgIcon: ArrowLineUpIcon,
        iconProps: { transform: "rotate(270)" },
        label: "Insert column left",
        // hotkey: "super+[",
        action({ editor }) {
            Table$1.insertColumn(editor, 0);
        },
    },
    {
        SvgIcon: ArrowLineUpIcon,
        iconProps: { transform: "rotate(90)" },
        label: "Insert column right",
        // hotkey: "super+]",
        action({ editor }) {
            Table$1.insertColumn(editor, 1);
        },
    },
    { divider: true },
    {
        SvgIcon: AlignLeftIcon,
        label: "Align Column Left",
        action({ editor }) {
            Table$1.setColumnAlign(editor, "left");
        },
    },
    {
        SvgIcon: AlignCenterIcon,
        label: "Align Column Center",
        action({ editor }) {
            Table$1.setColumnAlign(editor, "center");
        },
    },
    {
        SvgIcon: AlignRightIcon,
        label: "Align Column Right",
        action({ editor }) {
            Table$1.setColumnAlign(editor, "right");
        },
    },
    { divider: true },
    {
        SvgIcon: TrashIcon,
        label: "Delete row",
        // hotkey: "mod+.",
        action({ editor }) {
            Table$1.removeRow(editor);
        },
    },
    {
        SvgIcon: TrashIcon,
        label: "Delete column",
        // hotkey: "mod+shift+.",
        action({ editor }) {
            Table$1.removeColumn(editor);
        },
    },
    {
        SvgIcon: TrashIcon,
        label: "Delete Table",
        action({ editor }) {
            Table$1.removeTable(editor);
        },
    },
];
const $Grid = styled.div `
  &.-wysimark-table-grid {
    padding: 0.5em 0.75em;
    .__title {
      font: 400 14px/25px -apple-system, sans-serif;
    }
    table {
      width: 100%;
      border-collapse: separate;
      border-spacing: 2px;
      td {
        height: 1.5em;
        border: 1px solid #c0c0c0;
        &.selected {
          background: #e9f0ff;
          border: 1px solid #68a0d8;
        }
      }
    }
  }
`;
function SelectTableSizeGrid({ cols, rows, editor, }) {
    const modal = useInModal();
    const [pos, setPos] = useState(null);
    function onInsertTable(e, colCount, rowCount) {
        stopEvent(e);
        Table$1.insertTable(editor, { rowCount, colCount });
        modal.close();
    }
    return (React.createElement($Grid, { className: "-wysimark-table-grid" },
        React.createElement("div", { className: "__title" }, pos == null ? "Insert table" : `${pos[0]}x${pos[1]} table`),
        React.createElement("table", { onMouseLeave: () => setPos(null), unselectable: "on" },
            React.createElement("tbody", null, range_1(1, rows + 1).map((row) => (React.createElement("tr", { key: row }, range_1(1, cols + 1).map((col) => {
                const isSelected = pos != null && col <= pos[0] && row <= pos[1];
                return (React.createElement("td", { key: col, className: isSelected ? "selected" : undefined, onMouseDown: (e) => onInsertTable(e, col, row), onMouseEnter: () => setPos([col, row]) }));
            }))))))));
}
function TableMenu({ editor, dest, toolbarState, }) {
    return (React.createElement(ToolbarMenu, { editor: editor, dest: dest, items: TableCommands, toolbarState: toolbarState },
        React.createElement(SelectTableSizeGrid, { editor: editor, cols: 6, rows: 3 })));
}

function isCommand(item) {
    return item.divider == null;
}
const SIMPLE_COMMANDS = [
    {
        SvgIcon: H1Icon,
        label: "Heading 1",
        hotkey: "super+1",
        action({ editor }) {
            toggleHeading(editor, 1);
        },
        isActive(state) {
            return (isElementByType(state.block, "heading") &&
                state.block.level === 1);
        },
    },
    {
        SvgIcon: H2Icon,
        label: "Heading 2",
        hotkey: "super+2",
        action({ editor }) {
            toggleHeading(editor, 2);
        },
        isActive(state) {
            return (isElementByType(state.block, "heading") &&
                state.block.level === 2);
        },
    },
    {
        SvgIcon: H3Icon,
        label: "Heading 3",
        hotkey: "super+3",
        action({ editor }) {
            toggleHeading(editor, 3);
        },
        isActive(state) {
            return (isElementByType(state.block, "heading") &&
                state.block.level === 3);
        },
    },
    // {
    //   faIcon: faParagraph,
    //   label: "Normal",
    //   hotkey: "super+0",
    //   action({ editor }) {
    //     Custom.setParagraph(editor)
    //   },
    //   isActive(state) {
    //     return isElementByType(state.block, "p")
    //   },
    // },
];
const MORE_MARK_COMMANDS = [
    {
        SvgIcon: CodeIcon,
        label: "Code",
        hotkey: "super+c",
        action({ editor }) {
            toggleMark(editor, "code", true);
        },
        isActive(state) {
            return !!state.marks.code;
        },
    },
    {
        SvgIcon: SuperscriptIcon,
        label: "Superscript",
        hotkey: "super+p",
        action({ editor }) {
            toggleMark(editor, "sup", true);
        },
        isActive(state) {
            return !!state.marks.sup;
        },
    },
    {
        SvgIcon: SubscriptIcon,
        label: "Subscript",
        hotkey: "super+b",
        action({ editor }) {
            toggleMark(editor, "sub", true);
        },
        isActive(state) {
            return !!state.marks.sub;
        },
    },
    {
        // faIcon: faStrikethrough,
        SvgIcon: StrikeIcon,
        label: "Strikethrough",
        hotkey: "super+x",
        action({ editor }) {
            toggleMark(editor, "del", true);
        },
        isActive(state) {
            return !!state.marks.del;
        },
    },
    {
        SvgIcon: XCircleIcon,
        label: "Remove Formatting",
        // hotkey: "mod+d",
        action({ editor }) {
            removeAllMarks(editor);
        },
    },
];
const MARK_COMMANDS = [
    {
        SvgIcon: BoldIcon,
        label: "Bold",
        hotkey: "mod+b",
        action({ editor }) {
            toggleMark(editor, "bold", true);
        },
        isActive(state) {
            return !!state.marks.bold;
        },
    },
    {
        SvgIcon: ItalicIcon,
        label: "Italic",
        hotkey: "mod+i",
        action({ editor }) {
            toggleMark(editor, "italic", true);
        },
        isActive(state) {
            return !!state.marks.italic;
        },
    },
    {
        SvgIcon: EllipsisIcon,
        label: "More inline styles",
        dropdown: true,
        action({ editor, modal, dest, toolbarState }) {
            modal.open(ToolbarMenu, {
                items: MORE_MARK_COMMANDS,
                editor,
                dest,
                toolbarState,
            });
        },
    },
];
const LIST_COMMANDS = [
    {
        SvgIcon: UnorderedListIcon,
        label: "Bulleted list",
        hotkey: "super+8",
        action({ editor }) {
            toggleListItem(editor, "unordered-list-item");
        },
        isActive(state) {
            return isElementByType(state.block, "unordered-list-item");
        },
    },
    {
        SvgIcon: OrderedListIcon,
        label: "Numbered list",
        hotkey: "super+7",
        action({ editor }) {
            toggleListItem(editor, "ordered-list-item");
        },
        isActive(state) {
            return isElementByType(state.block, "ordered-list-item");
        },
    },
    {
        SvgIcon: ChecklistIcon,
        label: "Task list",
        hotkey: "super+9",
        action({ editor }) {
            toggleListItem(editor, "task-list-item");
        },
        isActive(state) {
            return isElementByType(state.block, "task-list-item");
        },
    },
    { divider: true },
    {
        SvgIcon: IndentIcon,
        label: "Indent list",
        hotkey: "tab",
        action({ editor }) {
            tabInList(editor, 1);
        },
    },
    {
        SvgIcon: OutdentIcon,
        label: "Outdent list",
        hotkey: "shift+tab",
        action({ editor }) {
            tabInList(editor, -1);
        },
    },
];
const CODE_BLOCK_COMMANDS = [
    {
        SvgIcon: PlainTextIcon,
        label: "Plain text",
        action({ editor }) {
            insertCodeBlock(editor, "text");
        },
    },
    {
        SvgIcon: HtmlIcon,
        label: "HTML",
        action({ editor }) {
            insertCodeBlock(editor, "html");
        },
    },
    {
        SvgIcon: CssIcon,
        label: "CSS",
        action({ editor }) {
            insertCodeBlock(editor, "css");
        },
    },
    {
        SvgIcon: JsIcon,
        label: "Javascript",
        action({ editor }) {
            insertCodeBlock(editor, "js");
        },
    },
    {
        SvgIcon: FileCodeIcon,
        label: "Java, C, C++",
        action({ editor }) {
            insertCodeBlock(editor, "clike");
        },
    },
];
const PLUS_COMMANDS = [
    {
        SvgIcon: PlusIcon,
        label: "Insert special type",
        dropdown: true,
        action({ editor, modal, dest, toolbarState }) {
            modal.open(ToolbarMenu, {
                items: INSERT_COMMANDS,
                editor,
                modal,
                dest,
                toolbarState,
            });
        },
    },
];
const BLOCKQUOTE_COMMANDS = [
    {
        SvgIcon: BlockquoteIndentIcon,
        label: "Add Block Quote to selected blocks",
        action({ editor }) {
            blockquote(editor);
        },
    },
    {
        SvgIcon: BlockquoteOutdentIcon,
        label: "Remove Block Quote at current selection",
        action({ editor }) {
            unblockquote(editor);
        },
    },
];
const INSERT_COMMANDS = [
    {
        SvgIcon: LinkIcon,
        label: "Insert link",
        hint: "Hint: Paste URL in editor",
        dropdown: true,
        action({ editor, modal, dest }) {
            modal.open(InsertLinkDialog, { editor, dest });
        },
        isActive(state) {
            return state.inLink;
        },
    },
    {
        SvgIcon: HrIcon,
        label: "Insert Horizontal Rule",
        hint: "Hint: type --- then hit enter",
        action({ editor }) {
            insertHorizontalRule(editor);
        },
    },
    {
        SvgIcon: QuoteIcon,
        label: "Block Quote",
        dropdown: true,
        action({ editor, modal, dest, toolbarState }) {
            modal.open(ToolbarMenu, {
                items: BLOCKQUOTE_COMMANDS,
                editor,
                modal,
                dest,
                toolbarState,
            });
        },
        isActive(state) {
            return state.inBlockQuote;
        },
    },
    {
        SvgIcon: UnorderedListIcon,
        label: "Open list and task menu",
        dropdown: true,
        action({ editor, modal, dest, toolbarState }) {
            modal.open(ToolbarMenu, {
                items: LIST_COMMANDS,
                editor,
                modal,
                dest,
                toolbarState,
            });
        },
        isActive(state) {
            return state.block ? isListItemElement(state.block) : false;
        },
    },
    {
        SvgIcon: TableIcon,
        label: "Insert and modify table",
        hint: "Insert and remove columns and rows in table",
        dropdown: true,
        action({ editor, modal, dest, toolbarState }) {
            modal.open(TableMenu, { editor, modal, dest, toolbarState });
        },
        isActive(state) {
            return isElementByType(state.block, "td");
        },
    },
    {
        SvgIcon: CodeIcon,
        label: "Insert code block",
        hint: "Hint: click to see shortcuts to insert code block",
        dropdown: true,
        action({ editor, modal, dest, toolbarState }) {
            modal.open(ToolbarMenu, {
                items: CODE_BLOCK_COMMANDS,
                editor,
                modal,
                dest,
                toolbarState,
            });
        },
        isActive(state) {
            return isElementByType(state.block, "code-line");
        },
    },
    {
        id: "insert-file",
        SvgIcon: ImageIcon,
        label: "Insert image or file",
        hint: "Hint: Upload image or file in editor",
        dropdown: true,
        action({ editor, modal, dest }) {
            modal.open(InsertImageDialog, {
                editor,
                dest,
            });
        },
    },
];

/**
 * Returns useful information about the current state of the editor that the
 * toolbar needs to display its state properly.
 *
 * For example, `bold`, `italic`, whether it's in a `p` or a `heading`, etc.
 */
function getToolbarState(editor) {
    if (editor.selection == null) {
        return { marks: {}, block: null, inBlockQuote: false, inLink: false };
    }
    const upwardNodes = getUpwardNodesFromEditor(editor, editor.selection);
    const marks = extractMarks(editor, upwardNodes);
    const [inLink, inBlockQuote, block] = getStateFromElements(editor, upwardNodes);
    return { block, inLink, inBlockQuote, marks };
}
/**
 * Returns an array of nodes starting from the current selection focus up to
 * the `Editor` object.
 *
 * The first node will be a Text leaf.
 *
 * The last node will be the Editor object.
 */
function getUpwardNodesFromEditor(editor, selection) {
    const nodes = Array.from(Node.levels(editor, selection.focus.path, { reverse: true })).map(([node]) => node);
    return nodes;
}
/**
 * Extract marks from nodes
 */
function extractMarks(editor, upwardNodes) {
    /**
     * If `editor.marks` is an object on the editor, it reflects the
     * marks that will be added to any inserted text.
     *
     * If it is `null`, then it uses the `marks` that are part of the `Text` leaf
     * that it is currently in.
     */
    if (editor.marks) {
        return editor.marks;
    }
    /**
     * If there are no upward Nodes (i.e. there is no selection) then there are
     * no marks.
     */
    if (upwardNodes.length === 0) {
        return {};
    }
    /**
     * First node is always the leaf Node.
     */
    const leafNode = upwardNodes[0];
    /**
     * Extract the marks from that leaf node
     */
    if (Text.isText(leafNode)) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const marks = __rest(leafNode, ["text"]);
        return marks;
    }
    else {
        /**
         * Log `upwardNodes` so we get useful debugging information on failure.
         *
         * NOTE:
         *
         * Getting to this code indicates that somewhere we placed the selection
         * such that we weren't selecting inside the Text node but rather inside
         * an Element node.
         *
         * We can usually fix this by using `Editor.start` or `Editor.end` with
         * the given node to place the seleciton into a valid location.
         *
         * WARNING:
         *
         * You may be tempted to return `{}` and be done with it but that is
         * inviting the use of invalid states and will eventually bite you back.
         */
        console.log("upwardNodes", upwardNodes);
        throw new Error(`This shouldn't happen because the first node should always be a leaf node.`);
    }
}
/**
 * Extract toolbar state from nodes
 */
function getStateFromElements(editor, upwardNodes) {
    let inLink = false;
    let inBlockQuote = false;
    let firstBlock = null;
    for (const node of upwardNodes) {
        /**
         * If it's not an Element, don't worry about it
         */
        if (!Element.isElement(node)) {
            continue;
        }
        if (node.type === "link") {
            inLink = true;
            continue;
        }
        if (isBlockElement(node)) {
            if (firstBlock == null) {
                firstBlock = node;
            }
            else {
                if (node.type === "blockquote") {
                    inBlockQuote = true;
                    break;
                }
            }
        }
    }
    return [inLink, inBlockQuote, firstBlock];
}

const $Toolbar = styled.div `
  position: sticky;
  top: 0;
  z-index: 1;
  user-select: none;
  flex: 0 0 auto;
  border-top-left-radius: ${colors.editorBorderRadius};
  border-top-right-radius: ${colors.editorBorderRadius};
  background: ${colors.toolbarBackgroundColor};
  border-bottom: 1px solid ${colors.editorBorderColor};
  .--initial-editor-content & {
    opacity: 0;
  }
  opacity: 1;
  overflow-y: hidden;
  transition: opacity 1s, height ease 1s, margin-bottom ease 1s;
  .--focused & {
    box-shadow: 0 1.5px 3px rgba(0, 0, 0, 0.05);
    background: #f4f4f4;
  }
`;
const $ButtonGroup = styled.div `
  @media (max-width: 767px) {
    &.--desktop-only {
      display: none;
    }
  }
  @media (min-width: 768px) {
    &.--mobile-only {
      display: none;
    }
  }
  display: inline-block;
  height: 40px;
  border-right: 1px solid ${colors.editorBorderColor};
  padding: 0 8px;
`;
const $IconButtons = styled.div `
  /* flex item */
  flex: 0 1 auto;
`;
const $IconButton = styled.div `
  display: inline-block;
  cursor: pointer;
  width: 32px;
  height: 40px;
  line-height: 40px;
  text-align: center;
  color: ${colors.toolbarIconColor};
  font-size: 18px;
  svg {
    position: relative;
    top: 2px;
    width: 1em;
    height: 1em;
  }
  transition: color 150ms, background 150ms;
  background: linear-gradient(
    335deg,
    rgba(0, 0, 0, 0) 0%,
    rgba(0, 0, 0, 0) 100%
  );
  &.--active {
    background: linear-gradient(
      335deg,
      rgba(0, 0, 0, 0.03) 0%,
      rgba(0, 0, 0, 0.05) 100%
    );
  }

  &:hover {
    color: black;
    background: linear-gradient(
      155deg,
      rgba(22, 15, 15, 0.08) 0%,
      rgba(0, 0, 0, 0.1) 100%
    );
  }
`;
const $DropdownIcon = styled.div `
  position: absolute;
  top: 10px;
  left: 10px;
  width: 12px;
  height: 12px;
  font-size: 10px;
`;
function DropdownIcon() {
    return (React.createElement($DropdownIcon, null,
        React.createElement(CaretDown, null)));
}
function Button({ command, editor, toolbarState, }) {
    const { SvgIcon, label, hotkey, dropdown = false, action, isActive } = command;
    const ref = useRef(null);
    const modal = useModal(ModalType.Dialog);
    const active = isActive ? isActive(toolbarState) : false;
    const className = cx({ "--active": active });
    function onMouseDown(e) {
        stopEvent(e); // save the lastSelection so we can use it in dialog.
        // Used in `InsertLinkDialog` for example.
        editor.lastSelection =
            editor.selection != null ? editor.selection : editor.lastSelection;
        if (ref.current == null) {
            throw new Error(`ref.current must be defined`);
        }
        const dest = ref.current;
        action({ editor, modal, dest, toolbarState });
    }
    return (React.createElement(Tooltip, { label: label, hotkey: hotkey },
        React.createElement($IconButton, { className: className, tabIndex: -1, ref: ref, unselectable: "on", onMouseDown: onMouseDown, style: { position: "relative" } },
            SvgIcon ? React.createElement(SvgIcon, { className: "wm-svg-icon" }) : null,
            dropdown ? React.createElement(DropdownIcon, null) : null)));
}
function ButtonGroup({ className, items, toolbarState, disable = [], }) {
    const editor = useSlate();
    return (React.createElement($ButtonGroup, { className: className }, items.map((item) => {
        if (isCommand(item) &&
            !disable.includes("id" in item ? (item.id !== undefined ? item.id : "") : "")) {
            return (React.createElement(Button, { key: item.label, command: item, editor: editor, toolbarState: toolbarState }));
        }
        else {
            return null;
        }
    })));
}
const RenderEditorToolbar = React.memo(function RenderEditorToolbar({ toolbarState, focused, }) {
    const className = cx({ "--focused": focused });
    return (React.createElement($Toolbar, { tabIndex: -1, className: className },
        React.createElement($IconButtons, null,
            React.createElement(ButtonGroup, { items: SIMPLE_COMMANDS, toolbarState: toolbarState }),
            React.createElement(ButtonGroup, { items: MARK_COMMANDS, toolbarState: toolbarState }),
            React.createElement(ButtonGroup, { items: PLUS_COMMANDS, className: "--mobile-only", toolbarState: toolbarState }),
            React.createElement(ButtonGroup, { items: INSERT_COMMANDS, className: "--desktop-only", toolbarState: toolbarState, disable: ["insert-file"] }))));
});
function EditorToolbar() {
    const editor = useSlate();
    const focused = useFocused();
    const toolbarState = getToolbarState(editor);
    return React.createElement(RenderEditorToolbar, { focused: focused, toolbarState: toolbarState });
}

/**
 * We split off the render into its own Component so that we have access to
 * the `useFocused` hook.
 */
function Container({ "data-cy": dataCy, showInitial = false, minHeight = 240, maxHeight, onBlur, }) {
    const isFocused = useFocused();
    const editor = useSlateStatic();
    /**
     * On the first render, if `showInitial` is true, it will quickly set the
     * className to the first argument and then remove it.
     *
     * This is used to fade in the content after the initial render and makes
     * the first render less jarring when used with the lazy loading
     * `externalModule`.
     */
    const initialContentClassName = useInitialClassName("--initial-editor-content", showInitial);
    /**
     * Use different CSS styling when a maxHeight is provided.
     */
    const className = cx(initialContentClassName, {
        "--focused": isFocused,
    });
    /**
     * Min height is always specified and a max height is optional.
     *
     * When max height is not specified, HTML says that it defaults to `none`
     * which is what we want.
     */
    const style = { minHeight, maxHeight };
    return (React.createElement($OuterEditorContainer, { className: className },
        React.createElement(EditorToolbar, null),
        React.createElement($InnerEditorContainer, { ref: editor.containerRef, style: style },
            React.createElement(CustomEditable, { className: "wysimark-body", "data-cy": dataCy, readOnly: false, onBlur: onBlur }))));
}
const $OuterEditorContainer = styled.div `
  position: relative;
  border: 1px solid ${colors.editorBorderColor};
  border-radius: ${colors.editorBorderRadius};

  /**
   * Fade a nice blue border on a focus or blur
   */
  transition: border ${colors.editorBorderTransition},
    box-shadow ${colors.editorBorderTransition};
  &.--focused {
    border: 1px solid ${colors.highlight};
    box-shadow: ${colors.highlight} 0 0 0 1px;
  }
`;
/**
 * Style the container that surrounds the Toolbar and the Editable Content
 * area.
 */
const $InnerEditorContainer = styled.div `
  border-radius: ${colors.editorBorderRadius};

  /**
   * This forces the inner Editable div to expand to fill the space in the
   * container which is important so that when we click on the empty part
   * of the content area, it triggers an onClick event which will focus
   * the editor and position the selection.
   *
   * This won't happen if the Editable is only at the top part of the container.
   *
   * IMPORTANT:
   *
   * This works in conjunction with styled-editable.ts which provides the
   * flex styling for the Editable.
   */
  display: flex;
  flex-direction: column;
`;

function noop() {
    /* noop */
}
/**
 * Main Entry Point for Wysimark
 */
const Wysimark = function (_a) {
    var { editor, onChange: onChangeProp = noop, onUpdate: onUpdateProp = noop, onBlur: onBlurProp = noop, throttle = 1000 } = _a, renderWysimarkProps = __rest(_a, ["editor", "onChange", "onUpdate", "onBlur", "throttle"]);
    /**
     * `value` state used to keep all of the content in the editor.
     */
    const [value, setValue] = useState(() => {
        const initialValue = parse(editor.initialMarkdown);
        /**
         * We set the `lastValue` here because if we don't, when we click into the
         * editor, the editor gets a call to `onChange` (for the selection change)
         * and because `lastValue` hasn't been set yet, we will get an `onChange`
         * called when there has been no change to the value.
         *
         * Notice in the `onChange` code that we check for a change by looking at
         * the `editor.lastValue`.
         */
        editor.lastValue = initialValue;
        return initialValue;
    });
    /**
     * This is a throttled version of onUpdate. It is defined such that if
     * `onUpdateProp` is `undefined`, then `onUpdate` is just a `noop`. This is
     * done mostly just to satisfy typing so it can be used inside the `onChange`
     * callback without an `if` statement.
     */
    const onUpdate = useCallback(throttle_1((e) => {
        onUpdateProp(e);
    }, throttle, 
    /**
     * We don't ant a call to the function on the leading edge which would
     * always just be one character change. We do want to ensure that the
     * trailing edge always gets an update though.
     */
    { leading: false, trailing: true }), [onUpdateProp]);
    /**
     * Callback to set the editor value which is passed into `Slate` component.
     */
    const onChange = useCallback((value) => {
        /**
         * Sets the current editor value both as `useState` state and using a
         * `valueRef`. The `valueRef` is necessary for use with the `getMarkdown`
         * callback method.
         */
        if (value !== editor.lastValue) {
            setValue(value);
            const editorEvent = getEditorEvent(editor);
            onUpdate(editorEvent);
            onChangeProp(editorEvent);
            editor.lastValue = value;
        }
    }, [editor, onUpdate]);
    /**
     * When we lose focus from the `contentEditable` we want to call both
     * `onUpdate` and `onBlur`. This is because if we don't call `onUpdate`,
     * a developer depending on that for updating a value, may not get the
     * editor update until it is too late if the user clicks a button to save
     * too fast.
     *
     * Unfortunately, this won't work if the developer has added a save shortcut
     * key since the editor will not have been updated.
     *
     * Note that `onUpdate` may be called unnecessarily though but that shouldn't
     * be a big deal.
     */
    const onBlur = useCallback(() => {
        const e = getEditorEvent(editor);
        /**
         * TODO: `onUpdate.cancel` seems to work everywhere except in Vue. Figure out why and fix it.
         *
         * Prevent onUpdate from being called twice.
         */
        onUpdate.cancel();
        onUpdateProp(e);
        onBlurProp(e);
    }, [editor, onUpdate]);
    return (React.createElement(Reset, null,
        React.createElement(ModalProvider, null,
            React.createElement(Slate, { editor: editor, value: value, onChange: onChange },
                React.createElement(Container, Object.assign({}, renderWysimarkProps, { onBlur: onBlur }))))));
};

function shallowEquals(arrA, arrB) {
    if (arrA === arrB) {
        return true;
    }
    if (!arrA || !arrB) {
        return false;
    }
    const len = arrA.length;
    if (arrB.length !== len) {
        return false;
    }
    for (let i = 0; i < len; i++) {
        if (arrA[i] !== arrB[i]) {
            return false;
        }
    }
    return true;
}

/**
 * Ensure all the children of a line contain only unstyled `Text`
 *
 * - Remove marks
 * - Remove links
 */
function ensureUnstyledLine(editor, element, path) {
    let normalized = false;
    for (const [childNode, childPath] of Node.children(editor, path, {
        reverse: true,
    })) {
        if (Text.isText(childNode) && Object.keys(childNode).length === 1)
            continue;
        /**
         * Simplified the code so that `inline` elements and text nodes with more
         * than one property (i.e. a mark) are handled the same.
         */
        Transforms.removeNodes(editor, { at: childPath });
        Transforms.insertNodes(editor, { text: Node.string(childNode) }, { at: childPath });
        normalized = true;
    }
    return normalized;
}

/**
 * Returns true if the given element is orphaned which means that it expected
 * a parent of a specific `type` but it was not there.
 */
function isOrphaned(editor, element, path, parentType) {
    const parentEntry = Editor.parent(editor, path);
    if (parentEntry == null)
        return false;
    const [parentNode] = parentEntry;
    return !Element.isElement(parentNode) || parentNode.type !== parentType;
}
/**
 * Takes an element and makes sure it has the correct `parentType`.
 *
 * If it does not, we convert the element to be a `paragraph` which is
 * allowed as a child to most element types.
 */
function convertOrphanToParagraph(editor, element, path, parentType) {
    if (!isOrphaned(editor, element, path, parentType))
        return false;
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const propsToRemove = __rest(element
    // const elementKeys = Object.keys(element).filter((el) =>
    //   !["type", "children"].includes(el)
    // )
    , ["type", "children"]);
    // const elementKeys = Object.keys(element).filter((el) =>
    //   !["type", "children"].includes(el)
    // )
    const nullProps = Object.fromEntries(Object.keys(propsToRemove).map((key) => [key, null]));
    const props = Object.assign({ type: "p" }, nullProps);
    Transforms.setNodes(editor, props, { at: path });
    return true;
}
/**
 * If it's an orphan, unwrap the current element
 */
function unwrapOrphanElement(editor, element, path, parentType) {
    if (!isOrphaned(editor, element, path, parentType))
        return false;
    Transforms.unwrapNodes(editor, { at: path });
    return true;
}

/**
 * If the given element is kind of empty (see `isElementKindOfEmpty`) then
 * remove the given `Element`.
 */
function removeElementIfEmpty(editor, element, path) {
    if (!isEmptyElement(element))
        return false;
    Transforms.removeNodes(editor, { at: path });
    return true;
}
/**
 * If an element is empty, wrap it with the provided `defaultElement`
 */
function wrapElementIfEmpty(editor, element, path, defaultElement) {
    if (!isEmptyElement(element))
        return false;
    Transforms.wrapNodes(editor, defaultElement, { at: [...path, 0] });
    return true;
}

/**
 * Remove any children that are not of a given `Element` type.
 *
 * This is useful for nested elements like a `table` that expects a specific
 * hierarchical structure (e.g. a `table` element with `tr` children and those
 * having `td` children).
 */
function removeInvalidChildren(editor, path, validTypes) {
    let normalized = false;
    for (const [child, childPath] of Node.children(editor, path, {
        reverse: true,
    })) {
        if (!Element.isElement(child) || !validTypes.includes(child.type)) {
            Transforms.removeNodes(editor, { at: childPath });
            normalized = true;
        }
    }
    return normalized;
}

/**
 * Returns true if the `Element` provided is empty.
 *
 * NOTE:
 *
 * It does not check for empty `children` and instead checkes for exactly
 * one child with `{text: ""}`.
 *
 * This is because Slate does a pre-normalization check before any normalizers
 * can run, including custom normalizers, that replaces empty children with
 * `[{text: ""}]`.
 */
function isEmptyElement(element) {
    /**
     * Why we still need this:
     *
     * Slate has one constraint that runs before any of the normalization steps
     * which is to make sure that there are no empty children. If there are,
     * then an empty `Text` is inserted as a single child.
     *
     * HOWEVER, during the normalization stage, it's possible for us to remove
     * all the children and we see true empty children. This would be something
     * that we did, not Slate, and only in the middle of normalization.
     */
    if (element.children.length === 0)
        return true;
    /**
     * There is more than one child so not empty
     */
    if (element.children.length > 1)
        return false;
    const onlyChild = element.children[0];
    /**
     * If it's not a text child, not considered empty
     */
    if (!Text.isText(onlyChild))
        return false;
    /**
     * If there's any text in it, not empty
     */
    return onlyChild.text === "";
}

/**
 * A LinkElement cannot exist without any text. Once we remove the last
 * character, we remove the link.
 */
function normalizeBlockquote(editor, element, path) {
    /**
     * INVALID PARENT:
     *
     * n/a
     *
     * Blockquotes are valid at the root so we don't want to do any normalization.
     */
    /**
     * EMPTY CHILDREN:
     *
     * If a blockquote is empty, remove it.
     */
    removeElementIfEmpty(editor, element, path);
    /**
     * INVALID CHILDREN:
     *
     * n/a
     *
     * Can hold anything that the root element can include a `blockquote`
     */
    /**
     * PROPS:
     *
     * n/a
     *
     * No props
     */
    return false;
}

/**
 * A LinkElement cannot exist without any text. Once we remove the last
 * character, we remove the link.
 */
function normalizeCodeBlock(editor, element, path) {
    /**
     * INVALID PARENT:
     *
     * Shuld be handled by parent. We only handle invalid parent for `Editor`
     * to improve performance.
     */
    /**
     * EMPTY CHILDREN:
     *
     * Remove if empty
     */
    if (removeElementIfEmpty(editor, element, path))
        return true;
    /**
     * INVALID CHILDREN:
     *
     * Convert children using `Node.string`. This has the nice side effect of
     * also fixing the empty children.
     */
    if (convertChildrenToCodeLine(editor, element, path))
        return true;
    return false;
}
/**
 * Makes sure that all children of `code-block` is a `code-line`.
 *
 * This method also makes sure that any children of a given element are not `Text`
 * nodes. If they are, we wrap them in a `code-line`
 *
 * This is done because if somehow the child element of the Element is removed,
 * Slate will force a child to exist and it does this by inserting a `Text`
 * Node.
 *
 * IMPORTANT:
 *
 * This has been confirmed that it can happen when using a Transform that
 * removes the last child. We end up with a `Text` node.
 */
function convertChildrenToCodeLine(editor, element, path) {
    let normalized = false;
    const children = Node.children(editor, path, {
        reverse: true,
    });
    for (const [child, childPath] of children) {
        if (isElementByType(child, "code-line"))
            continue;
        Transforms.removeNodes(editor, { at: childPath });
        Transforms.insertNodes(editor, {
            type: "code-line",
            children: [{ text: Node.string(child) }],
        }, { at: childPath });
        normalized = true;
    }
    return normalized;
}

/**
 * A LinkElement cannot exist without any text. Once we remove the last
 * character, we remove the link.
 */
function normalizeCodeLine$1(editor, element, path) {
    /**
     * EMPTY CHILDREN:
     *
     * Do nothing because it will always be at least an empty `Text` node.
     */
    /**
     * INVALID CHILDREN:
     *
     * Ensure code line contain only unstyled text
     */
    if (ensureUnstyledLine(editor, element, path))
        return true;
    /**
     * INVALID PARENT:
     *
     * Convert `code-line` without a parent `code-block` to a paragraph
     */
    if (convertOrphanToParagraph(editor, element, path, "code-block"))
        return true;
    return false;
}

/**
 * Normalize the Editor by making sure that the last block in the Editor is
 * always a convertible. If not, then insert an empty paragraph.
 */
function normalizeEditor(editorNode) {
    /**
     * Last block must be a convertible block like `p`, `heading` or
     * ListItemElement.
     *
     * If it's not, insert an empty paragraph
     */
    const lastBlock = editorNode.children[editorNode.children.length - 1];
    if (!isConvertibleBlockElement(lastBlock)) {
        Transforms.insertNodes(editorNode, { type: "p", children: [{ text: "" }] }, { at: [editorNode.children.length] });
        return true;
    }
    return false;
}

function normalizeLink(editor, node, path) {
    /**
     * INVALID PARENT:
     *
     * n/a
     */
    /**
     * EMPTY CHILDREN:
     *
     * Remove empty links
     */
    if (removeEmptyLink(editor, node, path))
        return true;
    /**
     * INVALID CHILDREN:
     *
     * Text children are fine. But nested inlines need to be lifted because we
     * don't allow nested inlines in our schema.
     */
    if (liftNestedLink(editor, node, path))
        return true;
    /**
     * SHAPE:
     *
     * n/a
     */
    return false;
}
/**
 * A LinkElement cannot exist without any text. Once we remove the last
 * character, we remove the link.
 */
function removeEmptyLink(editor, element, path) {
    if (element.children.length === 1 && element.children[0].text === "") {
        Transforms.removeNodes(editor, { at: path });
        return true;
    }
    return false;
}
/**
 * A LinkElement cannot exist without any text. Once we remove the last
 * character, we remove the link.
 */
function liftNestedLink(editor, element, path) {
    /**
     * If any of the children of an inline contain an Element (we are expecting
     * text), then lift them out of the inline.
     *
     * Note that when we lift, the `element` stays intact and becomes a sibling
     * of the inline.
     */
    let normalized = false;
    for (const [child, childPath] of Node.children(editor, path, {
        reverse: true,
    })) {
        if (Element.isElement(child)) {
            Transforms.liftNodes(editor, { at: childPath });
            normalized = true;
        }
    }
    return normalized;
}

function normalizeListItem(editor, 
// DO NOT REMOVE: Useful for type checking incoming element
element, path) {
    let normalized = false;
    const parentPath = Path.parent(path);
    const nodeIndex = path[-1];
    const listStartIndex = findListStartIndex(editor, parentPath, nodeIndex);
    const listStartKey = JSON.stringify([...parentPath, listStartIndex]);
    /**
     * Check if this list has been reordered already and if it has, short-circuit.
     * We don't need to check again.
     */
    if (editor.reorderedLists[listStartKey])
        return false;
    /**
     * Make the list as ordered using its path stringified
     */
    editor.reorderedLists[listStartKey] = true;
    /**
     * Find the end of the list
     */
    const listEndIndex = findListEndIndex(editor, parentPath, nodeIndex);
    /**
     * An `Array` of numbers that represents the current `value` of the list
     * at a given depth.
     */
    const values = [];
    /**
     * Iterate through the list item elements keeping track of the current
     * `values` and adjusting them/setting the props on `OrderedListItemElement`
     */
    for (let i = listStartIndex; i <= listEndIndex; i++) {
        /**
         * Because of our `listStartIndex` and `listEndIndex` algorithms, we know
         * we are getting `ListItemElement` only so we type case these as
         * `ListItemElement`
         */
        const li = Node.get(editor, [...parentPath, i]);
        /**
         * Delete the stuff that is passed the current depth level
         */
        values.splice(li.depth + 1);
        /**
         * Set the current `value` for the list item element by incrementing the
         * current depth or setting it to `1` if there isn't a value there
         */
        const value = (values[li.depth] =
            values[li.depth] == null ? 1 : values[li.depth] + 1);
        /**
         * If it's not an `ordered-list-item` or if the number already matches,
         * there's nothing to do so `continue`
         */
        if (li.type !== "ordered-list-item" || li.number === value)
            continue;
        Transforms.setNodes(editor, { number: value }, { at: [...parentPath, i] });
        normalized = true;
    }
    return normalized;
}
/**
 * Find the position of the start of the current list by iterating backwards
 * from the current position until we run into an element that is not a
 * `ListItemElement`
 */
function findListStartIndex(editor, parentPath, index) {
    for (let i = index - 1; i >= 0; i--) {
        const node = Node.get(editor, [...parentPath, i]);
        if (isListItemElement(node))
            continue;
        return i + 1;
    }
    return 0;
}
/**
 * Find the position of the end of the current list by iterating forwards
 * from the current position until we run into an element that is not a
 * `ListItemElement`
 */
function findListEndIndex(editor, parentPath, index) {
    const siblingCount = Node.parent(editor, [...parentPath, index]).children
        .length;
    for (let i = index + 1; i < siblingCount; i++) {
        const node = Node.get(editor, [...parentPath, i]);
        if (isListItemElement(node))
            continue;
        return i - 1;
    }
    return siblingCount - 1;
}

/**
 * Normalize the various parts of the table
 */
function normalizeTable(editor, table, path) {
    /**
     * Normalize invalid parent: n/a
     */
    /**
     * Normalize empty children
     */
    if (removeElementIfEmpty(editor, table, path))
        return true;
    /**
     * Normalize invalid children
     */
    if (removeInvalidChildren(editor, path, ["tr"]))
        return true;
    /**
     * Normalize props
     *
     * `columns` are normalized to cell count in `tr` normalizer
     */
    return false;
}

/**
 * Remove children that are not `td` elements
 */
function normalizeTableCell(editor, el, path) {
    /**
     * Normalize invalid parent
     *
     * Unwrap if it's not in a `tr`
     */
    if (unwrapOrphanElement(editor, el, path, "tr"))
        return true;
    /**
     * Normalize empty children
     *
     * Ensure that there is at least one `p`
     */
    wrapElementIfEmpty(editor, el, path, {
        type: "p",
        children: [],
    });
    /**
     * Normalize invalid children
     *
     * Should have exactly one child of type `p`.
     *
     * If there is more than one or the wrong type, merge the segments into a
     * single `p`.
     */
    if (mergeTableCellSegmentsIntoSingleP(editor, el, path))
        return true;
    /**
     * Normalize shape
     *
     * Make sure that each cell has the correct `index`
     */
    if (reindexTableCell(editor, el, path))
        return true;
    return false;
}
function reindexTableCell(editor, el, path) {
    const expectedIndex = path.slice(-1)[0];
    if (el.index == expectedIndex)
        return false;
    Transforms.setNodes(editor, { index: expectedIndex }, { at: path });
    return true;
}
function mergeTableCellSegmentsIntoSingleP(editor, el, path) {
    if (el.children.length === 0)
        throw new Error("Shouldn't happen");
    if (el.children.length === 1 && el.children[0].type === "p")
        return false;
    const insertedParagraphPath = [...path, 0];
    Editor.withoutNormalizing(editor, () => {
        /**
         * Insert a paragraph to move all the other segments into. We could reuse
         * the first `Element` but it complicates the logic.
         */
        Transforms.insertNodes(editor, { type: "p", children: [] }, { at: insertedParagraphPath });
        /**
         * Move the children that are `Text` or `Inline` into the inserted `p`
         */
        Transforms.moveNodes(editor, {
            at: path,
            match: (n, p) => {
                return (!Path.isAncestor(insertedParagraphPath, p) &&
                    (Text.isText(n) || isInlineElement(n)));
            },
            to: [...insertedParagraphPath, 0],
        });
        /**
         * Remove all the now empty nodes from which we moved the children from
         */
        Transforms.removeNodes(editor, {
            at: path,
            match: (n, p) => Path.isParent(path, p) && !Path.equals(p, insertedParagraphPath),
        });
    });
    return true;
}

/**
 * Remove children that are not `td` elements
 */
function normalizeTableRow(editor, el, path) {
    /**
     * Normalize invalid parent
     *
     * Unwrap
     */
    if (unwrapOrphanElement(editor, el, path, "table"))
        return true;
    /**
     * Normalize empty children
     */
    if (removeElementIfEmpty(editor, el, path))
        return true;
    /**
     * Normalize invalid children
     *
     * Remove them
     */
    if (removeInvalidChildren(editor, path, ["td"]))
        return true;
    /**
     * Normalize props
     *
     * Match number of `td` in `tr` to `table.columns`
     *
     * This only works if there is a `table` parent because if there
     * isn't, the call to `getTableInfo` fails
     */
    if (addAndRemoveCellsInRowToMatchColumns(editor, path))
        return true;
    return false;
}
/**
 * Adds or remove cells in a table row to match the number of `table.columns`
 * which is authoritative.
 */
function addAndRemoveCellsInRowToMatchColumns(editor, path) {
    const { table, trPath, tdCount } = getTableInfo(editor, path);
    const columnCount = table.columns.length;
    /**
     * Not enough cells, add more
     */
    if (tdCount < columnCount) {
        Editor.withoutNormalizing(editor, () => {
            for (let i = tdCount; i < columnCount; i++) {
                Transforms.insertNodes(editor, createTd(i), { at: [...trPath, i] });
            }
        });
        return true;
    }
    /**
     * Too many cells, remove some
     */
    if (tdCount > columnCount) {
        Editor.withoutNormalizing(editor, () => {
            for (let i = tdCount - 1; i >= columnCount; i--) {
                Transforms.removeNodes(editor, { at: [...trPath, i] });
            }
        });
        return true;
    }
    return false;
}

/**
 * Add normalization to the Editor
 */
function withNormalize(editor) {
    const { normalizeNode: originalNormalizeNode } = editor;
    /**
     * Set the initial value of `reorderedLists` so it doesn't start as
     * `undefined` which would break list normalization as it expects it to be
     * an `object`
     */
    editor.reorderedLists = {};
    /**
     * NOTE:
     *
     * Why not use `NodeEntry`?
     *
     * Considered passing a `NodeEntry` around but it tends to make type
     * narrowing more challenging as TypeScript doesn't do type narrowing
     * automatically for tuples with an object in it.
     */
    editor.normalizeNode = ([node, path]) => {
        /**
         * This is an optimized path through normalizing all the Node types.
         *
         * If we know it's not an Element, we don't have to do the individual
         * Element checks.
         */
        if (Element.isElement(node)) {
            /**
             * Normalize Element with option to short-circuit return
             */
            switch (node.type) {
                /**
                 * Normalize Inline
                 */
                case "link":
                    if (normalizeLink(editor, node, path))
                        return;
                    break;
                /**
                 * Normalize Code Block
                 */
                case "code-line":
                    if (normalizeCodeLine$1(editor, node, path))
                        return;
                    break;
                case "code-block":
                    if (normalizeCodeBlock(editor, node, path))
                        return;
                    break;
                /**
                 * Normalize Table
                 */
                case "td":
                    if (normalizeTableCell(editor, node, path))
                        return;
                    break;
                case "tr":
                    if (normalizeTableRow(editor, node, path))
                        return;
                    break;
                case "table":
                    if (normalizeTable(editor, node, path))
                        return;
                    break;
                /**
                 * Normalize List items
                 */
                case "ordered-list-item":
                case "unordered-list-item":
                case "task-list-item":
                    if (normalizeListItem(editor, node, path))
                        return;
                    break;
                /**
                 * Normalize block quote
                 */
                case "blockquote":
                    if (normalizeBlockquote(editor, node, path))
                        ;
                    break;
                /**
                 * Flush elements don't need normalizing
                 *
                 * Void elements don't need normalizing
                 */
                case "p":
                case "heading":
                case "hr":
                case "media":
                    break;
                default:
                    assertUnreachable(node);
            }
        }
        else if (Editor.isEditor(node)) {
            /**
             * The last item normalized is always the top level `Editor` object and
             * we use this fact to reset the `reorderedList` after normalization.
             */
            editor.reorderedLists = {};
            /**
             * Normalize Editor and ensure it ends in a `ConvertibleElement`
             */
            if (normalizeEditor(node))
                return;
        }
        else if (Text.isText(node)) ;
        else {
            assertUnreachable(node);
        }
        originalNormalizeNode([node, path]);
    };
    return editor;
}

/**
 * Takes a File object (e.g. from an <input type="file">) and returns the
 * width/height of the image if the File is an image. If it's not an image,
 * it returns null.
 *
 * <https://stackoverflow.com/questions/623172/how-to-get-image-size-height-width-using-javascript>
 */
function getImageSizeFromFile(file) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve) => {
            if (isImage(file)) {
                const reader = new FileReader();
                reader.addEventListener("load", function (e) {
                    if (e.target == null) {
                        throw new Error(`Expected a value for e.target`);
                    }
                    if (typeof e.target.result !== "string") {
                        throw new Error(`Expected e.target.result to be a string`);
                    }
                    const src = e.target.result;
                    const image = new Image();
                    image.addEventListener("load", function () {
                        const dimensions = {
                            width: this.naturalWidth,
                            height: this.naturalHeight,
                        };
                        resolve(dimensions);
                    });
                    image.src = src;
                });
                reader.readAsDataURL(file);
            }
            else {
                resolve(undefined);
            }
        });
    });
}
function isImage(file) {
    const ext = file.name.split(".").pop();
    if (ext == null)
        return false;
    return ["png", "gif", "jpg", "jpeg"].includes(ext);
}

/**
 * Uploads the file to the actual endpoint.
 *
 * Takes a file field and a `policy` generated using `server.ts` and uploads
 * that file to Amazon S3.
 */
function uploadFile({ file, policy, onProgress, }) {
    return __awaiter(this, void 0, void 0, function* () {
        const { formFields, apiUrl, fileUrl } = policy;
        // upload file to Amazon
        const form = new FormData();
        Object.entries(formFields).forEach(([key, value]) => {
            form.append(key, value);
        });
        form.append("content-type", file.type);
        form.append("file", file);
        /**
         * Post to S3 with a callback for returning progress
         */
        const uploadResponse = yield axios.post(apiUrl, form, {
            onUploadProgress(e) {
                if (onProgress == null)
                    return;
                onProgress({ file, loaded: e.loaded, total: e.total });
            },
        });
        if (uploadResponse.status === 204) {
            return { url: fileUrl };
        }
        else {
            throw new Error(`Error during upload ${JSON.stringify(uploadResponse.data, null, 2)}`);
        }
    });
}

/**
 * `useStateRef` is useful when you need both a reactive state that will
 * update the DOM when there is a change while also needing an accurate to
 * the moment version of the value.
 *
 * This can happen when you have a callback and you want to be able to
 * us the `useCallback` hook. If we tie it to a state from `useState`,
 * the data could be outdated when the method is called.
 */
function useStateRef(fn) {
    const [rawState, rawSetState] = useState(fn);
    const ref = useRef(rawState);
    const setState = useCallback((fn) => {
        rawSetState((prevState) => {
            const nextState = fn(prevState);
            ref.current = nextState;
            return nextState;
        });
    }, []);
    return [rawState, setState, ref];
}

/**
 * Returns true of there are one or more errors in the upload states
 */
function checkHasUploadErrors(uploads) {
    return Array.from(uploads.values()).some((upload) => {
        return upload.status === "error";
    });
}
/**
 * The UploadProgressDialog exists while files are uploaded.
 *
 * The process is a little unituitive. We open the UploadProgressDialog
 * Dialog and then this Dialog itself is responsible for initiating the upload
 * and when done, closing itself and putting the files/images
 */
function UploadProgressDialog({ dest, editor, files, }) {
    const modal = useInModal();
    /**
     * Set the initial UploadState to `waiting`
     */
    const [uploads, setUploads, uploadsRef] = useStateRef(() => {
        const map = new Map();
        for (const file of files) {
            map.set(file, { status: "waiting" });
        }
        return map;
    });
    /**
     * Function to update the UploadState using a more natural syntax
     */
    const setUpload = useCallback(function setUpload(file, state) {
        setUploads((prevMap) => {
            const map = new Map(prevMap);
            map.set(file, state);
            return map;
        });
    }, []);
    useEffect(() => {
        (function () {
            return __awaiter(this, void 0, void 0, function* () {
                const uploadOptions = editor.uploadOptions;
                if (uploadOptions.type === "disabled") {
                    throw new Error(`Uploading has been disabled`);
                }
                /**
                 * Upload all the files by first getting a policy from the API endpoint
                 * and then sending the files based on the policy we retrieved.
                 *
                 * During this phase, we are interactively updating the uploadState.
                 */
                yield Promise.all(Array.from(files).map((file) => __awaiter(this, void 0, void 0, function* () {
                    const dimensions = yield getImageSizeFromFile(file);
                    const uploadFileInfo = dimensions
                        ? {
                            type: "image",
                            filename: file.name,
                            bytes: file.size,
                            width: dimensions.width,
                            height: dimensions.height,
                        }
                        : {
                            type: "generic",
                            filename: file.name,
                            bytes: file.size,
                        };
                    const props = Object.assign({ file: uploadFileInfo }, omit_1(editor.uploadOptions, ["url"]));
                    let rawResponse;
                    try {
                        rawResponse = yield axios.post(uploadOptions.url, props);
                    }
                    catch (e) {
                        setUpload(file, {
                            status: "error",
                            message: `Could not access the upload API.
The most likely cause is that the API URL ${JSON.stringify(uploadOptions.url)} is configured incorrectly.
The error is:
${e}`,
                        });
                        return;
                    }
                    const response = rawResponse.data;
                    if (response.status === "error") {
                        setUpload(file, { status: "error", message: response.message });
                        return;
                    }
                    if (response.status !== "success") {
                        setUpload(file, {
                            status: "error",
                            message: `This response from the server does is invalid: ${JSON.stringify(response)}`,
                        });
                        return;
                    }
                    setUpload(file, {
                        status: "sending",
                        loaded: 0,
                        total: file.size,
                    });
                    yield uploadFile({
                        file,
                        policy: response.data,
                        onProgress: (e) => {
                            if (e.loaded !== e.total) {
                                setUpload(file, {
                                    status: "sending",
                                    loaded: e.loaded,
                                    total: e.total,
                                });
                            }
                        },
                    });
                    setUpload(file, Object.assign({ status: "success", loaded: file.size, total: file.size, fileUrl: response.data.fileUrl }, dimensions));
                })));
                /**
                 * When everything is done, we start iterating through the uploads and
                 * inserting them into the editor.
                 */
                for (const [file, upload] of Array.from(uploadsRef.current.entries())) {
                    if (upload.status === "success") {
                        reselect(editor);
                        if (upload.width && upload.height) {
                            const maxWidth = getEditorInnerWidth(editor);
                            if (upload.width > maxWidth) {
                                const width = Math.round(Math.min(maxWidth, upload.width));
                                const height = Math.round(width * (upload.height / upload.width));
                                const imageUrl = `${upload.fileUrl}?size=${width}x${height}`;
                                insertMedia(editor, imageUrl);
                            }
                            else {
                                insertMedia(editor, upload.fileUrl);
                            }
                        }
                        else {
                            insertLinkBlock(editor, upload.fileUrl, `${file.name} (${prettyBytes(file.size)})`);
                        }
                    }
                }
                if (!checkHasUploadErrors(uploadsRef.current)) {
                    /**
                     * Prevent a React error.
                     *
                     * The timeout is required because otherwise the modal closes but
                     * there may be pending render updates due to changes in the progress
                     * bar state. By providing a short wait, we make sure they get a
                     * chance to run.
                     */
                    setTimeout(() => {
                        modal.close();
                    }, 100);
                }
                return uploads;
            });
        })();
    }, []);
    const hasUploadErrors = checkHasUploadErrors(uploads);
    return (React.createElement(Dialog, { title: hasUploadErrors ? "Errors While Uploading" : "Uploading...", dest: dest, position: Position$1.Inside, width: 320 },
        hasUploadErrors ? (React.createElement(React.Fragment, null,
            React.createElement(Form$1.Block, null,
                React.createElement("p", { style: { color: "#cc0000", fontWeight: "bold" } }, "Some files were not uploaded due to these issues."),
                React.createElement(Form$1.Button, { className: "btn btn-primary", onClick: modal.close }, "Got It!")),
            React.createElement(Form$1.Divider, null))) : null,
        Array.from(uploads.entries()).map(([file, uploadState], index) => {
            if (uploadState.status === "waiting" ||
                uploadState.status === "sending" ||
                uploadState.status === "success") {
                const { loaded, total } = uploadState.status === "sending" || uploadState.status === "success"
                    ? uploadState
                    : { loaded: null, total: null };
                const progress = loaded != null && total != null ? loaded / total : 0;
                return (React.createElement(Form$1.Block, { key: index },
                    React.createElement(Form$1.Label, null,
                        "Uploading ",
                        JSON.stringify(file.name)),
                    React.createElement(Form$1.Progress, { progress: progress })));
            }
            else if (uploadState.status === "error") {
                return (React.createElement(Form$1.Block, { key: index },
                    React.createElement(Form$1.Label, null,
                        "Error uploading ",
                        JSON.stringify(file.name)),
                    React.createElement($Error, null, uploadState.message)));
            }
            else {
                assertUnreachable(uploadState);
            }
        })));
}
const $Error = styled.div `
  color: #cc0000;
  font-weight: bold;
  line-height: 24px;
`;

/**
 * Adds a function `upload` to the Slate `editor` object.
 *
 * When initializing the `editor`, you should add the `withUpload` to enable
 * the upload function.
 */
function withUpload(editor) {
    /**
     * Create a `bodyRef` Ref that we can attach the Editor content body onto.
     */
    editor.containerRef = createRef();
    /**
     * Add an `upload` method onto the `Editor` instance.
     *
     * It takes a FileList (like an Array of File) and then starts uploading all
     * the files from it.
     *
     * It does this by opening a modal Dialog with the files attached. The
     * Dialog will iterate through each File, start the upload process on each
     * one of them, display a progress bar and then insert them into the document
     * when done.
     */
    editor.upload = function (files) {
        if (editor.containerRef == null)
            return;
        if (editor.containerRef.current == null) {
            throw new Error(`editor.containerRef.current must be defined`);
        }
        editor.modalDialog.open(UploadProgressDialog, {
            editor,
            files,
            dest: editor.containerRef.current,
            position: Position$1.Inside,
        });
    };
    return editor;
}

/**
 * Only allow deletes across element boundaries when they have the same parent
 *
 * If a delete crosses an element boundary at different levels, like say a
 * paragraph deleting into a `code-block` / `code-line`, the delete can end up
 * sucking that `code-line` out of the `code-block` into the `p` or visa
 * versa. This can be surprising to the user so we disable it.
 */
function deleteDynamicAroundNested(editor, direction) {
    const currentLowestBlockEntry = Editor.above(editor, {
        mode: "lowest",
        match: isBlockElement,
    });
    /**
     * This will be true but useful for type narrowing
     */
    if (currentLowestBlockEntry === undefined)
        return false;
    /**
     * Check if we are at the boundary of an element when deleting.
     *
     * If it's forward, we check if we are at the end.
     * If it's backward, we check if we are at the start.
     */
    const checkBoundary = direction === "forward" ? Editor.isEnd : Editor.isStart;
    if (editor.selection == null) {
        throw new Error(`Expected editor.selection to be defined`);
    }
    const isBoundary = checkBoundary(editor, editor.selection.anchor, currentLowestBlockEntry[1]);
    if (!isBoundary)
        return false;
    /**
     * Get the adjacent lowest element and check if it has the same parent as
     * the current one. We only want to allow a delete, when they share the
     * same parent otherwise Slate can behave in a surprising manner to the
     * user.
     **/
    const getAdjacent = direction === "forward" ? Editor.next : Editor.previous;
    const adjacentLowestBlockEntry = getAdjacent(editor, {
        match: isBlockElement,
        mode: "lowest",
    });
    if (adjacentLowestBlockEntry === undefined)
        return false;
    const sharesParent = isEqual_1(Path.parent(currentLowestBlockEntry[1]), Path.parent(adjacentLowestBlockEntry[1]));
    if (sharesParent)
        return false;
    /**
     * If the current and next lowest nodes don't share a parent, that means
     * they are at different levels and this means we don't want the delete to
     * happen because the delete will shuffle things through different levels.
     */
    return true;
}
/**
 * Only allow deletes across element boundaries when they have the same parent
 */
function deleteBackwardAroundNested(editor) {
    return deleteDynamicAroundNested(editor, "backward");
}
/**
 * Only allow deletes across element boundaries when they have the same parent
 */
function deleteForwardAroundNested(editor) {
    return deleteDynamicAroundNested(editor, "forward");
}

/**
 * If we are in an empty `code-line` that is the last `code-line` in a
 * `code-block`, when we delete, remove the entire `code-block`.
 */
function deleteInCodeLine(editor) {
    /**
     * Check if we are in an empty `code-line`
     */
    const codeLineEntry = Editor.above(editor, {
        match: (n) => Element.isElement(n) && n.type === "code-line",
    });
    if (codeLineEntry == null)
        return false;
    if (!isEmptyElement(codeLineEntry[0]))
        return false;
    /**
     * Check if we are in the last `code-line` of a `code-block`
     */
    const codeBlockEntry = Editor.above(editor, {
        match: (n) => Element.isElement(n) && n.type === "code-block",
    });
    if (codeBlockEntry == null)
        return false;
    if (codeBlockEntry[0].children.length > 1)
        return false;
    /**
     * If we are in the only remaining `code-line` and it is empty, remove
     * the `code-block`.
     */
    Transforms.removeNodes(editor, { at: codeBlockEntry[1] });
    return true;
}

function deleteInEmptyConvertible(editor, direction) {
    console.log(1);
    /**
     * Check if the cursor is currently in an empty convertible and if it isn't
     * we don't want to handle it
     */
    const currentEntry = Editor.above(editor);
    if (currentEntry === undefined)
        return false;
    const [el, path] = currentEntry;
    if (!isConvertibleBlockElement(el))
        return false;
    const text = Node.string(el);
    if (text.length > 0)
        return false;
    /**
     * Find the delete target and if it's a seamless element, we delete self
     * instead.
     */
    const deleteTargetEntry = direction === "backward"
        ? getNodeBeforeIf(editor, path)
        : getNodeAfterIf(editor, path);
    if (!deleteTargetEntry)
        return false;
    if (!isSeamlessElement(deleteTargetEntry[0]))
        return false;
    Transforms.delete(editor, { at: path });
    direction === "backward"
        ? focusAtEnd(editor, deleteTargetEntry[1])
        : focusAtStart(editor, path);
    return true;
}
/**
 * If we are at
 */
function deleteBackwardInEmptyConvertible(editor) {
    return deleteInEmptyConvertible(editor, "backward");
}
function deleteForwardInEmptyConvertible(editor) {
    return deleteInEmptyConvertible(editor, "forward");
}

/**
 * If we are at the beginning of a table cell, disable delete backward
 */
function deleteBackwardInList(editor) {
    const liEntry = Editor.above(editor, {
        match: isListItemElement,
    });
    /**
     * If not in a list, don't handle it
     */
    if (liEntry == null)
        return false;
    const [liElement, liPath] = liEntry;
    assertDefined(editor.selection, "editor.selection");
    const isStart = Editor.isStart(editor, editor.selection.anchor, liPath);
    if (!isStart)
        return false;
    if (liElement.depth === 0)
        return false;
    Transforms.setNodes(editor, { depth: liElement.depth - 1 }, { at: liPath });
    return true;
}

/**
 * If we are at the beginning of a table cell, disable delete backward
 */
function deleteBackwardInTd(editor) {
    var _a;
    const tdNodeEntry = Editor.above(editor, {
        match: (n) => Element.isElement(n) && n.type === "td",
    });
    if (tdNodeEntry == null)
        return false;
    assertDefined((_a = editor.selection) === null || _a === void 0 ? void 0 : _a.anchor, "editor.selection.anchor");
    const isStart = Editor.isStart(editor, editor.selection.anchor, tdNodeEntry[1]);
    return isStart;
}
/**
 * If we are at the end of a table cell, disable delete forward
 */
function deleteForwardInTd(editor) {
    const tdNodeEntry = Editor.above(editor, {
        match: (n) => Element.isElement(n) && n.type === "td",
    });
    if (tdNodeEntry == null)
        return false;
    assertDefined(editor.selection, "editor.selection");
    const isEnd = Editor.isEnd(editor, editor.selection.anchor, tdNodeEntry[1]);
    return isEnd;
}

function withDelete(editor) {
    /**
     * Ignore deletes at the beginning of a table cell
     */
    const originalDeleteBackward = editor.deleteBackward;
    editor.deleteBackward = (unit) => {
        if (deleteInCodeLine(editor))
            return;
        if (deleteBackwardInTd(editor))
            return;
        if (deleteBackwardInList(editor))
            return;
        if (deleteBackwardInEmptyConvertible(editor))
            return;
        if (deleteBackwardAroundNested(editor))
            return;
        originalDeleteBackward(unit);
    };
    /**
     * Ignore deletes at the end of a table cell
     */
    const originalDeleteForward = editor.deleteForward;
    editor.deleteForward = (unit) => {
        if (deleteInCodeLine(editor))
            return;
        if (deleteForwardInTd(editor))
            return;
        if (deleteForwardInEmptyConvertible(editor))
            return;
        if (deleteForwardAroundNested(editor))
            return;
        originalDeleteForward(unit);
    };
    return editor;
}

/**
 * If the selection is collapsed and in a table, insert a newline instead of
 * using the default of splitting the block.
 */
function insertBreakInTd(editor) {
    if (!isFocusInside(editor, "td"))
        return false;
    insertNewline(editor);
    return true;
}

function insertBreakInListItem(editor, originalInsertBreak) {
    /**
     * Check if we're in a list.
     */
    const listItemEntry = Editor.above(editor, {
        match: isListItemElement,
    });
    /**
     * If we're not in a list, exit early
     */
    if (listItemEntry == null)
        return false;
    const [listItemNode, listItemPath] = listItemEntry;
    const s = Node.string(listItemNode);
    /**
     * If the list item is empty, outdent
     */
    if (s.length === 0) {
        /**
         * Outdent by reducing depth by 1 but only works if depth is greater than 0
         */
        if (listItemNode.depth > 0) {
            Transforms.setNodes(editor, { depth: listItemNode.depth - 1 }, { at: listItemPath });
        }
        else if (listItemNode.depth === 0) {
            /**
             * When depth is 0 turn list item into a paragraph
             */
            Transforms.unsetNodes(editor, ["checked", "depth", "number"]);
            Transforms.setNodes(editor, { type: "p" });
        }
        return true;
    }
    originalInsertBreak();
    if (listItemNode.type === "task-list-item") {
        Transforms.setNodes(editor, { checked: false });
    }
    return true;
}

function insertBreakInConvertible(editor, originalInsertBreak, cursor) {
    /**
     * Look for convertible
     */
    const convertibleEntry = Editor.above(editor, {
        match: isConvertibleBlockElement,
    });
    /**
     * If we're not in a convertible, exit early
     */
    if (convertibleEntry == null)
        return false;
    const [convertibleNode, convertiblePath] = convertibleEntry;
    /**
     * We need to find out if we are at the end before calling `insertBreak`
     */
    const isEnd = Editor.isEnd(editor, cursor, convertiblePath);
    originalInsertBreak();
    /**
     * If we were at the end of the convertible, convert it to a paragraph
     */
    if (isEnd && convertibleNode.type !== "p") {
        Transforms.setNodes(editor, { type: "p" });
    }
    return true;
}

function insertBreakInCodeLine(editor, originalInsertBreak) {
    /**
     * If it's not in a code-line use default handler
     */
    if (!isFocusInside(editor, "code-line"))
        return false;
    /**
     * Find the code line above
     */
    const aboveEntry = Editor.above(editor, {
        match: (n) => {
            return Element.isElement(n) && n.type === "code-line";
        },
    });
    if (!aboveEntry)
        return false;
    const leadingSpaces = countLeadingSpaces(Node.string(aboveEntry[0]));
    originalInsertBreak();
    /**
     * Insert correct number of spaces
     */
    Transforms.insertText(editor, Array(leadingSpaces).fill(" ").join(""));
    return true;
}

/**
 * Core enter handling
 */
function insertBreak(editor, originalInsertBreak) {
    const { selection } = editor;
    /**
     * If there is no selection or the range, use the default handler
     */
    if (selection == null)
        return false;
    /**
     * If the selection is expanded, use the default handler
     */
    if (Range.isExpanded(selection))
        return false;
    /**
     * The anchor and the focus are the same
     */
    const { anchor: cursor } = selection;
    /**
     * In a code-line, when we insert a break, make sure to keep the indent
     * the same
     */
    if (insertBreakInCodeLine(editor, originalInsertBreak))
        return true;
    /**
     * In a table use newlines.
     */
    if (insertBreakInTd(editor))
        return true;
    /**
     * Special handling for lists
     */
    if (insertBreakInListItem(editor, originalInsertBreak))
        return true;
    /**
     * Special handling for inserting a break at the end of a convertible.
     *
     * Should turn the convertible into a paragraph.
     */
    if (insertBreakInConvertible(editor, originalInsertBreak, cursor))
        return true;
    return false;
}
function withInsertBreak(editor) {
    /**
     * Handle breaks in tables as newlines and also special handling when inserting
     * breaks at end of line.
     */
    const originalInsertBreak = editor.insertBreak;
    editor.insertBreak = () => {
        if (insertBreak(editor, originalInsertBreak))
            return;
        originalInsertBreak();
    };
    return editor;
}

/**
 * The default `activeImage` which is a static image. Just takes the image url
 * and returns the `url` with the `type` of `static` so that the image
 * renderer knows that it can't be resized and that we don't know the width
 * and height of the image either.
 */
function staticActiveImage(url) {
    return { type: "static", url };
}
/**
 * Adds active image resizers to the Editor.
 *
 * @param {Editor} editor Editor object
 * @param {string[]} urlPrefixes Array of the start of the URL which are valid
 *     for resizing like `https://*.files.wysimark.com` or
 *     `https://files.wysimark.com/*` or `https://files.mezine.com`.
 *     You can use a * as a wildcard match on alphanumeric plus dash and
 *     underscore
 */
function withActiveImage(editor, urlPrefixes) {
    /**
     * Convert the urlPrefixes
     */
    // const urlRegExps = urlPrefixes.map(convertPrefixToRegExp)
    const originalCreateActiveImage = editor.createActiveImage || staticActiveImage;
    /**
     * We are setting `createActiveImage` to a method that takes a `url` as an
     * argument and then returns an ActiveImage object.
     *
     * There is a function in it named `resize` which allows us to resize the
     * image and returns a `url` of the resized image.
     *
     * It also tells us other information like that the image is dynamic.
     */
    editor.createActiveImage = (url) => {
        for (const urlPrefix of urlPrefixes) {
            /**
             * If it doesn't start with the prefix, check next one.
             */
            if (!url.startsWith(urlPrefix))
                continue;
            const urlInfo = getUrlInfo(url);
            if (urlInfo.type == "image") {
                return {
                    type: "dynamic",
                    url,
                    resize: (width, height) => `${url}?size=${width}x${height}`,
                    width: urlInfo.width,
                    height: urlInfo.height,
                    originalWidth: urlInfo.width,
                    originalHeight: urlInfo.height,
                };
            }
            else if (urlInfo.type === "image-query") {
                return {
                    type: "dynamic",
                    url,
                    resize: (width, height) => `${urlInfo.original.url}?size=${width}x${height}`,
                    width: urlInfo.width,
                    height: urlInfo.height,
                    originalWidth: urlInfo.original.width,
                    originalHeight: urlInfo.original.height,
                };
            }
            else {
                break;
            }
        }
        return originalCreateActiveImage(url);
    };
    return editor;
}

function withElementTypeMethods(editor) {
    /**
     * Customize isVoid
     */
    editor.isVoid = isVoidElement;
    /**
     * Customize isInline
     */
    editor.isInline = isInlineElement;
    return editor;
}

/**
 * Remove trailing spaces in a code line
 */
function normalizeCodeLine(codeline) {
    const children = mergeSegmentsByMark(trimSegments(splitSegmentsAtBoundaries(codeline.children), {
        trimStart: false,
        trimEnd: true,
    }));
    return {
        type: "code-line",
        children,
    };
}
/**
 * Takes a Code block and normalizes it by removing trailing spaces in each
 * code line
 */
function normalizeCode(codeBlock) {
    assertDefined(codeBlock.children);
    const codelines = codeBlock.children.map(normalizeCodeLine);
    return Object.assign(Object.assign({}, codeBlock), { children: codelines });
}

function isBlockType(block, types) {
    return (Object.prototype.hasOwnProperty.call(block, "type") &&
        !!block.type &&
        types.includes(block.type));
}
// TODO: Consider moving these to `editor/types` with an `isLeafElement` method
const TYPES_WITH_LINE_CHILDREN = [
    "p",
    "heading",
    "ordered-list-item",
    "unordered-list-item",
    "task-list-item",
];
/**
 * Is the children of the block a Line
 */
function hasLineChildren(block) {
    return isBlockType(block, TYPES_WITH_LINE_CHILDREN);
}
const VOID_TYPES = ["hr", "media"];
/**
 * Is the block a void block type
 */
function isVoidBlock(block) {
    return isBlockType(block, VOID_TYPES);
}
/**
 * Takes an array of blocks at any position in the document and normalizes it.
 * We use a `BlockLike` type in order to work around the restrictions of
 * using the exact correct types.
 */
function normalizeBlocks(blocks, processSegments) {
    const nextBlocks = [];
    for (const block of blocks) {
        if (hasLineChildren(block)) {
            /**
             * Normalize blocks where the children are known to be a standard line
             * with segments
             */
            nextBlocks.push(Object.assign(Object.assign({}, block), { children: processSegments(block.children) }));
        }
        else if (isVoidBlock(block)) {
            /**
             * Don't normalize void blocks
             */
            nextBlocks.push(block);
        }
        else if (block.type === "code-block") {
            /**
             * Normalize code block
             */
            nextBlocks.push(normalizeCode(block));
        }
        else if (Object.prototype.hasOwnProperty.call(block, "children") &&
            block.children) {
            /**
             * Normalize blocks with children by normalizing their children with
             * the same generic algorithm
             */
            nextBlocks.push(Object.assign(Object.assign({}, block), { children: normalizeBlocks(block.children, processSegments) }));
        }
    }
    return nextBlocks;
}
/**
 * Is this a paragraph type block with no text in it
 */
function isEmptyParagraph(block) {
    if (block.type !== "p")
        return false;
    if (block.children.length !== 1)
        return false;
    const segment = block.children[0];
    if (!isTextSegment(segment))
        return false;
    return segment.text === "";
}
/**
 * Remove any empty trailing paragraphs
 */
function trimTrailingBlocks(blocks) {
    const nextBlocks = [...blocks];
    for (let i = nextBlocks.length - 1; i >= 1; i--) {
        if (!isEmptyParagraph(nextBlocks[i]))
            break;
        nextBlocks.splice(i, 1);
    }
    return nextBlocks;
}
/**
 * Takes a document and returns a normalized version of it that is ready for
 * turning into markdown.
 *
 * Notably, if you convert this to markdown and then turn the markdown back
 * into a document, it should equal this normalized version of the document.
 */
function normalize(blocks) {
    const normalizedBlocks = normalizeBlocks(blocks, normalizeLine);
    const trimmedBlocks = trimTrailingBlocks(normalizedBlocks);
    return trimmedBlocks;
}

function serializeBlockquote(block) {
    const innerParts = serializeBlocks(block.children);
    const outerParts = innerParts.map((part, index) => {
        let { markdown } = part;
        if (index === 0) {
            /**
             * Add the first blockquote character
             */
            markdown = `> ${markdown}`;
        }
        if (index === innerParts.length - 1) {
            /**
             * If we are in the last part, we don't need blockquote characters
             * on the trailing newlines because that will affect the following
             * blocks instead of the current one.
             */
            const matches = markdown.match(/^(.*?)(\n*)$/);
            if (matches == null)
                throw new Error(`This should always match`);
            markdown = `${matches[1].replace(/(\n)/g, "\n> ")}${matches[2]}`;
        }
        else {
            markdown = markdown.replace(/(\n)/g, "\n> ");
        }
        return Object.assign(Object.assign({}, part), { markdown });
    });
    return outerParts;
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeFloor = Math.floor;

/**
 * The base implementation of `_.repeat` which doesn't coerce arguments.
 *
 * @private
 * @param {string} string The string to repeat.
 * @param {number} n The number of times to repeat the string.
 * @returns {string} Returns the repeated string.
 */
function baseRepeat(string, n) {
  var result = '';
  if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
    return result;
  }
  // Leverage the exponentiation by squaring algorithm for a faster repeat.
  // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
  do {
    if (n % 2) {
      result += string;
    }
    n = nativeFloor(n / 2);
    if (n) {
      string += string;
    }
  } while (n);

  return result;
}

var _baseRepeat = baseRepeat;

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite_1(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

var toInteger_1 = toInteger;

/**
 * Repeats the given string `n` times.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to repeat.
 * @param {number} [n=1] The number of times to repeat the string.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {string} Returns the repeated string.
 * @example
 *
 * _.repeat('*', 3);
 * // => '***'
 *
 * _.repeat('abc', 2);
 * // => 'abcabc'
 *
 * _.repeat('abc', 0);
 * // => ''
 */
function repeat(string, n, guard) {
  if ((guard ? _isIterateeCall(string, n, guard) : n === undefined)) {
    n = 1;
  } else {
    n = toInteger_1(n);
  }
  return _baseRepeat(toString_1(string), n);
}

var repeat_1 = repeat;

const BACKTICK_REGEXP = /^([`]{3})/;
/**
 * Looks for codeline that starts with a backtick and returns the number of
 * backticks that it returns.
 */
function getBacktickCountFromText(text) {
    const matchData = text.match(BACKTICK_REGEXP);
    return matchData == null ? 0 : matchData[1].length;
}
/**
 * serialize a codeline into marks and a backtickCount if there
 * are 3 or more consecutive backticks at the beginning of the line.
 */
function serializeCodeLine(codeline) {
    const parts = codeline.children.map((codeText) => {
        if (codeText.text === "") {
            return { markdown: "", string: "" };
        }
        else {
            return { markdown: codeText.text, string: codeText.text };
        }
    });
    parts.push(token("\n", "\n"));
    const text = parts.map((part) => part.markdown).join("");
    const backtickCount = getBacktickCountFromText(text);
    return { parts, backtickCount };
}
/**
 * Takes an array of codelines and returns both the parts and the backtickLookup
 * from it.
 */
function serializeCodeLines(codelines) {
    const parts = [];
    const backtickLookup = {};
    for (const codeline of codelines) {
        const data = serializeCodeLine(codeline);
        parts.push(...data.parts);
        backtickLookup[data.backtickCount] = true;
    }
    return { parts, backtickLookup };
}
/**
 * Finds the number of backticks we need to use by inspecting the backtick
 * lookup
 */
function getBackticksFromLookup(backtickLookup) {
    for (let i = 3;; i++) {
        if (!backtickLookup[i]) {
            return repeat_1("`", i);
        }
    }
}
/**
 * When we serialize a code block, it usually starts with 3 backticks but can
 * be any amount of backticks.
 *
 * It's possible that backticks might be part of the actual codelines so we
 * need to augment the number of backticks used to delineate the beginnign of
 * the code block.
 */
function serializeCode(block) {
    const { parts, backtickLookup } = serializeCodeLines(block.children);
    const backticks = getBackticksFromLookup(backtickLookup);
    const surroundedParts = [
        token(`${backticks}${block.language}\n`, ""),
        ...parts,
        token(`${backticks}\n\n`, "\n"),
    ];
    return surroundedParts;
}

const ESCAPES = [
    "\\",
    "`",
    "*",
    "_",
    "{",
    "}",
    "[",
    "]",
    "(",
    ")",
    "#",
    "+",
    "-",
    ".",
    "!",
    "|",
    "^",
    "~", // sub/strikethrough
];
const ESCAPES_REGEXP = new RegExp(`(${ESCAPES.map((symbol) => `\\${symbol}`).join("|")})`, "g");
/**
 * Escape text that could have an ambiguous meaning in markdown
 */
function escapeText(s) {
    return s
        .replace(ESCAPES_REGEXP, (s) => `\\${s}`)
        .replace(/\n/g, "<br>");
}

/**
 * Serialize a link
 */
function serializeLink(link, contextMarks) {
    const innerParts = serializeSegments(link.children, contextMarks);
    return [token("[", ""), ...innerParts, token(`](${link.url})`, "")];
}
/**
 * Serialize text
 */
function serializeText(segment) {
    if (segment.code) {
        if (segment.text.includes("`")) {
            /**
             * TODO:
             * This is a little hacky at the moment. We are actually adding
             * double backticks but the code that calls the `serializeText` adds the
             * first set of backticks. If one backtick is found in the code, we add
             * the second set.
             *
             * Also... we need to account for if the code mark contains multiple
             * backticks then we need to escape multiple times there as well
             */
            return {
                markdown: `\`\` ${escapeCodeText(segment.text)} \`\``,
                string: segment.text,
            };
        }
        else {
            return {
                markdown: `\`${escapeCodeText(segment.text)}\``,
                string: segment.text,
            };
        }
    }
    else {
        return {
            markdown: escapeText(segment.text),
            string: segment.text,
        };
    }
}
/**
 * Escape text within a code text. We use different logic within code text
 * because there is less to escape as the inside is more literal; however,
 * we do have to escape the backtick itself and newlines are not allowed.
 */
function escapeCodeText(codeText) {
    return codeText.replace(/\n/g, "`<br>`");
}
// /**
//  * Serialize inline code and make sure it is escaped
//  */
// function serializeCode(code: CodeSegmentElement): Part[] {
//   const codeParts: Part[] = code.children.map((segment) => {
//     return {
//       markdown: escapeCodeText(segment.text),
//       string: segment.text,
//     }
//   })
//   return [token("`", ""), ...codeParts, token("`", "")]
// }
/**
 * Serialize a diff into parts that are the closing tokens first and then
 * the new opening tokens next
 */
function serializeDiff(diff) {
    const parts = [];
    if (diff.removeMarks.length > 0) {
        parts.push({
            markdown: tokenizeMarksExceptCode(diff.removeMarks),
            string: "",
        });
    }
    if (diff.addMarks.length > 0) {
        parts.push({ markdown: tokenizeMarksExceptCode(diff.addMarks), string: "" });
    }
    return parts;
}
/**
 * Serialize a line.
 *
 * The most complicated part of this happens in diffMarks and also the
 * normalize that happens to the segments before it gets here.
 *
 * We make sure that the marks are at the proper positions, just outside of
 * non-space segments.
 */
function serializeSegments(segments, contextMarks) {
    const parts = [];
    let prevMarks = contextMarks;
    for (const segment of segments) {
        const markProps = getMarkPropsFromSegment(segment);
        const diff = diffMarksExceptCode({ prevMarks, nextMarkProps: markProps });
        parts.push(...serializeDiff(diff));
        if (isTextSegment(segment)) {
            parts.push(serializeText(segment));
        }
        else if (isLinkSegment(segment)) {
            parts.push(...serializeLink(segment, diff.nextMarks));
        }
        else {
            throw new Error(`Unhandled segment type ${JSON.stringify(segment)}`);
        }
        prevMarks = diff.nextMarks;
    }
    const diff = diffMarksExceptCode({
        prevMarks,
        nextMarkProps: getMarkPropsFromMarks(contextMarks),
    });
    parts.push(...serializeDiff(diff));
    return parts;
}
/**
 * Serialize a line returning an array of `Part` which consists of `markdown`
 * and a text representation as `string`.
 *
 * Takes an optional third argument which allows us to specify if this
 * particular line should forcefully create a zero width space if there is
 * no content.
 *
 * This is important for certain prefixes like the beginning of a list.
 *
 * If we return no content, a bulleted list item that has the markdown `- `
 * will not return a bulleted list. This is because some content is required.
 */
function serializeLine(segments, contextMarks = [], forceZeroWidthSpace = false) {
    if (forceZeroWidthSpace &&
        segments.length === 1 &&
        segments[0].text === "") {
        return [{ markdown: "&ZeroWidthSpace;", string: "" }];
    }
    return serializeSegments(segments, contextMarks);
}

/**
 * serialize the token that comes before a list item based on its checked
 * value.
 */
function serializeListItemToken(depth, block) {
    const indent = range_1(depth)
        .map(() => "   ")
        .join("");
    switch (block.type) {
        case "ordered-list-item":
            return token(`${indent}1. `, "1. ");
        case "unordered-list-item":
            return token(`${indent}- `, "* ");
        case "task-list-item":
            if (block.checked) {
                return token(`${indent}- [x] `, "[x] ");
            }
            else {
                return token(`${indent}- [ ] `, "[ ] ");
            }
        // case true:
        //   return token(`${indent}- [x] `, "[x] ")
        // case false:
        //   return token(`${indent}- [ ] `, "[ ] ")
        // default:
        //   return token(`${indent}- `, "* ")
    }
}
/**
 * serialize list item
 */
function serializeListItem(block, maxDepth) {
    /**
     * When we serialize, markdown doesn't recognize when we skip a depth level.
     *
     * Critically, if we start at a depth of 2 or greater (4 spaces) the line
     * is interpreted as a code block and really messes things up.
     *
     * The logic around `maxDepth` is that the first list item must always be
     * of depth 0 and any subsequent list items can only ever be a maximum
     * depth of 1 more than the previous one.
     *
     * Any way we do it, we aren't respecting the user's wishes. This takes the
     * minimally invasive method (which is also the least amount of code).
     */
    const depth = Math.min(maxDepth, block.depth);
    const prefixToken = serializeListItemToken(depth, block);
    const parts = [
        prefixToken,
        ...serializeLine(block.children, [], true),
        token("\n\n", "\n\n"),
    ];
    return { depth, parts };
}

/**
 * Serialize media block
 */
function serializeMedia(block) {
    return {
        markdown: `![${block.alt}](${block.url})\n\n`,
        string: `${block.alt} (${block.url})`,
    };
}

/**
 * Serialize table row
 */
function serializeTr(tr) {
    const parts = [];
    tr.children.forEach((cell, index) => {
        if (cell.children.length !== 1)
            throw new Error(`Expected td to have exactly one child which should be a paragraph`);
        const paragraphChildren = cell.children[0].children;
        parts.push(...serializeLine(paragraphChildren));
        const isLast = index === tr.children.length - 1;
        if (isLast) {
            parts.push(token("|", " |"));
        }
        else {
            parts.push(token("|", " | "));
        }
    });
    return [token("|", "| "), ...parts, token("\n", "\n")];
}
/**
 * Serialize table
 */
function serializeTable(block) {
    const parts = [];
    const firstChild = block.children[0];
    const headRowParts = serializeTr(firstChild);
    const headDividerMarkdown = `|${block.columns
        .map((column) => {
        switch (column.align) {
            case "left":
                return ":-";
            case "right":
                return "-:";
            case "center":
                return ":-:";
        }
    })
        .join("|")}|\n`;
    parts.push(...headRowParts, token(headDividerMarkdown, ""));
    block.children.slice(1).forEach((tr) => {
        parts.push(...serializeTr(tr));
    });
    parts.push(token("\n", "\n"));
    return parts;
}

/**
 * Serialize an array of blocks
 */
function serializeBlocks(blocks) {
    const parts = [];
    let maxDepth = 0;
    for (let i = 0; i < blocks.length; i++) {
        let nextMaxDepth = 0;
        const block = blocks[i];
        switch (block.type) {
            case "p":
                parts.push(...serializeLine(block.children), token("\n\n", "\n\n"));
                break;
            case "heading":
                parts.push(token(`${"#".repeat(block.level)} `, ""), ...serializeLine(block.children), token("\n\n", "\n\n"));
                break;
            case "hr":
                parts.push(token("---\n\n", "\n\n"));
                break;
            case "code-block":
                parts.push(...serializeCode(block));
                break;
            case "media":
                parts.push(serializeMedia(block));
                break;
            case "ordered-list-item":
            case "unordered-list-item":
            case "task-list-item": {
                const listItemData = serializeListItem(block, maxDepth);
                parts.push(...listItemData.parts);
                nextMaxDepth = listItemData.depth + 1;
                break;
            }
            case "table":
                parts.push(...serializeTable(block));
                break;
            case "blockquote": {
                const blockquoteParts = serializeBlockquote(block);
                parts.push(...blockquoteParts);
                break;
            }
            default:
                throw new Error(`Unhandled block type ${JSON.stringify(block.type)}`);
        }
        maxDepth = nextMaxDepth;
    }
    return parts;
}

/**
 * Takes an array of parts and turns it into the serialized data with markdown
 * and text.
 */
function extractFromParts(parts) {
    const markdown = parts
        .map((part) => part.markdown)
        .join("")
        .trim();
    const text = parts
        .map((part) => part.string)
        .join("")
        .trim();
    return { markdown, text };
}
/**
 * Takes a document and serializes it into markdown and text
 */
function serialize(blocks) {
    try {
        const normalizedBlocks = normalize(blocks);
        const parts = serializeBlocks(normalizedBlocks);
        const data = extractFromParts(parts);
        return data;
    }
    catch (e) {
        console.log("Error in serialize of these blocks");
        console.log(blocks);
        throw e;
    }
}

function withGetMarkdown(editor) {
    /**
     * Add `editor.getMarkdown` method which takes the current value of the
     * editor and converts it to markdown and returns it.
     */
    editor.getMarkdown = () => {
        const { markdown } = serialize(editor.children);
        return markdown;
    };
    return editor;
}

/**
 * NOTE:
 *
 * This is the main entry point for creating an editor for unit testing.
 * It does not include the props from `UseEditorProps` but otherwise has all
 * the functions of the editor which can be useful for testing.
 *
 * WARNING:
 * Do not refactor `withEditor` into `useEditor`. It is required for unit tests.
 *
 * Adds properties to Editor to customize its behavior
 *
 * - Custom Normalizer
 * - Custom Uploader
 * - Custom Props
 *
 * Plus Slate plugins
 *
 * - Slate History
 * - Slate React
 */
function withEditor(editor) {
    editor = withReact(editor);
    editor = withHistory(editor);
    editor = withNormalize(editor);
    editor = withUpload(editor);
    editor = withInsertBreak(editor);
    editor = withDelete(editor);
    editor = withElementTypeMethods(editor);
    editor = withGetMarkdown(editor);
    editor = withActiveImage(editor, [
        "https://dev-files.wysimark.com/f/",
        "https://files.wysimark.com/f/",
    ]);
    return editor;
}
/**
 * WARNING:
 * Do not refactor `withEditor` into `useEditor`. It is required for unit tests.
 */
function useEditor({ initialMarkdown, upload = {
    type: "demo",
    url: "https://app.wysimark.com/api/v1/upload/demo",
}, }, deps = []) {
    const depsRef = useRef([]);
    /**
     * IMPORTANT!
     *
     * We use a `ref` instead of `useMemo` due to an issue with fast refreshing
     * as described in this Slate issue.
     *
     * <https://github.com/ianstormtaylor/slate/issues/4081>
     *
     * Slate expects the Editor object to be the same and if it isn't, throws an
     * error like:
     *
     * `Error: Cannot find a descendant at path [0] in node`
     *
     * The documentation uses `useMemo` but that's not reliable on NextJS with
     * live reloading which, I assume, is similar to CRA live-reload as mentioned
     * in the issue.
     */
    // IMPORTANT! Must be `useRef` not `useMemo`. See above.
    const editorRef = useRef();
    if (!editorRef.current ||
        (editorRef.current && !shallowEquals(depsRef.current, deps))) {
        const editor = withEditor(createEditor());
        editor.initialMarkdown = initialMarkdown;
        editorRef.current = editor;
        depsRef.current = deps;
    }
    /**
     * We want to change these values live in our demo. Since it doesn't affect
     * the content, we can change these references and the next time the user
     * tries to upload, it will get these new values.
     *
     * If we try and swap them and create a new Editor, we get problems.
     */
    editorRef.current.uploadOptions = upload;
    return editorRef.current;
}

export { Wysimark as W, useEditor as u };
//# sourceMappingURL=index-c0bfb315.es.js.map
